{% extends "base.html" %} {% load static %} {% block content %}
{% load stock_filters %} 

<style>
  /* ✅ CRITICAL CSS: IQF Rejection Modal Styles (Fixed UI Collapse) */
.iqf-rejection-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.4) !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  z-index: 10000 !important;
  opacity: 0 !important;
  visibility: hidden !important;
  transition: opacity 0.3s ease, visibility 0.3s ease !important;
  padding: 20px !important;
  overflow-y: auto !important;
}

.iqf-rejection-modal-overlay.active {
  opacity: 1 !important;
  visibility: visible !important;
}

.iqf-rejection-modal-container {
  background: white !important;
  border-radius: 16px !important;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3) !important;
  width: 100% !important;
  max-width: 1000px !important;
  max-height: 90vh !important;
  display: flex !important;
  flex-direction: column !important;
  animation: slideIn 0.3s ease !important;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-50px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.iqf-rejection-modal-header {
  padding: 24px !important;
  border-bottom: 2px solid #f0f0f0 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: space-between !important;
  flex-shrink: 0 !important;
  background: linear-gradient(135deg, #f5f7fa 0%, #ffffff 100%) !important;
  border-radius: 16px 16px 0 0 !important;
}

.iqf-rejection-modal-title {
  margin: 0 !important;
  color: #1a237e !important;
  font-size: 22px !important;
  font-weight: 700 !important;
}

.iqf-rejection-model-badge {
  background: linear-gradient(135deg, #028084 0%, #015c58 100%) !important;
  color: white !important;
  padding: 8px 16px !important;
  border-radius: 8px !important;
  font-weight: 600 !important;
  font-size: 14px !important;
}

.iqf-rejection-modal-close {
  background: none !important;
  border: none !important;
  font-size: 28px !important;
  color: #bbb !important;
  cursor: pointer !important;
  padding: 0 !important;
  width: 40px !important;
  height: 40px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  transition: all 0.3s ease !important;
  border-radius: 50% !important;
}

.iqf-rejection-modal-close:hover {
  background: #f0f0f0 !important;
  color: #d32f2f !important;
  transform: scale(1.1) !important;
}

.iqf-rejection-modal-body {
  flex: 1 !important;
  overflow-y: auto !important;
  padding: 24px !important;
  background: white !important;
}

.iqf-rejection-modal-body::-webkit-scrollbar {
  width: 8px !important;
}

.iqf-rejection-modal-body::-webkit-scrollbar-track {
  background: #f1f1f1 !important;
  border-radius: 10px !important;
}

.iqf-rejection-modal-body::-webkit-scrollbar-thumb {
  background: #bbb !important;
  border-radius: 10px !important;
}

.iqf-rejection-modal-body::-webkit-scrollbar-thumb:hover {
  background: #888 !important;
}

.iqf-rejection-modal-footer {
  padding: 16px 24px !important;
  border-top: 1px solid #f0f0f0 !important;
  display: flex !important;
  gap: 12px !important;
  justify-content: flex-end !important;
  flex-shrink: 0 !important;
  background: #fafafa !important;
  border-radius: 0 0 16px 16px !important;
}

.iqf-modal-btn {
  padding: 10px 24px !important;
  border: none !important;
  border-radius: 8px !important;
  font-size: 14px !important;
  font-weight: 600 !important;
  cursor: pointer !important;
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  transition: all 0.3s ease !important;
}

.iqf-modal-btn.draft {
  background: #007bff !important;
  color: white !important;
}

.iqf-modal-btn.draft:hover {
  background: #0056b3 !important;
  transform: translateY(-2px) !important;
  box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3) !important;
}

.iqf-modal-btn.proceed {
  background: #28a745 !important;
  color: white !important;
}

.iqf-modal-btn.proceed:hover {
  background: #218838 !important;
  transform: translateY(-2px) !important;
  box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3) !important;
}

.iqf-modal-btn.cancel {
  background: #6c757d !important;
  color: white !important;
}

.iqf-modal-btn.cancel:hover {
  background: #5a6268 !important;
  transform: translateY(-2px) !important;
  box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3) !important;
}

.iqf-qty-info-bar {
  display: flex !important;
  gap: 20px !important;
  margin-bottom: 24px !important;
  padding: 20px !important;
  background: linear-gradient(135deg, #f5f7fa 0%, #fffbf0 100%) !important;
  border-radius: 12px !important;
  border: 2px solid #e0e0e0 !important;
}

.iqf-qty-item {
  flex: 1 !important;
  display: flex !important;
  align-items: center !important;
  gap: 12px !important;
  padding: 12px 16px !important;
  background: white !important;
  border-radius: 8px !important;
  border-left: 4px solid #028084 !important;
}

.iqf-qty-item.rw {
  border-left-color: #e67e22 !important;
}

.iqf-qty-item.missing {
  border-left-color: #d32f2f !important;
}

.iqf-qty-item.physical {
  border-left-color: #388e3c !important;
}

.iqf-qty-item i {
  font-size: 18px !important;
  color: #666 !important;
}

.iqf-qty-label {
  font-size: 12px !important;
  color: #666 !important;
  text-transform: uppercase !important;
  font-weight: 600 !important;
  letter-spacing: 0.5px !important;
}

.iqf-qty-value {
  font-size: 20px !important;
  font-weight: 700 !important;
  color: #1a237e !important;
}

.iqf-section-header {
  display: flex !important;
  align-items: center !important;
  justify-content: space-between !important;
  margin: 20px 0 16px 0 !important;
  padding: 12px 16px !important;
  background: #f5f5f5 !important;
  border-left: 4px solid #028084 !important;
  border-radius: 4px !important;
}

.iqf-section-title {
  margin: 0 !important;
  color: #1a237e !important;
  font-size: 16px !important;
  font-weight: 700 !important;
  display: flex !important;
  align-items: center !important;
  gap: 10px !important;
}

.iqf-lot-rejection-toggle {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
}

.iqf-lot-rejection-toggle label {
  margin: 0 !important;
  font-weight: 600 !important;
  color: #666 !important;
  cursor: pointer !important;
}

#rejection-reasons-section {
  border: 2px solid #dee2e6 !important;
  border-radius: 12px !important;
  background: white !important;
  overflow: hidden !important;
}

#accepted-tray-table-container {
  margin-top: 12px !important;
  border: 1px solid #dee2e6 !important;
  border-radius: 6px !important;
  background: white !important;
  overflow: hidden !important;
}

#acceptanceRemarksSection,
#lotRejectionRemarksSection {
  border: 2px solid #dee2e6 !important;
  border-radius: 12px !important;
  padding: 20px !important;
  background: #f8fafb !important;
  margin: 16px 0 !important;
}

/* Make sure table doesn't break the modal layout */
#order-listing,
.table {
  width: 100% !important;
  margin-bottom: 0 !important;
}

/* Prevent modal from collapsing on content updates */
.iqf-rejection-modal-body {
  min-height: 400px !important;
}

/* Ensure modals are always on top */
.iqf-rejection-modal-overlay,
#trayScanModal_DayPlanning,
#delinkModal,
#iqfRejectionModalOverlay {
  z-index: 10000 !important;
}

/* Override any conflicting table styles inside modal */
.iqf-rejection-modal-body .table thead th {
  background-color: #028084 !important;
  color: white !important;
}

.iqf-rejection-modal-body .table tbody tr:hover {
  background-color: #f8f9fa !important;
}
/* ========== Modal Display Control ========== */
/* Hide tray scan modals by default */
#trayScanModal_DayPlanning {
  display: none;
  position: fixed;
  z-index: 10000;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
}

#trayScanModal_DayPlanning.show {
  display: flex !important;
  align-items: center;
  justify-content: center;
}

/* ========== Tablet override — paste at file end (after other table styles) ========== */
/* --- Tablet: freeze first 3 columns consistently with desktop --- */
@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {

*{
  font-size: 20px !important; /* Increase font size for better readability */
}

:root { --app-font-size: 20px; }
.rounded-circle{
  padding: 17px !important;
}
.model-image-tooltip{
  transform: translateX(-25%) !important;
  top: 45% !important;
  z-index: 500000 !important; /* high so it sits above table & scrollbar */

}


  /* Core layout blocks */
  .content-wrapper,
  .card, .card-body,
  .table-responsive,
  #order-listing,
  #trayScanModal_DayPlanning,
  .tray-scan-modal-DayPlanning,
  .pagination-wrapper {
    font-size: var(--app-font-size) !important;
    line-height: 1.35 !important;
  }

  /* Table headings / cells / icons */
  #order-listing th,
  #order-listing td,
  #order-listing thead th {
    font-size: var(--app-font-size) !important;
    vertical-align: middle !important;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  /* Ensure heading/title and date controls match */
  h4.text-left.mt-0.mb-3,
  .calendar-bar .date-input-group label,
  .calendar-bar .date-input-group input,
  #search-date-range-simple,
  #clear-date-filter-simple,
  .calendar-btn,
  #trayScanModal_DayPlanning input.form-control,#trayValidateBtn,
  #trayScanModal_DayPlanning table th, #trayScanModal_DayPlanning table td,
  #modalModelNo_DayPlanning
 {
    font-size: var(--app-font-size) !important;
  }  

  /* Reserve space for filter icons in header cells */
#order-listing th {
  position: relative;
  overflow: visible !important;
  white-space: normal !important; /* allow wrapping */
}

/* Ensure filter icons always stay to the right */
#order-listing th .fa-filter {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px !important;
  opacity: 0.8;
  cursor: pointer;
}

  /* Column 1 */
  #order-listing th:nth-child(1),
  #order-listing td:nth-child(1) {
    position: sticky;
    left: 0 !important;
    min-width: 90px !important;
    max-width: 90px !important;
    background: #f7fafd;
    z-index: 30;
  }

  /* Column 2 */
  #order-listing th:nth-child(2),
  #order-listing td:nth-child(2) {
    position: sticky;
    left: 90px !important;   /* = width of col1 */
    min-width: 125px !important;
    max-width: 125px !important;
    background: #f7fafd;
    z-index: 25;
  }

  /* Column 3 */
  #order-listing th:nth-child(3),
  #order-listing td:nth-child(3) {
    position: sticky;
    left: 215px !important;  /* 75 (col1) + 100 (col2 min) */
    min-width: 140px !important;
    max-width: 140px !important;
    background: #f7fafd;
    z-index: 20;
  }

  /* Sticky header */
  #order-listing thead th {
    position: sticky;
    top: 0;
    z-index: 40;
    background: #028084 !important;
    color: #e5fcff !important;
  }
}

@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {
  .table-container {
    overflow-x: auto;
  }

  /* Other columns (fit remaining space) */
  #order-listing th:nth-child(4)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(5)  { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(6)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(7)  { min-width: 105px !important; max-width: 105px !important; }
  #order-listing th:nth-child(8)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(9)  { min-width: 140px !important; max-width: 145px !important; }
  #order-listing th:nth-child(10) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(11) { min-width: 110px !important; max-width: 110px !important; }
  #order-listing th:nth-child(12) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(13) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(14) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(15) { min-width: 115px !important; max-width: 115px !important; }
  #order-listing th:nth-child(16) { min-width: 130px !important; max-width: 150px !important; }
  #order-listing th:nth-child(17) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(18) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(19) { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(20) { min-width: 130px !important; max-width: 130px !important; }


  /* Prevent overlap */
  #order-listing th:nth-child(-n+3),
  #order-listing td:nth-child(-n+3) {
    z-index: 45 !important;
  }

  /* Hide hidden columns */
  #order-listing th[hidden],
  #order-listing td[hidden] {
    display: none !important;
  }
}
  /* Add to your CSS file for Excel-like grid lines */
  .table-bordered th,
  .table-bordered td {
    border: 1px solid #d9dedf !important;
  }
  /* Make the table header sticky */
  thead th {
    position: sticky;
    top: 0;
    background-color: white; /* or your table header bg color */
    z-index: 5; /* ensure it stays above the table rows */
  }

  #order-listing thead th {
    height: 38px !important; /* Increase as needed */
    background: #028084 !important;
    color: #e5fcff !important;
    vertical-align: middle !important;
    border-bottom: 2.5px solid #bdbdbd !important; /* Thicker grey line below heading */
  }
  /* style for hol/unhold row - blurred bg */
  #order-listing tr:last-child td {
    margin-bottom: 0 !important;
    padding-bottom: 0 !important;
    /* background: #f4f3f3 !important; */
  }
  /* Gird line color combination */
  #order-listing th,
  #order-listing td {
    border-right: 1.5px solid #bababa !important; /* Vertical lines: blue */
    border-bottom: 1.5px solid #121413 !important; /* Horizontal lines: green */
  }

  /* Default: Desktop/Laptop (wider columns for larger font) - server */
  /* #order-listing th:nth-child(1) {
  min-width: 90px;
  max-width: 90px;
} */ /* S.No */
  /* #order-listing th:nth-child(2) {
  min-width: 90px;
  max-width: 100px;
} */ /* Last Updated */
  /* #order-listing th:nth-child(3) {
  min-width: 90px;
  max-width: 120px;
} */ /* Plating */
  #order-listing th:nth-child(4) {
    min-width: 110px;
    max-width: 120px;
  } /* Polishing Stk No */
  #order-listing th:nth-child(5) {
    min-width: 90px;
    max-width: 100px;
  } /* Plating Color */
  #order-listing th:nth-child(6) {
    min-width: 100px;
    max-width: 110px;
  } /* Category */
  #order-listing th:nth-child(7) {
    min-width: 85px;
    max-width: 95px;
  } /* Polish Finish */
  #order-listing th:nth-child(8) {
    min-width: 110px;
    max-width: 110px;
  } /* Version */
  #order-listing th:nth-child(9) {
    min-width: 105px;
    max-width: 105px;
  } /* Tray Cate-Capacity */
  #order-listing th:nth-child(10) {
    min-width: 90px;
    max-width: 100px;
  } /* Source */
  #order-listing th:nth-child(11) {
    min-width: 80px;
    max-width: 80px;
  } /* No of Trays */
  #order-listing th:nth-child(12) {
    min-width: 100px;
    max-width: 105px;
  } /* Input Qty */
  #order-listing th:nth-child(13) {
    min-width: 95px;
    max-width: 100px;
  } /* Process Status */
  #order-listing th:nth-child(14) {
    min-width: 90px;
    max-width: 100px;
  } /*  Action */
  #order-listing th:nth-child(15) {
    min-width: 90px;
    max-width: 100px;
  } /* Lot Status */
  #order-listing th:nth-child(16) {
    min-width: 100px;
    max-width: 100px;
  } /* Current Stage */
  #order-listing th:nth-child(17) {
    min-width: 110px;
    max-width: 100px;
  } /* Remarks */
  #order-listing th:nth-child(18) {
    min-width: 100px;
    max-width: 110px;
  }

  @media (min-width: 600px) and (max-width: 900px) {
    #order-listing {
      table-layout: auto !important; /* Let columns auto-fit content */
      width: 100% !important;
      min-width: unset !important;
      max-width: 100vw !important;
    }
    /* Adjust width for all headings (th) and cells (td) */
    #order-listing th,
    #order-listing td {
      min-width: 160px !important;
      max-width: 260px !important;
      width: 180px !important;
    }
    #order-listing th {
      position: relative;
      padding-right: 48px !important; /* More space for filter icon */
      white-space: normal !important;
      overflow: visible !important;
      text-overflow: ellipsis;
    }
    #order-listing th .fa-filter {
      position: absolute;
      right: 18px !important;
      top: 50%;
      transform: translateY(-50%);
      z-index: 2;
      background: transparent;
      pointer-events: auto;
    }
  }
  /* Right-align filter icons */
  #order-listing th .fa-filter {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 11px;
    opacity: 0.7;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  #order-listing th .fa-filter:hover {
    opacity: 1;
  }

  #order-listing th:last-child,
  #order-listing td:last-child {
    border-right: none;
    max-width: 95px;
    min-width: 100px;
  }
  /* Overall Table Shrink */
  #order-listing tr,
  #order-listing td,
  #order-listing th {
    height: 20px !important;
    padding-top: 2px !important;
    padding-bottom: 2px !important;
    padding-left: 6px !important;
    padding-right: 6px !important;
  }
  /* Table heading font size */
  /* Add this at the end of your <style> block in DP_PickTable.html */

  /* Professional table header styling with proper text wrapping */
  #order-listing th {
    position: relative;
    padding: 8px 12px 8px 16px !important;
    text-align: left !important;
    vertical-align: middle !important;
    white-space: normal !important;
    line-height: 1.3 !important;
    word-break: keep-all !important;
    hyphens: none !important;
    /* font-size: 13px; */
    /* font-weight: 600 !important; */
    background: #028084 !important;
    color: #e5fcff !important;
    border-bottom: 2.5px solid #bdbdbd !important;
    /* min-width: 80px;
  max-width: 140px; */
    overflow-wrap: break-word;
    word-wrap: break-word;
    z-index: 20 !important;
  }

  /* Make sure header cells for sticky columns are always above body cells */
  /* Fix: Prevent shadow/rows from showing behind sticky columns while scrolling */
  #order-listing th:nth-child(-n + 3),
  #order-listing td:nth-child(-n + 3) {
    z-index: 30 !important;
    box-shadow: 2px 0 8px rgba(0, 0, 0, 0.04);
  }

  /* Prevent sticky columns from overlapping sticky header */
  #order-listing td:nth-child(-n + 3) {
    z-index: 11 !important;
  }
  /* Make the first column sticky and opaque */
  #order-listing td:first-child,
  #order-listing th:first-child {
    position: sticky;
    left: 0;
    background: #fff; /* Or match your table background */
    z-index: 2; /* Above blurred rows */
    box-shadow: 2px 0 4px rgba(0, 0, 0, 0.03); /* Optional: subtle shadow */
  }
  /* Force specific table headers to wrap onto two lines */
  #order-listing th:nth-child(4),   /* Polishing Stk No */
#order-listing th:nth-child(5),   /* Plating Color */
#order-listing th:nth-child(7),   /* Polish Finish */
#order-listing th:nth-child(9),   /* Tray Cate-Capacity */
#order-listing th:nth-child(11),  /* No of Tray */
#order-listing th:nth-child(12),  /* Input Qty */
#order-listing th:nth-child(13)   /* Process Status */ {
    white-space: normal !important;
    line-height: 1.2 !important;
    word-break: break-word !important;

    text-align: center;
    vertical-align: middle;
    padding-top: 5px !important;
    padding-bottom: 5px !important;
  }
  /* Freeze style for 1st - 3 columns */
  /* --- Freeze first 3 columns and table header for #order-listing --- */
  #order-listing {
    position: relative;
    border-collapse: separate !important;
    border-spacing: 0;
    background: #fff;
    /* Ensure enough left padding for sticky columns */
  }

  #order-listing th,
  #order-listing td {
    background-clip: padding-box;
    /* Prevent overlap artifacts */
    z-index: 1;
  }

  /* Sticky header */
  #order-listing thead th {
    position: sticky;
    top: 0;
    z-index: 10;
    background: #028084 !important;
    color: #e5fcff !important;
  }

  /* Freeze 1st column */
  #order-listing th:nth-child(1),
  #order-listing td:nth-child(1) {
    position: sticky;
    left: 0 !important;
    z-index: 12; /* Above header */
    background: #f7fafd;
    min-width: 75px;
    max-width: 75px;
  }

  /* Freeze 2nd column - Last Updated*/
  #order-listing th:nth-child(2),
  #order-listing td:nth-child(2) {
    position: sticky;
    left: 75px; /* Match min-width of 1st col */
    z-index: 12;
    background: #f7fafd;
    min-width: 100px; /* Increased width */
    max-width: 110px; /* Increased width */
  }

  /* Freeze 3rd column */
  #order-listing th:nth-child(3),
  #order-listing td:nth-child(3) {
    position: sticky;
    left: 175px; /* 100px (1st) + 90px (2nd) */
    z-index: 12;
    background: #f7fafd;
    min-width: 130px; /* Increased width 100 - old value*/
    max-width: 140px; /* Increased width  110 - old value*/
  }

  /* Prevent sticky columns from overlapping sticky header */
  #order-listing th:nth-child(-n + 3) {
    z-index: 12;
  }
  #order-listing td:nth-child(-n + 3) {
    z-index: 11;
  }

  /* Ensure sticky columns and header work together */
  #order-listing th,
  #order-listing td {
    box-sizing: border-box;
    /* Prevent content shake */
    /* overflow: hidden; */
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .blurred-heading,
  .blurred-cell {
    filter: blur(2px) grayscale(0.7) opacity(0.6);
    pointer-events: none !important;
    user-select: none;
    cursor: not-allowed;
    background: #f5f5f5 !important;
  }
  /* Show remark tooltip above the trigger instead of below */
  .remark-tooltip {
    top: auto !important;
    bottom: 110% !important;
  }
  #trayScanDetails.table-grid {
    display: grid !important;
    grid-template-columns: 94px 175px 150px !important;
    gap: 0px !important;
    max-height: 300px !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
    padding-right: 10px;
    margin-top: 10px;
    border: 1px solid #ddd;
  }

  #trayScanDetails.table-grid::-webkit-scrollbar {
    width: 8px;
  }

  #trayScanDetails.table-grid::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }

  #trayScanDetails.table-grid::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
  }

  #trayScanDetails.table-grid::-webkit-scrollbar-thumb:hover {
    background: #555;
  }


  
  /* Override only when modal is open */
  .tray-scan-modal.open {
    width: 498px !important;  /* UPDATED: Changed from 630px to 498px */
    margin-right: 0;
    right: 0; /* Slide in */
  }
  
  
  /* For the 4-column layout (with validation status) */
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 50px 1fr 100px 140px !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
  }

  /* Styling individual grid cells, only inside trayScanDetails */
  #trayScanDetails.table-grid > div {
    background: #f7f7f7;
    padding: 8px 12px;
    font-size: 12px;
    border: 1px solid #ddd;
    margin: 0; /* reset any margin from <p> or others */
  }

  /* S.no column specific styling */
  #trayScanDetails.table-grid > div:nth-child(3n + 1):not(:nth-child(-n + 4)) {
    text-align: center;
    font-weight: 600;
    padding: 8px 4px; /* Reduced horizontal padding for S.no */
  }

  /* For mobile responsiveness */
  @media (max-width: 768px) {
    #trayScanDetails.table-grid {
      grid-template-columns: 45px 1fr 1fr !important; /* Even smaller S.no column on mobile */
    }
    #trayScanDetails.table-grid.four-column {
      grid-template-columns: 40px 1fr 80px 100px !important;
    }
    #trayScanDetails.table-grid
      > div:nth-child(3n + 1):not(:nth-child(-n + 4)) {
      padding: 6px 2px; /* Further reduced padding on mobile */
      font-size: 11px;
    }
  }

  /* For very small screens */
  @media (max-width: 480px) {
    #trayScanDetails.table-grid {
      grid-template-columns: 35px 1fr 80px !important; /* Minimal S.no column */
    }
    #trayScanDetails.table-grid.four-column {
      grid-template-columns: 30px 1fr 70px 90px !important;
    }
  }

/* ========================================
   IQF REJECTION MODAL RESPONSIVE STYLES
   ======================================== */

/* ✅ Desktop/Laptop (default - optimized for 1920x1080 and above) */
@media (min-width: 1401px) {
  #rejection-reasons-section {
    max-width: 750px !important;
    min-width: 700px !important;
  }
  
  #rejection-reasons-section th,
  #rejection-reasons-section td {
    font-size: 14px !important;
  }
  
  .rejection-qty-input {
    max-width: 70px !important;
    height: 32px !important;
    font-size: 13px !important;
  }
}

/* ✅ Tablet Landscape (1024px - 1400px) */
@media (pointer: coarse) and (min-width: 1024px) and (max-width: 1400px) {
  #rejection-reasons-section {
    max-width: 900px !important;
    min-width: 850px !important;
    max-height: 320px !important;
  }
  
  #rejection-reasons-section th {
    padding: 18px 14px !important;
    font-size: 18px !important;
  }
  
  #rejection-reasons-section td {
    padding: 14px 10px !important;
    font-size: 17px !important;
  }
  
  .rejection-qty-input {
    max-width: 90px !important;
    height: 42px !important;
    font-size: 17px !important;
  }
  
  #modalModelNo {
    font-size: 24px !important;
  }
  
  #modalLotQty, #modalMissingQty, #modalPhysicalQty {
    font-size: 20px !important;
  }
  
  #draftButton, #proceedButton, #cancelButton {
    padding: 14px 38px !important;
    font-size: 18px !important;
  }
}

/* ✅ Tablet Portrait (768px - 1023px) */
@media (min-width: 768px) and (max-width: 1023px) {
  #rejection-reasons-section {
    max-width: 95% !important;
    min-width: 700px !important;
    max-height: 280px !important;
  }
  
  #rejection-reasons-section th {
    padding: 16px 12px !important;
    font-size: 16px !important;
  }
  
  #rejection-reasons-section td {
    padding: 12px 8px !important;
    font-size: 15px !important;
  }
  
  .rejection-qty-input {
    max-width: 80px !important;
    height: 38px !important;
    font-size: 15px !important;
  }
  
  #modalModelNo {
    font-size: 22px !important;
  }
  
  #draftButton, #proceedButton, #cancelButton {
    padding: 12px 30px !important;
    font-size: 16px !important;
  }
}

/* ✅ Mobile Landscape (576px - 767px) */
@media (min-width: 576px) and (max-width: 767px) {
  #rejection-reasons-section {
    max-width: 100% !important;
    min-width: 550px !important;
    max-height: 250px !important;
    font-size: 12px !important;
  }
  
  #rejection-reasons-section th {
    padding: 12px 8px !important;
    font-size: 13px !important;
  }
  
  #rejection-reasons-section th i {
    display: none; /* Hide icons on small screens */
  }
  
  #rejection-reasons-section td {
    padding: 10px 6px !important;
    font-size: 12px !important;
  }
  
  .rejection-qty-input {
    max-width: 60px !important;
    height: 32px !important;
    font-size: 12px !important;
  }
  
  #modalModelNo {
    font-size: 16px !important;
  }
  
  #modalLotQty, #modalMissingQty, #modalPhysicalQty {
    font-size: 14px !important;
  }
  
  #draftButton, #proceedButton, #cancelButton {
    padding: 10px 20px !important;
    font-size: 13px !important;
    gap: 4px !important;
  }
  
  /* Stack buttons vertically on very small screens */
  #draftButton i, #proceedButton i, #cancelButton i {
    font-size: 12px !important;
  }
}

/* ✅ Mobile Portrait (less than 576px) */
@media (max-width: 575px) {
  #rejection-reasons-section {
    max-width: 100% !important;
    min-width: 100% !important;
    max-height: 220px !important;
    overflow-x: auto !important;
  }
  
  #rejection-reasons-section table {
    min-width: 500px; /* Allow horizontal scroll */
  }
  
  #rejection-reasons-section th {
    padding: 10px 6px !important;
    font-size: 11px !important;
  }
  
  #rejection-reasons-section th i {
    display: none;
  }
  
  #rejection-reasons-section td {
    padding: 8px 4px !important;
    font-size: 11px !important;
  }
  
  .rejection-qty-input {
    max-width: 50px !important;
    height: 28px !important;
    font-size: 11px !important;
  }
  
  #modalModelNo {
    font-size: 14px !important;
  }
  
  #modalLotQty, #modalMissingQty, #modalPhysicalQty {
    font-size: 12px !important;
  }
  
  /* Stack buttons vertically */
  #draftButton, #proceedButton, #cancelButton {
    padding: 10px 18px !important;
    font-size: 12px !important;
    width: 100%;
    max-width: 200px;
  }
  
  /* Stack button container */
  div[style*="justify-content: center"] {
    flex-direction: column !important;
    align-items: center !important;
  }
}

/* ✅ Input focus states - all screens */
.rejection-qty-input:focus {
  outline: none !important;
  border-color: #026066 !important;
  box-shadow: 0 0 0 3px rgba(2, 128, 132, 0.2) !important;
  transform: scale(1.05);
}

.rejection-qty-input:hover:not(:disabled) {
  border-color: #026066 !important;
  box-shadow: 0 2px 8px rgba(2, 128, 132, 0.15) !important;
}

/* ✅ Checkbox hover enhancement */
#batchRejection:hover {
  cursor: pointer;
  transform: scale(1.1);
}

/* ✅ Table row hover effect */
#rejection-table-body tr:hover {
  background: linear-gradient(135deg, #e8f5f5 0%, #d4edda 100%) !important;
  transform: scale(1.01);
  transition: all 0.2s ease;
}

/* ========================================
   END IQF REJECTION MODAL RESPONSIVE STYLES
   ======================================== */

/* ✅ IQF Confirmation Modal Styles */
.iqf-confirmation-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1050;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

.iqf-confirmation-modal.open {
  opacity: 1;
  visibility: visible;
}

.iqf-confirmation-modal-content {
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  max-width: 600px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  position: relative;
  padding: 20px;
}

.iqf-confirmation-modal-close {
  position: absolute;
  top: 10px;
  right: 15px;
  font-size: 24px;
  cursor: pointer;
  color: #aaa;
}

.iqf-confirmation-modal-close:hover {
  color: #000;
}

/* ✅ IQF Modal Alert Styles - Center Screen */
.iqf-modal-alert {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10002;
  min-width: 400px;
  max-width: 600px;
}
</style>

<div class="content-wrapper">
  <div class="row">
    <div class="col-12 grid-margin stretch-card">
      <div class="card">
        <div class="card-body">
          <div class="mb-4">
            <h5 class="text-left mt-0 mb-0 d-inline-block" style="font-weight:700;">
              IQF / Pick Table
              <button type="button" class="btn btn-primary btn-sm ms-3" id="scanButton" 
                      style="background-color: #028084; border-color: #028084; font-weight: 600; vertical-align: middle;">
                <i class="fa fa-qrcode" style="margin-right: 6px;"></i>
                Scan
              </button>
              <span id="scanStatusMessage" style="display: none; margin-left: 12px; vertical-align: middle; color: #28a745; font-size: 15px; font-weight: 700;">PLEASE SCAN</span>
            </h5>
            
            <!-- Hidden input for scanner -->
            <input type="text" id="scanHiddenInput" style="position: absolute; left: -9999px; opacity: 0;" />
            
            <!-- Status message -->
            <div id="scanMessage" style="display: none; margin-top: 8px; padding: 6px 12px; border-radius: 4px; font-size: 14px; font-weight: 600;"></div>
          </div>
          <!-- Table Section -->
          <div class="table-responsive">
            <table id="order-listing" class="table">
                <thead>
                  <tr>
                    <th>
                      S.No <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Last<br>Updated
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating <br> Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                     <th>
                      Polishing Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating Color
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                     <th>
                      Category
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polish Finish
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>

                    <th style="display: none;">
                      Version <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>

                    <th>
                      Tray Cate- <br> Capacity
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Input Source
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      No of Trays<i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      RW Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Physical Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Accept Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                      </th>
                    <th>
                      Reject Qty<i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Process Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Action <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Lot Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th style="cursor: pointer;min-width: 100px;max-width: 100px;">
                      Current <br> Stage
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
 
                    <th>
                      Remarks <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                   
                  </tr>
                </thead>
                <tbody>
                  <!-- Row 1 - Highlighted -->
                   {% for data in master_data %}

                  <tr class="highlighted-tray-scan" 
                      data-batch-id="{{data.batch_id}}" 
                      data-lot-qty="{{ data.brass_rejection_total_qty|default:'0' }}"
                      data-available-qty="{{ data.available_qty }}" 
                      data-brass-onhold-picking="{{ data.iqf_onhold_picking }}"
                      data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
                          data-stock-lot-id="{{ data.stock_lot_id }}"
                          data-missing-qty="{{ data.iqf_missing_qty}}"
                          data-physical-qty="{{ data.iqf_physical_qty }}">

                      <td {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                    <span style="display:flex; align-items:center; gap:3px;">
                      {% if is_admin %} 
                        <!-- Admin users: Show toggle switch -->
                        <label class="hold-toggle-switch" style="margin-bottom:0;">
                          {% if not data.iqf_hold_lot %}
                            <input type="checkbox" class="hold-toggle-btn" checked />
                            <span class="hold-slider"></span>
                          {% else %}
                            <input type="checkbox" class="hold-toggle-btn" />
                            <span class="hold-slider"></span>
                          {% endif %}
                        </label>
                        <!-- Hold remark icon -->
                        <span class="hold-remark-icon" 
                              style="display: {% if data.iqf_hold_lot or data.iqf_release_lot or data.iqf_holding_reason or data.iqf_release_reason %}inline-block{% else %}none{% endif %}; cursor:pointer;" 
                              title="{% if data.iqf_holding_reason %}Holding Reason: {{ data.iqf_holding_reason }}{% endif %}{% if data.iqf_holding_reason and data.iqf_release_reason %}&#10;{% endif %}{% if data.iqf_release_reason %}Release Reason: {{ data.iqf_release_reason }}{% endif %}">
                          {% if data.iqf_hold_lot or data.iqf_release_lot or data.iqf_holding_reason or data.iqf_release_reason %}
                            <img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />
                          {% endif %}
                        </span>
                      {% else %}
                        <!-- Non-admin: Only show view icon if there's a holding/release reason -->
                        {% if data.iqf_hold_lot or data.iqf_release_lot or data.iqf_holding_reason or data.iqf_release_reason %}
                          <span class="hold-remark-icon" 
                                style="display:inline-block; cursor:pointer;" 
                                title="{% if data.iqf_holding_reason %}Holding Reason: {{ data.iqf_holding_reason }}{% endif %}{% if data.iqf_holding_reason and data.iqf_release_reason %}&#10;{% endif %}{% if data.iqf_release_reason %}Release Reason: {{ data.iqf_release_reason }}{% endif %}">
                            <img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:18px; height:18px;" />
                          </span>
                        {% endif %}
                      {% endif %}
                      <span class="sno-value">{{ page_obj.start_index|add:forloop.counter0 }}</span>
                    </span>
                    {% if data.send_brass_audit_to_iqf %}
                      <i class="fa fa-info-circle" style="color: #028084; font-size:13px;" data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="Audit"></i>
                      {% endif %}
                  </td>  
                      <!-- <td>
                      4 <i class="fa fa-info-circle" style="color: #028084; font-size:13px;" data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="IQF"></i>
                    </td>-->                  
                    <td style="white-space:normal;word-break:break-all;"   {% if data.iqf_hold_lot %} class="row-inactive-blur" {% endif %}>
                              {{ data.bq_last_process_date_time|date:"d-M-y"  }}<br>
                        <span style="display:inline-block; margin-top:4px;word-break: break-all;">{{ data.bq_last_process_date_time|date:"h:i A" }}</span>
                        
                        </td>

                            <td {% if data.iqf_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <span class="model-hover-trigger" style="cursor: pointer; word-break: break-all;">
                        {{ data.plating_stk_no|highlight_plating_color|safe_html }}
                        <div class="model-image-tooltip" style="position: absolute; left: 80%; top: 110%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 18px; z-index: 9999; display: flex; flex-direction: column; gap: 8px; opacity: 0; pointer-events: none; transition: opacity 0.2s; min-width: 220px;">
                          
                          <!-- Header with Info and Close buttons -->
                          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <button class="info-btn" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer;">
                               Info
                            </button>
                            <button class="close-btn" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer;">
                               Close
                            </button>
                          </div>

                          <!-- Image gallery section -->
                          <div style="display: flex; align-items: center; gap: 8px;">
                            <!-- Hide scroll buttons since only one image is shown -->
                            <div class="img-gallery" style="display: flex; gap: 6px; overflow: hidden; width: 180px;">
                              <img src="{{ data.model_images.0|default:'/static/assets/images/imagePlaceholder.png' }}" style="width: 55px; height: 55px; object-fit: cover; border-radius: 6px;" />
                            </div>
                          </div>
                        </div>
                      </span>
                    </td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.polishing_stk_no|default:"N/A"|highlight_polish_finish|safe_html }}</td>

                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.plating_color }}</td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.category }}</td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.polish_finish}}</td>
                    <td style="display: none;">{{data.version__version_name}}</td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.tray_type}}-{{data.tray_capacity}}</td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.location__location_name}}</td>
                    
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.no_of_trays}}</td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                      <span class="lot-qty" style="min-width: 30px; text-align: right">
                        {% if data.send_brass_audit_to_iqf %}
                          {{ data.brass_audit_rejection_qty }}
                        {% else %}
                          {{ data.brass_rejection_total_qty }}
                        {% endif %}
                      </span>
                      <span style="display: inline-flex; align-items: center; gap: 4px;">
                        {% if not data.iqf_accepted_qty_verified %}
                          <!-- Show checkbox before save -->
                          <input type="checkbox"
                            class="ip-checkbox"
                            data-lot-id="{{ data.stock_lot_id }}"
                            style="width: 15px; height: 15px"
                            {% if data.iqf_accepted_qty_verified %}checked disabled{% endif %} />
                          {% else %}
                          <!-- Show green tick after save -->
                          <span style="
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            width: 19px;
                            height: 19px;
                            border-radius: 50%;
                            background: #0c8249;
                            color: white;
                            font-size: 14px;
                            font-weight: bold;
                            margin-left: 2px;
                          ">
                            &#10003;
                          </span>
                        {% endif %}
                        <input type="text"
                          class="missing-qty-input"
                          value="{{ data.iqf_missing_qty|default_if_none:'' }}"
                          style="width: 36px; padding: 1px 3px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px;"
                          {% if data.iqf_accepted_qty_verified %}disabled{% endif %} />
                      </span>
                    </td>
                      <td  {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                      {{data.iqf_physical_qty}}
                    </td>

                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                        {{data.iqf_accepted_qty|default:0}}
                    </td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                        {{data.iqf_rejection_qty|default:0}}
                    </td>
                    <!-- Process Status Column -->
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                      <div class="d-flex">
                        <!-- Q: Green if iqf_accepted_qty_verified, else gray -->
                        <div
                          title="Tray Scan"
                          class="d-flex align-items-center justify-content-center rounded-circle ms-1"
                          style="
                            width: 25px;
                            height: 25px;
                            background-color: {% if data.iqf_accepted_qty_verified %}#0c8249{% else %}#bdbdbd{% endif %};
                            color: white;
                            font-weight: bold;
                            line-height: 20px;
                            text-align: center;
                            padding: 5px;
                          "
                        >
                          Q
                        </div>
                        <!-- QC: Green if iqf_rejection or iqf_acceptance, else gray -->
                        <div 
                          title="Tray Scan"
                          class="d-flex align-items-center justify-content-center rounded-circle ms-1"
                          style="
                            width: 25px;
                            height: 25px;
                        
                              {% if data.iqf_rejection or data.iqf_acceptance or data.iqf_few_cases_acceptance %}                              
                              background-color: #0c8249;
                              {% elif data.Draft_Saved %}
                              background: linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                              {% else %}
                              background-color: #bdbdbd;
                              {% endif %}
                              
                            color: white;
                            font-weight: bold;
                            line-height: 20px;
                            text-align: center;
                            padding: 5px;
                          "
                        >
                          QC
                        </div>
                      </div>
                    </td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                      
                      {% if data.iqf_accepted_qty_verified %}

                      <a href="#" class="delete-batch-btn" title="Delete" data-batch-id="{{ data.batch_id }}" data-stock-lot-id="{{ data.stock_lot_id }}">
                        <img src="{% static 'assets/icons/bin.png' %}" alt="Delete" style="width: 20px; margin-right: 8px; height: auto" />
                      </a>
                      {% else %}

                        <span title="Delete Disabled" style="opacity: 0.5; pointer-events: none;">
                          <img src="{% static 'assets/icons/bin.png' %}" alt="Delete Disabled" style="width: 20px; margin-right: 8px; height: auto; filter: grayscale(1) opacity(0.5);" />
                        </span>
                      {% endif %}
                      
                      {% if data.iqf_acceptance %}
                        <!-- Fully Accepted state -->
                        <span class="btn btn-social-icon-text btn-twitter"
                              style="background-color: #66bb6a; pointer-events: none; opacity: 0.8; cursor: not-allowed;">
                          <i class="fa fa-check-circle"></i>Accepted
                        </span>
                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                                style="background-color: #e57373; opacity: 0.6; cursor: not-allowed; pointer-events: none;"
                                data-stock-lot-id="{{ data.stock_lot_id }}"
                                data-batch-id="{{ data.batch_id }}"
                                disabled>
                          <i class="fa fa-times-circle"></i>Reject
                        </button>

                      {% elif data.iqf_onhold_picking %}

<button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
        style="background-color: #84bbf3; color: #fff; border: 2px solid #1565c0; box-shadow: 0 2px 8px rgba(132,187,243,0.12);"
        data-stock-lot-id="{{ data.stock_lot_id }}"
        data-batch-id="{{ data.batch_id }}"
        data-model-no="{{ data.plating_stk_no }}"
        data-lot-qty="{{ data.brass_rejection_total_qty }}"
        data-missing-qty="{{ data.iqf_missing_qty|default:'' }}"
        data-physical-qty="{{ data.iqf_physical_qty|default:'' }}">
<i class="fa fa-check-circle" style="color: #fff; background: #1976d2; border-radius: 50%; padding: 2px;"></i>Verify Trays</button>
                      {% elif data.iqf_rejection or data.iqf_few_cases_acceptance %}
                        <!-- Rejected or Few Cases Accepted state (but not on-hold) -->
                        {% if not data.iqf_onhold_picking %}

                          <span class="btn btn-social-icon-text btn-youtube"
                                style="background-color: #e57373; pointer-events: none; opacity: 0.8; cursor: not-allowed;">
                            <i class="fa fa-times-circle"></i>Rejected
                          </span>
                        {% endif %}

                      {% else %}
                        <!-- Default state - Both buttons enabled -->

                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                                style="background-color: #eaab36; color: #fff; border: 2px solid #b38f00; box-shadow: 0 2px 8px rgba(234,171,54,0.12);"
                                data-stock-lot-id="{{ data.stock_lot_id }}"
                                data-batch-id="{{ data.batch_id }}"
                                data-model-no="{{ data.plating_stk_no }}"
                                data-lot-qty="{{ data.brass_rejection_total_qty|default:'0' }}"
                                data-missing-qty="{{ data.iqf_missing_qty|default:'0' }}"
                                data-physical-qty="{{ data.iqf_physical_qty|default:'0' }}"
                                >
                          <i class="fa fa-check-circle" style="color: #fff; background: #b38f00; border-radius: 50%; padding: 2px;"></i>Audit
                        </button>
                      {% endif %}
                      <!-- Eye icon to view submitted "Tray Scan Table" -->
<a
    href="#"
    title="View"
    class="text-primary tray-scan-btn-Jig"
    style="text-decoration: underline"
    data-stock-lot-id="{{ data.stock_lot_id }}"
    data-batch-id="{{ data.batch_id }}"
    data-model-no="{{ data.plating_stk_no}}"
    data-no-of-trays="{{ data.no_of_trays }}"
    data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
    data-moved-to-d-picker="{{ data.Moved_to_D_Picker }}"
    data-tray-qty-list="{{ data.tray_qty_list|default:'[]'|safe }}"
    data-model-image="{{ data.model_images.0|default:'' }}"
    data-total-batch-quantity="{{ data.display_physical_qty }}"
    data-lot-qty="{{ data.brass_rejection_total_qty }}"
    data-missing-qty="{{ data.iqf_missing_qty }}"
    data-physical-qty="{{ data.iqf_physical_qty }}">

    <img
        src="{% static 'assets/icons/view.png' %}"
        alt="View"
        style="width: 20px; margin-right: 8px; height: auto; cursor:pointer;"
    />
</a>
                    </td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                      {% if data.iqf_hold_lot  %}
                       <div
                          class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="
                            border: 1px solid #dc3545;
                            background-color: #f8d7da;
                            color: #721c24;
                            font-size: 12px;
                            white-space: nowrap;
                            padding: 5px;
                          "
                        >
                          On Hold
                        </div>
                      {% elif data.Draft_Saved %}
                        <div
                          class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="
                            border: 2px solid #4997ac;
                            background-color: #d1f2f3;
                            color: #03425d;
                            font-size: clamp(0.75rem, 2vw, 0.875rem);
                            white-space: nowrap;
                            padding-top: 0.5rem;
                            padding-bottom: 0.5rem;
                          "
                        >
                          Draft
                        </div>
                      {% elif data.iqf_rejection or data.iqf_few_cases_acceptance or data.iqf_acceptance %}
                        <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                            style="border: 2px solid #0d5d17; background-color: #c5f9c2; color: #2f801b; font-size: clamp(0.3rem, 2vw, 0.875rem); white-space: nowrap; padding: 0.3rem;">
                          Yet to Release
                        </div>
                      {% else %}
                        <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                            style="border: 2px solid #f9a825; background-color: #fff8e1; color: #b26a00; font-size: clamp(0.3rem, 2vw, 0.875rem); white-space: nowrap; padding: 0.3rem;">
                          Yet to Start
                        </div>
                      {% endif %}
                    </td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                      <div
                        class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                        style="
                          border: 2px solid
                            {% if data.last_process_module == 'Input screening' %}
                              #0d5d17
                            {% elif data.last_process_module == 'IQF' %}
                              #f9a825
                            {% elif data.last_process_module == 'DayPlanning' %}
                              #1976d2
                            {% else %}
                              #9adeed
                            {% endif %};
                          background-color:
                            {% if data.last_process_module == 'Input screening' %}
                              #c5f9c2
                            {% elif data.last_process_module == 'IQF' %}
                              #fff8e1
                            {% elif data.last_process_module == 'DayPlanning' %}
                              #d1eaff
                            {% else %}
                              #d1edf3
                            {% endif %};
                          color:
                            {% if data.last_process_module == 'Input screening' %}
                              #2f801b
                            {% elif data.last_process_module == 'IQF' %}
                              #b26a00
                            {% elif data.last_process_module == 'DayPlanning' %}
                              #033b5d
                            {% else %}
                              #033b5d
                            {% endif %};
                          font-size: clamp(0.75rem, 2vw, 0.875rem);
                          white-space: nowrap;
                          padding-top: 0.5rem;
                          padding-bottom: 0.5rem;
                        "
                      >
                        {{ data.last_process_module|default:"N/A" }}
                      </div>
                    </td>
                    <td {% if data.iqf_hold_lot %} class="row-inactive-blur"{% endif %}>
                      {% if not data.iqf_acceptance and not data.iqf_rejection and not data.iqf_rejection_tray_scan_status and not data.iqf_few_cases_acceptance %}

                      <!-- VoiceRec with tooltip (audio remark) -->
                    <!-- VoiceRec with tooltip (audio remark) -->
                    <a
                      href="#"
                      title="Add Audio Remark"
                      class="remark-tooltip-trigger"
                      style="
                        display: inline-flex;
                        align-items: center;
                        height: 28px;
                        margin-left: 0;
                        position: relative;
                        cursor: pointer;
                      "
                    >
                      <img
                        src="{% static 'assets/icons/rec.png' %}"
                        alt="VoiceRec"
                        style="width: 20px; height: 20px"
                      />
                      <div
                        class="remark-tooltip"
                        style="
                          position: absolute;
                          top: 110%;
                          left: 50%;
                          transform: translateX(-50%);
                          width: 265px;
                          background: #fff;
                          border: 1px solid #ccc;
                          border-radius: 6px;
                          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                          opacity: 0;
                          visibility: hidden;
                          transition: opacity 0.3s ease, visibility 0.3s ease;
                          padding: 10px;
                          z-index: 1000;
                        "
                      >
                        <!-- Audio recording UI placeholder -->
                        <div
                          style="display: flex; align-items: center; gap: 10px"
                        >
                          <button
                            type="button"
                            style="
                              background: #28a745;
                              color: #fff;
                              border: none;
                              border-radius: 50%;
                              width: 40px;
                              height: 40px;
                              font-size: 20px;
                              display: flex;
                              align-items: center;
                              justify-content: center;
                            "
                          >
                            <i class="fa fa-microphone"></i>
                          </button>
                          <span style="font-size: 14px; color: #333"
                            >Hold to record audio</span
                          >
                          <div style="text-align: right; margin-top: 10px">
                            <button
                              type="button"
                              style="
                                background-color: #007bff;
                                color: #fff;
                                border: none;
                                padding: 6px 12px;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 14px;
                              "
                            >
                              <i class="fa fa-send"></i>
                            </button>
                          </div>
                        </div>
                      </div>
                    </a>
                    <a
                      href="#"
                      title="Add Remark"
                      class="remark-tooltip-trigger"
                      style="
                        display: inline-flex;
                        align-items: center;
                        height: 20px;
                        margin-left: 5px;
                        position: relative;
                        cursor: pointer;
                      "
                    >
                      <img
                        src="{% static 'assets/icons/chat_icon.png' %}"
                        alt="Chat"
                        style="width: 20px; height: 20px; {% if data.IQF_pick_remarks %}filter: grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2); opacity: 1;{% endif %}"
                      />
                      <div
                        class="remark-tooltip"
                        style="
                          position: absolute;
                          top: 110%;
                          left: 50%;
                          transform: translateX(-50%);
                          width: 300px;
                          background: #fff;
                          border: 1px solid #ccc;
                          border-radius: 6px;
                          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                          opacity: 0;
                          visibility: hidden;
                          transition: opacity 0.3s ease, visibility 0.3s ease;
                          padding: 15px;
                          z-index: 1000;
                        "
                      >
                        <textarea
                          placeholder="Type your remark..."
                          style="
                            width: 85%;
                            height: 40px;
                            resize: vertical;
                            border: 1px solid #ccc;
                            padding: 5px;
                            border-radius: 4px;
                            font-family: Arial, sans-serif;
                            font-size: 14px;
                          "
                          {%
                          if
                          data.IQF_pick_remarks
                          %}readonly{%
                          endif
                          %}
                        >
{{ data.IQF_pick_remarks|default_if_none:"" }}</textarea
                        >
                        <div style="text-align: right; margin-top: -35px">
                          {% if not data.IQF_pick_remarks %}
                          <button
                            type="button"
                            style="
                              background-color: #007bff;
                              color: #fff;
                              border: none;
                              padding: 6px 12px;
                              border-radius: 4px;
                              cursor: pointer;
                              font-size: 14px;
                            "
                          >
                            <i class="fa fa-send"></i>
                          </button>
                          {% else %}
                          <div
                            style="
                              margin-top: 40px;
                              color: #31708f;
                              background: #d9edf7;
                              border: 1px solid #bce8f1;
                              border-radius: 4px;
                              padding: 8px 12px;
                              font-size: 10px;
                              text-align: left;
                            "
                          >
                            <i
                              class="fa fa-info-circle"
                              style="margin-right: 6px"
                            ></i>
                            Remark already saved and cannot be edited.
                          </div>
                          {% endif %}
                        </div>
                      </div>
                    </a>
                       {% else %}
                      <!-- Audio Remark Icon (disabled) -->
                      <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; opacity: 0.5; pointer-events: none;">
                        <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
                      </span>
                      <!-- Chat Remark Icon (disabled) -->
                      <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; opacity: 0.5; pointer-events: none;">
                        <img src="{% static 'assets/icons/chat_icon.png' %}" alt="Chat Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
                      </span>
                    {% endif %}
                    </td>
                   
                  </tr>
                  {% endfor%}
              
                </tbody>
              </table>


                                    <div
  id="trayScanModal_DayPlanning"
  class="tray-scan-modal-DayPlanning"
>
  <div class="tray-scan-modal-DayPlanning-content">
    <span id="closeTrayScanModal_DayPlanning" class="tray-scan-close-readonly">&times;</span>
    
    <div class="modal-top-header" style="display: flex; align-items: center; gap: 20px; padding-bottom: 10px;">
      <div class="user-profile" style="display: flex; align-items: center; gap: 8px">
        <img src="/static/assets/images/imagePlaceholder.png" alt="User Profile" style="border-radius: 50%; width: 50px; height: 50px; object-fit: cover;" />
        <!-- Model No and RW Qty in same line -->
        <div style="display: flex; flex-direction: column; gap: 2px;">
          <div style="display: flex; align-items: center; gap: 15px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-weight: bold; color: #666;">Model No:</span>
              <h6 id="modalModelNo_DayPlanning" style="margin: 0; color: #028084; font-weight: bold;">(Fetch Dynamically)</h6>
            </div>

          </div>
          <p>
              RW Qty: <span id="modalLotQty" style="font-weight:bold; color:#e67e22;"></span> /
              Missing Qty: <span id="modalMissingQty" style="font-weight:bold; color:#d32f2f;"></span> /
              Physical Qty: <span id="modalPhysicalQty" style="font-weight:bold; color:#388e3c;"></span>
          </p>
        </div>
      </div>
    </div>
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
      <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
        IQF - Rejected Tray Scan 
      </h5>
      <button id="trayValidateBtn" type="button" style="display: flex; align-items: center; gap: 6px; background: #f5faff; border: 1px solid #023E4DCC; color: #023E4DCC; border-radius: 20px; padding: 4px 14px; font-size: 12px; font-weight: 500; cursor: pointer;">
        
        Tray Validate
      </button>
      <input id="trayValidateInput" type="text" placeholder="Enter validation info..." style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;" />
      <img src="{% static 'assets/icons/redo2.png' %}" alt="Redo" id="trayScanRedoBtn" style="width: 24px; height: 24px; cursor: pointer; margin-left: 8px;" title="Clear Tray IDs" />
    </div>
    <div id="trayErrorMessage" style="display: none; background-color: #ffebee; border: 1px solid #f44336; color: #c62828; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-size: 12px; text-align: center;">
      <span id="trayErrorText"></span>
    </div>
    <div id="trayScanDetails_DayPlanning" class="table-grid">
      <!-- Headers and dynamic content will be injected here -->
    </div>
  </div>
</div>
               </div>
              <!-- Tray Scan Details Modal (Left Popup) -->
              <div id="trayScanModal" class="tray-scan-modal" style="scrollbar-width: thin; scrollbar-color: #fff #fff; max-width: 800px !important; min-width: 500px !important">
                <div class="tray-scan-modal-content">
                  <span id="closeTrayScanModal" class="tray-scan-close"
                    >&times;</span
                  >

                  <div id="trayScanDetails" style="min-height: 200px;">
                    <!-- Dynamic content will be loaded here -->
                    <div style="display: none;" class="empty-content-placeholder">
                      <div style="text-align: center; padding: 40px; color: #6c757d;">
                        <i class="fa fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 10px;"></i>
                        <p>Loading tray scan details...</p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <!-- IQF Confirmation Modal (Right Popup) -->
              <div id="newPopupModal" class="iqf-confirmation-modal">
                <div class="iqf-confirmation-modal-content">
                  <span id="closeNewPopupModal" class="iqf-confirmation-modal-close">&times;</span>
                  <!-- New top header container: title + user profile aligned left -->
                  <div
                    class="modal-top-header"
                    style="
                      display: flex;
                      align-items: center;
                      gap: 20px;
                      padding-bottom: 10px;
                    "
                  >
                    <div
                      class="user-profile"
                      style="display: flex; align-items: center; gap: 8px"
                    >
                      <img
                        src="{% static 'assets/images/userProfile.png' %}"
                        alt="User Profile"
                        style="
                          border-radius: 50%;
                          width: 50px;
                          height: 50px;
                          object-fit: cover;
                        "
                      />
                      <span>Model No:</span>
                      <h6>(Fetch Dynamically) / Accepted Tray Rescan</h6>
                    </div>
                  </div>
                  <!-- Existing centered h3 title -->
                  <!-- Redo icon for clearing "tray ID" -->
                 <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
                    <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                      IQF - Accepted case tray scan table
                    </h5>
                    <img
                      src="{% static 'assets/icons/redo2.png' %}"
                      alt="Redo"
                      id="trayScanRedoBtn"
                      style="width: 24px; height: 24px; cursor: pointer; margin-right: 14px;"
                      title="Clear Tray IDs"
                    />
                  </div>
                  <!-- Accepted Case Tray Scan Table - Grid View with Visible Borders -->
                  <div id="trayScanDetails" class="table-grid">
                    <div style="border: 1px solid #ccc; padding: 8px; font-weight: bold;">S.no</div>
                    <div style="border: 1px solid #ccc; padding: 8px; font-weight: bold;">Tray ID</div>
                    <div style="border: 1px solid #ccc; padding: 8px; font-weight: bold;">Tray Qty</div>

                    <div style="border: 1px solid #ccc; padding: 8px;">1</div>
                    <div style="border: 1px solid #ccc; padding: 8px;">Tray0012345</div>
                    <div style="border: 1px solid #ccc; padding: 8px;">
                      <div style="display: flex; align-items: center; gap: 14px;">
                        <span>10</span>
                        <div style="display: flex; gap: 4px;">
                          <input type="checkbox" style="width: 15px; height: 15px; cursor: pointer;" />
                          <img src="/static/assets/icons/edit2.png" alt="Edit" style="width: 15px; height: 15px; cursor: pointer;" />
                        </div>
                      </div>
                    </div>

                    <!-- NEW BUTTONS SECTION -->
                    <div class="tray-scan-modal-buttons" style="grid-column: 1 / -1; display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
                       <button
                    style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">
                    Draft
                  </button>
                  <button
                    style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
                    Submit
                  </button>
                  <button
                    style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">
                    Cancel
                  </button>
                    </div>
                  </div>
                </div>
              </div>
              
            </div>
            
           
          </div>
         <!-- Pagination Section -->

            <div class="pagination-wrapper">
              <nav aria-label="Page navigation">
                                <ul class="pagination justify-content-end mb-0">
                  {# Previous button #}
                  {% if page_obj.has_previous %}
                    <li>
                      <a href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                        <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                    </li>
                  {% endif %}
                
                  {# Always show first page #}
                  {% if page_obj.number > 3 %}
                    <li><a href="?page=1">1</a></li>
                    {% if page_obj.number > 4 %}
                      <li class="disabled"><span>…</span></li>
                    {% endif %}
                  {% endif %}
                
                  {# Show pages around current page #}
                  {% for num in page_obj.paginator.page_range %}
                    {% if num >= page_obj.number|add:'-2' and num <= page_obj.number|add:'2' %}
                      {% if num == page_obj.number %}
                        <li class="active"><span>{{ num }}</span></li>
                      {% else %}
                        <li><a href="?page={{ num }}">{{ num }}</a></li>
                      {% endif %}
                    {% endif %}
                  {% endfor %}
                
                  {# Show ellipsis and last page if needed #}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-2' %}
                    {% if page_obj.number < page_obj.paginator.num_pages|add:'-3' %}
                      <li class="disabled"><span>…</span></li>
                    {% endif %}
                    <li><a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a></li>
                  {% endif %}
                
                  {# Next button #}
                  {% if page_obj.has_next %}
                    <li>
                      <a href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                        <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                    </li>
                  {% endif %}
                </ul>
              </nav>
            </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Image Slider Modal (popup) -->
  <div id="imageSliderModal" class="image-slider-modal">
    <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
    <h3>Visual Aid</h3>
    <div class="slider" id="slider">
      <div class="slides" id="slidesContainer">
        <div class="slide active">
          <img src="{% static 'assets/images/carousel/banner_1.jpg' %}" alt="Slide 1">
        </div>
        <div class="slide">
          <img src="{% static 'assets/images/carousel/banner_2.jpg' %}" alt="Slide 2">
        </div>
        <div class="slide">
          <img src="{% static 'assets/images/carousel/banner_3.jpg' %}" alt="Slide 3">
        </div>
      </div>
      <button class="prev" id="prevBtn">&#10094;</button>
      <button class="next" id="nextBtn">&#10095;</button>
    </div>
  </div>
  <!-- Image Slider Modal -->
  <div id="imageSliderModal" class="image-slider-modal">
    <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
    <div class="slider" id="slider">
      <button class="prev" id="prevBtn">&#8592;</button>
      <div class="slides"></div>
      <button class="next" id="nextBtn">&#8594;</button>
    </div>
  </div>

  <!-- Hold Remark Modal -->
<div id="holdRemarkModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.18); z-index:20000; align-items:center; justify-content:center;">
  <div style="background:#fff; border-radius:10px; padding:28px 32px 18px 32px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
    <span id="closeHoldRemarkModal" style="position:absolute; top:8px; right:16px; font-size:22px; font-weight:bold; color:#d9534f; cursor:pointer;">&times;</span>
    <h5 style="margin-bottom:16px; color:#028084;">Row Hold Remark</h5>
    <textarea id="holdRemarkInput" maxlength="50" style="width:100%; height:60px; border:1px solid #ccc; border-radius:6px; padding:8px; font-size:15px; resize:none;" placeholder="Enter remark (max 50 chars)"></textarea>
    <div style="text-align:right; margin-top:10px;">
      <button id="saveHoldRemarkBtn" style="background:#007bff; color:#fff; border:none; border-radius:20px; padding:6px 18px; font-size:15px; cursor:pointer;">Save</button>
    </div>
    <div id="holdRemarkError" style="color:red; font-size:13px; min-height:18px; margin-top:6px;"></div>
  </div>
</div>

{% block script %}
<script nonce="{{ csp_nonce }}">
  document.addEventListener("DOMContentLoaded", function () {
    const trayModal = document.getElementById("trayScanModal");
    const closeTrayBtn = document.getElementById("closeTrayScanModal");
    if (closeTrayBtn) {
      closeTrayBtn.addEventListener("click", function () {
        trayModal.classList.remove("open");
        trayModal.style.display = "none"; // <-- Ensure modal is hidden
        window.location.reload(); // Reload the page to refresh the table
      });
    }
  });
</script>

<script nonce="{{ csp_nonce }}">
// ✅ FIXED: Store state globally so it persists across table refreshes
window.holdToggleState = {
  currentHoldCell: null,
  intendedState: null,
  currentBatchId: null,
  currentLotId: null
};

function attachHoldToggleListeners() {
  console.log('Attaching hold toggle listeners...');

  // Attach batch_id to each row for easy access
  document.querySelectorAll("tbody tr").forEach(function (row) {
    const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
    if (trayScanBtn) {
      row.setAttribute('data-batch-id', trayScanBtn.getAttribute('data-batch-id'));
    }
  });

  // Remove existing listeners and attach new ones
  document.querySelectorAll('.hold-toggle-btn').forEach(function (btn) {
    // Remove any existing click listeners
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);
    
    // Add new event listener
    newBtn.addEventListener('click', function (e) {
      e.preventDefault();
      
      const holdCell = newBtn.closest('td');
      const row = holdCell.closest('tr');
      
      // ✅ Store state globally with all needed data
      window.holdToggleState = {
        currentHoldCell: holdCell,
        intendedState: newBtn.checked,
        currentBatchId: row.getAttribute('data-batch-id'),
        currentLotId: row.getAttribute('data-stock-lot-id'),
        // Store identifiers that can help us find the row after refresh
        rowIdentifier: row.getAttribute('data-stock-lot-id') || row.getAttribute('data-batch-id')
      };
      
      console.log('Hold toggle clicked, state:', window.holdToggleState);
      
      document.getElementById('holdRemarkModal').querySelector('h5').textContent = 
        window.holdToggleState.intendedState ? 'Unholding Reason' : 'Holding Reason';
      document.getElementById('holdRemarkInput').value = '';
      document.getElementById('holdRemarkError').textContent = '';
      document.getElementById('holdRemarkModal').style.display = 'flex';
      document.getElementById('holdRemarkInput').focus();
    });
  });

  // ✅ Attach save button handler (only once globally)
  const saveBtn = document.getElementById('saveHoldRemarkBtn');
  if (saveBtn && !window.holdSaveHandlerAttached) {
    window.holdSaveHandlerAttached = true;
    
    saveBtn.onclick = function () {
      console.log('Save button clicked, current state:', window.holdToggleState);
      
      const remark = document.getElementById('holdRemarkInput').value.trim();
      if (!remark) {
        document.getElementById('holdRemarkError').textContent = 'Remark required!';
        return;
      }
      
      // ✅ Use stored state instead of current variables
      if (!window.holdToggleState.currentLotId) {
        document.getElementById('holdRemarkError').textContent = 'Lot ID not found!';
        return;
      }
    
      const action = window.holdToggleState.intendedState ? 'unhold' : 'hold';
      
      console.log('Sending request:', {
        lot_id: window.holdToggleState.currentLotId,
        remark: remark,
        action: action
      });
    
      fetch('/iqf/iqf_save_hold_unhold_reason/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          lot_id: window.holdToggleState.currentLotId,
          remark: remark,
          action: action
        })
      })
      .then(res => res.json())
      .then(data => {
        console.log('Server response:', data);
        
        if (data.success) {
          // ✅ Close modal first
          document.getElementById('holdRemarkModal').style.display = 'none';
          
          // ✅ Update UI immediately before refresh
          const currentRow = document.querySelector(`tr[data-stock-lot-id="${window.holdToggleState.currentLotId}"]`);
          if (currentRow) {
            const toggle = currentRow.querySelector('.hold-toggle-btn');
            const icon = currentRow.querySelector('.hold-remark-icon');
            
            if (action === 'hold') {
              if (toggle) toggle.checked = false;
              currentRow.classList.add('row-inactive');
              currentRow.querySelectorAll('td').forEach((td, idx) => {
                if (idx > 0) {
                  td.classList.add('row-inactive-blur');
                } else {
                  td.classList.remove('row-inactive-blur');
                }
              });
              if (icon) {
                icon.style.display = 'inline-block';
                icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:18px; height:18px;" />`;
                icon.setAttribute('title', 'Holding Reason: ' + remark);
              }
            } else {
              if (toggle) toggle.checked = true;
              currentRow.classList.remove('row-inactive');
              currentRow.querySelectorAll('td').forEach(td => {
                td.classList.remove('row-inactive-blur');
              });
              if (icon) {
                icon.style.display = 'none';
              }
            }
          }
          
          // ✅ Then refresh the table data
          setTimeout(() => {
            if (typeof refreshTableData === 'function') {
              refreshTableData();
            } else {
              location.reload();
            }
          }, 500);
          
        } else {
          document.getElementById('holdRemarkError').textContent = data.error || 'Failed to save reason!';
        }
      })
      .catch((error) => {
        console.error('Request failed:', error);
        document.getElementById('holdRemarkError').textContent = 'Network error!';
      });
    };
  }

  // ✅ Attach close button handler (only once globally)
  const closeBtn = document.getElementById('closeHoldRemarkModal');
  if (closeBtn && !window.holdCloseHandlerAttached) {
    window.holdCloseHandlerAttached = true;
    closeBtn.onclick = function () {
      document.getElementById('holdRemarkModal').style.display = 'none';
      // Clear the state when modal is closed
      window.holdToggleState = {
        currentHoldCell: null,
        intendedState: null,
        currentBatchId: null,
        currentLotId: null
      };
    };
  }

  // Helper for CSRF
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
}



// ✅ Call on page load
document.addEventListener("DOMContentLoaded", function () {
  attachHoldToggleListeners();
});
</script>

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const redoBtn = document.getElementById("trayScanRedoBtn");
  const validateInput = document.getElementById("trayValidateInput");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
  const errorMessage = document.getElementById("trayErrorMessage");

  if (redoBtn && validateInput && detailsDiv) {
    redoBtn.addEventListener("click", function () {
      // Hide and clear the input
      validateInput.value = "";
      validateInput.blur();
      
      // Hide error message
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Reset Tray Validate button to normal state
      const validateBtn = document.getElementById("trayValidateBtn");
      if (validateBtn) {
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }

      // Reset all icons in the validation status column (read-only modal)
      // For table layout:
      const rows = detailsDiv.querySelectorAll("tbody tr");
      if (rows.length > 0) {
        rows.forEach(row => {
          const statusCell = row.querySelector("td:last-child");
          if (statusCell) {
            statusCell.innerHTML = `
              <div class="validation-status">
                <div class="status-icon fail">
                  <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                </div>
                <div class="status-icon pass">
                  <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                </div>
              </div>
            `;
          }
        });
      } else {
        // For grid layout (if used)
        detailsDiv.querySelectorAll('.tray-validation-status-header, .tray-validation-status-cell').forEach(cell => {
          cell.innerHTML = `
            Tray Validation Status
            <span style="margin-left: 10px;">
              <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
              <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
            </span>
          `;
        });
      }
    });
  }
});
</script>

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const validateBtn = document.getElementById("trayValidateBtn");
  const validateInput = document.getElementById("trayValidateInput");
  const redoBtn = document.getElementById("trayScanRedoBtn");
  const errorMessage = document.getElementById("trayErrorMessage");

  if (validateBtn && validateInput) {
    validateBtn.addEventListener("click", function () {
      validateInput.value = "";
      
      // Hide error message when starting new validation
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Change button to active state (green color)
      validateBtn.style.background = "#e8f5e8";
      validateBtn.style.borderColor = "#4caf50";
      validateBtn.style.color = "#2e7d32";
      
      // Add the 4th column to the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      
      if (modal && detailsDiv && modal.buildTableHTML) {
        // Rebuild table with validation column
        detailsDiv.innerHTML = modal.buildTableHTML(true);
      }
      
      // Focus the hidden input so it can receive keystrokes
      validateInput.focus();
    });
  }
  
  if (redoBtn && validateInput) {
    redoBtn.addEventListener("click", function () {
      validateInput.value = "";
      validateInput.blur();
      
      // Hide error message
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Reset button to normal state (original blue color)
      if (validateBtn) {
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }
      
      // Remove the 4th column from the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      
      if (modal && detailsDiv && modal.buildTableHTML) {
        // Rebuild table without validation column
        detailsDiv.innerHTML = modal.buildTableHTML(false);
      }
      
      redoBtn.focus();
    });
  }
});
</script>

<script nonce="{{ csp_nonce }}">
// ============================================
// LEGACY TRAY VALIDATION - REDIRECTED TO ENHANCED SYSTEM
// ============================================
document.addEventListener("DOMContentLoaded", function () {
  const validateInput = document.getElementById("trayValidateInput");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
  const errorMessage = document.getElementById("trayErrorMessage");
  const errorText = document.getElementById("trayErrorText");

  console.log("🔍 [LEGACY] Legacy tray validation script loaded - redirecting to enhanced system");
  console.log("📋 [LEGACY] Elements found:", {
    validateInput: !!validateInput,
    detailsDiv: !!detailsDiv,
    errorMessage: !!errorMessage,
    errorText: !!errorText
  });

  function getCurrentBatchId() {
    const modal = document.getElementById("trayScanModal_DayPlanning");
    if (modal && modal.dataset.batchId) return modal.dataset.batchId;
    const lastBtn = document.querySelector('.tray-scan-btn-Jig[data-batch-id]');
    return lastBtn ? lastBtn.getAttribute('data-batch-id') : '';
  }

  function getCurrentStockStatus() {
    // Get stock status from the last clicked button
    const lastBtn = document.querySelector('.tray-scan-btn-Jig[data-batch-id]');
    if (lastBtn) {
      return {
        accepted_ip_stock: lastBtn.getAttribute('data-accepted-ip-stock') === 'true',
        brass_qc_rejection: lastBtn.getAttribute('data-rejected-ip-stock') === 'true',
        brass_qc_few_cases_accptance: lastBtn.getAttribute('data-few-cases-accepted-ip-stock') === 'true'
      };
    }
    return {
      accepted_ip_stock: false,
      brass_qc_rejection: false,
      brass_qc_few_cases_accptance: false
    };
  }

  function showError(message) {
    console.log("🚨 [LEGACY] Showing error:", message);
    if (errorMessage && errorText) {
      errorText.textContent = message;
      
      // Force display with important styles
      errorMessage.style.setProperty('display', 'block', 'important');
      errorMessage.style.setProperty('visibility', 'visible', 'important');
      errorMessage.style.setProperty('opacity', '1', 'important');
      errorMessage.style.setProperty('z-index', '99999', 'important');
      errorMessage.style.setProperty('position', 'relative', 'important');
      errorMessage.style.setProperty('background-color', '#ffebee', 'important');
      errorMessage.style.setProperty('border', '1px solid #f44336', 'important');
      errorMessage.style.setProperty('color', '#c62828', 'important');
      errorMessage.style.setProperty('padding', '8px 12px', 'important');
      errorMessage.style.setProperty('border-radius', '4px', 'important');
      errorMessage.style.setProperty('margin-bottom', '10px', 'important');
      errorMessage.style.setProperty('font-size', '12px', 'important');
      errorMessage.style.setProperty('text-align', 'center', 'important');
      errorMessage.style.setProperty('width', '100%', 'important');
      
      console.log("✅ [LEGACY] Error message styled");
      
      // Scroll to error message if it exists
      errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      
      // Flash the background to make it more noticeable
      let flashCount = 0;
      const flashInterval = setInterval(() => {
        if (flashCount < 6) {
          errorMessage.style.backgroundColor = flashCount % 2 === 0 ? '#ffcdd2' : '#ffebee';
          flashCount++;
        } else {
          clearInterval(flashInterval);
          errorMessage.style.backgroundColor = '#ffebee';
        }
      }, 200);
      
      console.log("✅ [LEGACY] Error message displayed");
      
      // Auto-hide after 8 seconds
      setTimeout(() => {
        errorMessage.style.display = "none";
        console.log("⏰ [LEGACY] Auto-hiding error message after 8 seconds");
      }, 8000);
    } else {
      console.log("❌ [LEGACY] Error message elements not found!");
      // Fallback: show alert if error div not found
      alert(message);
    }
  }

  function hideError() {
    console.log("🫥 [LEGACY] Hiding error message");
    if (errorMessage) {
      errorMessage.style.display = "none";
    }
  }

  // ============================================
  // REDIRECT TO ENHANCED VALIDATION SYSTEM
  // ============================================
  if (validateInput && detailsDiv) {
    console.log("🎯 [LEGACY] DISABLED - Legacy validation redirected to enhanced system");
    console.log("✨ [LEGACY] Enhanced instant validation is now handling all tray validations");
    
    // LEGACY VALIDATION DISABLED - Enhanced system handles everything
    // The enhanced IQFTrayValidation system provides:
    // ✅ Instant validation on typing (no need to press Enter)
    // ✅ Auto-save functionality 
    // ✅ Real-time feedback
    // ✅ Better UX with debounced validation calls
    
  } else {
    console.log("❌ [LEGACY] Required elements not found:", {
      validateInput: !!validateInput,
      detailsDiv: !!detailsDiv
    });
  }
  
  // Helper for CSRF
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
  
  console.log("🎯 Tray validation script setup complete");
});
</script>

<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
        link.addEventListener('click', async function (e) {
          e.preventDefault();
    
          // Get modal elements
          const modal = document.getElementById("trayScanModal_DayPlanning");
          const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
          const modalModelNo = document.getElementById("modalModelNo_DayPlanning");

          const modalLotQty = document.getElementById("modalLotQty");
          const modalMissingQty = document.getElementById("modalMissingQty");
          const modalPhysicalQty = document.getElementById("modalPhysicalQty");

          modal.dataset.batchId = link.getAttribute('data-batch-id');
    
          // Get data attributes
          const batchId = link.getAttribute('data-batch-id');
          const modelNo = link.getAttribute('data-model-no');
          const stockLotId = link.getAttribute('data-stock-lot-id');
          const noOfTrays = parseInt(link.getAttribute('data-no-of-trays')) || 0;
          const trayCapacity = link.getAttribute('data-tray-capacity') || "";
          const totalBatchQuantity = link.getAttribute('data-total-batch-quantity') || "0";
          const lotQty = link.getAttribute('data-lot-qty') || "0";
          const missingQty = link.getAttribute('data-missing-qty') || "0";
          const physicalQty = link.getAttribute('data-physical-qty') || "0";

          // ✅ UPDATED: Get brass QC specific stock status data
          const brassQcAccptance = link.getAttribute('data-brass-qc-accptance') === 'true';
          const brassQcRejection = link.getAttribute('data-brass-qc-rejection') === 'true';
          const brassQcFewCasesAccptance = link.getAttribute('data-brass-qc-few-cases-accptance') === 'true';
    
          // Set model number in modal
          if (modalModelNo && modelNo) {
            modalModelNo.textContent = modelNo;
          }

          if (modalLotQty) {
            modalLotQty.textContent = totalBatchQuantity || lotQty || '0';
            console.log("✅ Set RW Qty to:", totalBatchQuantity || lotQty || '0');
          }

          if (modalMissingQty) {
            modalMissingQty.textContent = missingQty || '0';
            console.log("✅ Set Missing Qty to:", missingQty || '0');
          }

          if (modalPhysicalQty) {
            modalPhysicalQty.textContent = physicalQty || '0';
            console.log("✅ Set Physical Qty to:", physicalQty || '0');
          }
    
          // Set model image
          const modalUserImg = modal.querySelector('.user-profile img');
          const modelImage = link.getAttribute('data-model-image');
          if (modalUserImg) {
            modalUserImg.src = modelImage || "/static/assets/images/imagePlaceholder.png";
          }
    
          // ✅ UPDATED: Fetch ONLY rejected tray data
          let traysData = [];
          let rejectionSummary = {};
          try {
            const params = new URLSearchParams({
              lot_id: stockLotId,
            });
            
            // ✅ UPDATED: Use correct endpoint name
            const resp = await fetch(`/iqf/iqf_pick_CompleteTable_tray_id_list/?${params}`);
            const result = await resp.json();
            if (result.success) {
              traysData = result.trays || [];
              rejectionSummary = result.rejection_summary || {};
              console.log('✅ Fetched ONLY brass rejected trays:', traysData);
              console.log('📊 Rejection summary:', rejectionSummary);
            }
          } catch (e) {
            console.error('❌ Error fetching tray data:', e);
          }
    
          function buildTableHTML(showValidationColumn = false) {
            let html = `
              <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
                <thead>
                  <tr>
                    <th style="width:50px;">S.no</th>
                    <th>Tray ID</th>
                    <th>Tray Qty</th>
                    ${showValidationColumn ? '<th>Tray Validation Status</th>' : ''}
                  </tr>
                </thead>
                <tbody>
            `;
          
            // ✅ Sort traysData by tray_quantity ascending
            const sortedTrays = traysData.slice().sort((a, b) => (a.tray_quantity || 0) - (b.tray_quantity || 0));
          
            sortedTrays.forEach((tray, idx) => {
              html += `
                <tr>
                  <td>${idx + 1}</td>
                  <td>
                    <input type="text" class="form-control" value="${tray.tray_id || ''}" readonly style="width: 100%;" />
                  </td>
                  <td>
                    <input type="number" class="form-control" value="${tray.tray_quantity || ''}" readonly style="width: 100%;" />
                  </td>
                  ${showValidationColumn ? `
                    <td>
                      <div class="validation-status">
                        <div class="status-icon fail">
                          <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                        </div>
                        <div class="status-icon pass">
                          <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                        </div>
                      </div>
                    </td>
                  ` : ''}
                </tr>
              `;
            });
          
            html += '</tbody></table>';
            return html;
          }

          // Show table 
          detailsDiv.innerHTML = buildTableHTML(false);
    
          // Store data for later use
          modal.buildTableHTML = buildTableHTML;
          modal.traysData = traysData;
          modal.rejectionSummary = rejectionSummary;
    
          // Show the modal
          modal.style.display = "block";
          modal.classList.add("open");
        });
      });
    
      // Close handler remains the same
      const closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");
      if (closeBtn) {
        closeBtn.addEventListener("click", function () {
          const modal = document.getElementById("trayScanModal_DayPlanning");
          if (modal) {
            modal.classList.remove("open");
            modal.style.display = "none";
          }
        });
      }
    });
</script>

<!-- Complete IQF Tray Scan Modal & Popup Script -->
<script nonce="{{ csp_nonce }}">
function collectDelinkTrayData() {
  console.log('📊 Collecting delink tray data for draft...');
  
  const delinkTrays = [];
  const delinkInputs = document.querySelectorAll('.delink-tray-id-input');
  
  delinkInputs.forEach((input, index) => {
    const trayId = input.value.trim();
    const isValid = input.style.borderColor === 'rgb(40, 167, 69)'; // Green border indicates valid
    const availableTraysData = input.getAttribute('data-available-trays');
    const lotId = input.getAttribute('data-lot-id');
    
    // For draft: include ALL entries, even empty or invalid ones
    delinkTrays.push({
      sequence: index + 1,
      tray_id: trayId,
      is_valid: isValid && trayId.length > 0,
      is_empty: !trayId,
      available_trays: availableTraysData ? JSON.parse(availableTraysData) : [],
      lot_id: lotId || '',
      border_color: input.style.borderColor || '',
      background_color: input.style.backgroundColor || ''
    });
  });
  
  console.log('📊 Collected delink trays:', delinkTrays);
  return delinkTrays;
}

// ✅ Function to collect rejection verification data
function collectRejectionVerificationData() {
  console.log('📊 Collecting rejection verification data for draft...');
  
  const rejectionVerifications = [];
  const trayIdInputs = document.querySelectorAll('.rejection-tray-id-input');
  const qtyInputs = document.querySelectorAll('.rejection-qty-input');
  const checkboxes = document.querySelectorAll('.rejection-verify-checkbox');
  const selectAllCheckbox = document.getElementById('selectAllVerifyCheckbox');
  const isSelectAllChecked = selectAllCheckbox && selectAllCheckbox.checked;

  // Collect individual verification entries
  trayIdInputs.forEach((input, index) => {
    const trayId = input.value.trim();
    const qtyInput = qtyInputs[index];
    const checkbox = checkboxes[index];
    
    const qty = qtyInput ? parseInt(qtyInput.value) || 0 : 0;
    const isEnabled = checkbox ? !checkbox.disabled : false;
    
    rejectionVerifications.push({
      tray_id: trayId,
      qty: qty,
      sequence: index + 1,
      is_enabled: false,
      is_verified: !!isSelectAllChecked, // <-- Always true if "Verify All" is checked
      input_readonly: true,
      input_background: qtyInput ? qtyInput.style.backgroundColor : ''
    });
  });
  
  // Collect Select All state
  const selectAllState = {
    is_checked: selectAllCheckbox ? selectAllCheckbox.checked : false,
    label_text: document.querySelector('label[for="selectAllVerifyCheckbox"]')?.textContent || 'Select All'
  };
  
  console.log('📊 Collected rejection verifications:', rejectionVerifications);
  console.log('📊 Select All state:', selectAllState);
  
  return {
    verifications: rejectionVerifications,
    select_all_state: {
      is_checked: isSelectAllChecked,
      label_text: document.querySelector('label[for="selectAllVerifyCheckbox"]')?.textContent || 'Verify All'
    }
  };
}

// ✅ Function to save optimal distribution draft
async function saveOptimalDistributionDraft(lotId) {
  console.log('💾 Saving optimal distribution draft for lot:', lotId);
  
  try {
    // Show saving indicator
    showDraftSavingIndicator(true);
    
    // Collect all data (allows partial data for draft)
    const delinkTrays = collectDelinkTrayData();
    const rejectionData = collectRejectionVerificationData();
    
    const draftData = {
      lot_id: lotId,
      delink_trays: delinkTrays,
      rejection_verifications: rejectionData.verifications,
      select_all_state: rejectionData.select_all_state,
      saved_timestamp: new Date().toISOString(),
      draft_metadata: {
        delink_filled_count: delinkTrays.filter(tray => tray.tray_id).length,
        delink_total_count: delinkTrays.length,
        rejection_checked_count: rejectionData.verifications.filter(v => v.is_verified).length,
        rejection_total_count: rejectionData.verifications.length
      }
    };
    
    console.log('💾 Draft data to save:', draftData);
    
    // Save to backend
    const response = await fetch('/iqf/iqf_save_optimal_distribution_draft/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify(draftData)
    });
    
    const result = await response.json();
    
    if (result.success) {
      console.log('✅ Draft saved successfully:', result);
      showDraftSuccessMessage(result.message || 'Draft saved successfully!');
      
      // Update button text to indicate draft exists
      const draftBtn = document.getElementById('acceptedTrayDraftBtn');
      if (draftBtn) {
        draftBtn.textContent = 'Draft';
        draftBtn.style.background = '#007bff'; // Blue to indicate existing draft
      }
        window.location.reload(); // <-- Add this line to refresh the page

      
      return { success: true, data: result };
    } else {
      console.error('❌ Failed to save draft:', result.error);
      showDraftErrorMessage(result.error || 'Failed to save draft');
      return { success: false, error: result.error };
    }
    
  } catch (error) {
    console.error('❌ Network error saving draft:', error);
    showDraftErrorMessage('Network error occurred while saving draft');
    return { success: false, error: error.message };
  } finally {
    showDraftSavingIndicator(false);
  }
}

// ✅ Function to load optimal distribution draft
async function loadOptimalDistributionDraft(lotId) {
  console.log('📂 Loading optimal distribution draft for lot:', lotId);

  try {
    const response = await fetch(`/iqf/iqf_load_optimal_distribution_draft/?lot_id=${encodeURIComponent(lotId)}`);
    const result = await response.json();

    if (result.success && result.draft_data) {
      console.log('📂 Draft loaded successfully:', result.draft_data);

      // Populate delink table with draft data
      populateDelinkTableFromDraft(result.draft_data.delink_trays || []);

      // Populate rejection verification table ONLY from draft data
      populateRejectionVerificationFromDraft(
        result.draft_data.rejection_verifications || [],
        result.draft_data.select_all_state,
        result.draft_data.delink_trays || []
      );

      // Update button to show draft exists
      const draftBtn = document.getElementById('acceptedTrayDraftBtn');
      if (draftBtn) {
        draftBtn.textContent = 'Draft';
        draftBtn.style.background = '#007bff';
      }

      // Show draft loaded message
      showDraftLoadedMessage(result.draft_data.saved_timestamp);

      return { success: true, data: result.draft_data };
    } else {
      console.log('📂 No draft found for lot:', lotId);
      return { success: false, error: 'No draft found' };
    }

  } catch (error) {
    console.error('❌ Error loading optimal distribution draft:', error);
    return { success: false, error: error.message };
  }
}


// ✅ Function to populate delink table from draft data
function populateDelinkTableFromDraft(delinkTraysData) {
  console.log('🎯 Populating delink table from draft:', delinkTraysData);
  
  const delinkInputs = document.querySelectorAll('.delink-tray-id-input');
  
  delinkInputs.forEach((input, index) => {
    const draftEntry = delinkTraysData.find(entry => entry.sequence === index + 1);
    
    if (draftEntry) {
      // Restore tray ID
      input.value = draftEntry.tray_id || '';
      
      // Restore validation styling
      if (draftEntry.is_valid && draftEntry.tray_id) {
        input.style.borderColor = '#28a745';
        input.style.backgroundColor = '#f8fff8';
      } else if (draftEntry.tray_id && !draftEntry.is_valid) {
        input.style.borderColor = '#dc3545';
        input.style.backgroundColor = '#fff5f5';
      } else {
        // Empty field
        input.style.borderColor = '';
        input.style.backgroundColor = '';
      }
      
      console.log(`🎯 Restored delink row ${index + 1}:`, draftEntry.tray_id);
    }
  });
}

function populateRejectionVerificationFromDraft(verificationsData, selectAllState, delinkTraysData) {
  const rejectionTableBody = document.getElementById('rejection-table-body');
  if (!rejectionTableBody) return;

  // Clear table
  rejectionTableBody.innerHTML = '';

  // Render only trays from draft, using your requested style
  verificationsData.forEach((tray, i) => {
    const isTopTray = i === 0 ? ' (Top Tray)' : '';
    const row = document.createElement('tr');
    row.innerHTML = `
      <td style="padding: 6px;">${i + 1}${isTopTray}</td>
      <td style="padding: 6px;">
        <input type="text" class="rejection-tray-id-input" 
               value="${tray.tray_id}" 
               style="width: 100%; padding: 4px; font-size: 13px; background-color: #e8f5e9; border: 2px solid #28a745;" 
               readonly />
      </td>
      <td style="padding: 6px;">
        <input type="number" class="rejection-qty-input" 
               value="${tray.qty}" 
               style="width: 80px; padding: 4px; font-size: 13px; background-color: #fff3cd; border: 2px solid #856404; font-weight: bold;" 
               readonly 
               title="Fixed distributed quantity" />
      </td>
    `;
    rejectionTableBody.appendChild(row);
  });

  // Set "Verify All" checkbox state
  const selectAllCheckbox = document.getElementById('selectAllVerifyCheckbox');
  // Check if any delink tray is valid
  const anyDelinkValid = Array.isArray(delinkTraysData) && delinkTraysData.some(tray => tray.is_valid);
  if (selectAllCheckbox) {
    selectAllCheckbox.checked = !!(selectAllState && selectAllState.is_checked) || anyDelinkValid;
  }
}

// ✅ UI feedback functions
function showDraftSavingIndicator(show) {
  const draftBtn = document.getElementById('acceptedTrayDraftBtn');
  if (!draftBtn) return;
  
  if (show) {
    draftBtn.disabled = true;
    draftBtn.style.opacity = '0.7';
    draftBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Saving...';
  } else {
    draftBtn.disabled = false;
    draftBtn.style.opacity = '1';
    draftBtn.innerHTML = 'Draft';
  }
}

function showDraftSuccessMessage(message) {
  showNotification(message, 'success');
}

function showDraftErrorMessage(message) {
  showNotification(message, 'error');
}

function showDraftLoadedMessage(timestamp) {
  const date = new Date(timestamp);
  const formattedDate = date.toLocaleString();
}

function showNotification(message, type = 'success') {
  // Create notification element
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 10003;
    font-weight: 500;
    font-size: 14px;
    transform: translateX(400px);
    transition: transform 0.3s ease;
    max-width: 350px;
  `;
  
  // Set colors based on type
  switch (type) {
    case 'success':
      notification.style.background = '#28a745';
      notification.style.color = 'white';
      break;
    case 'error':
      notification.style.background = '#dc3545';
      notification.style.color = 'white';
      break;
    case 'info':
      notification.style.background = '#007bff';
      notification.style.color = 'white';
      break;
    default:
      notification.style.background = '#6c757d';
      notification.style.color = 'white';
  }
  
  notification.textContent = message;
  document.body.appendChild(notification);
  
  // Show notification
  setTimeout(() => {
    notification.style.transform = 'translateX(0)';
  }, 100);
  
  // Hide notification after 3 seconds
  setTimeout(() => {
    notification.style.transform = 'translateX(400px)';
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 300);
  }, 3000);
}

// ✅ IQF Modal Alert Functions
function showIQFModalAlert(message, type = 'warning') {
  const alertDiv = document.getElementById('iqf-modal-alert');
  const messageSpan = document.getElementById('iqf-alert-message');
  
  if (alertDiv && messageSpan) {
    messageSpan.textContent = message;
    
    // Update alert type
    const alertElement = alertDiv.querySelector('.alert');
    alertElement.className = `alert alert-${type} alert-dismissible fade show`;
    
    alertDiv.style.display = 'block';
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      hideIQFModalAlert();
    }, 5000);
  }
}

function hideIQFModalAlert() {
  const alertDiv = document.getElementById('iqf-modal-alert');
  if (alertDiv) {
    alertDiv.style.display = 'none';
  }
}

// ✅ EXISTING CODE STARTS HERE - KEEPING ALL ORIGINAL FUNCTIONALITY
document.addEventListener("DOMContentLoaded", () => {
  const trayScanLinks = document.querySelectorAll(".tray-scan-btn");
  const trayModal = document.getElementById("trayScanModal");
  const closeTrayBtn = document.getElementById("closeTrayScanModal");
  const detailsDiv = document.getElementById("trayScanDetails");
  const newPopupModal = document.getElementById("newPopupModal");
  
  const closeNewPopupBtn = document.getElementById("closeNewPopupModal");

// ✅ FIXED: Complete tray scan button handler for left popup
trayScanLinks.forEach((link) => {
  link.addEventListener("click", (event) => {
    event.preventDefault();

    const row = event.target.closest("tr");
    const batchId = link.getAttribute('data-batch-id');
    const stockLotId = link.getAttribute('data-stock-lot-id');
    const isOnHold = row.getAttribute('data-brass-onhold-picking') === 'True';
    
    // ✅ ENHANCED: Extract values from multiple sources with better fallbacks
    let modelNo = link.getAttribute('data-model-no') || '';
    let lotQty = '0';
    let missingQty = '0';
    let physicalQty = '0';

    // 1. Try to get from button data attributes first
    lotQty = link.getAttribute('data-lot-qty') || '0';
    missingQty = link.getAttribute('data-missing-qty') || '0';
    physicalQty = link.getAttribute('data-physical-qty') || '0';

    // 2. If still 0, try to get from row data attributes
    if (lotQty === '0' || !lotQty) {
      lotQty = row.getAttribute('data-available-qty') || '0';
    }
    if (missingQty === '0' || !missingQty) {
      missingQty = row.getAttribute('data-missing-qty') || '0';
    }
    if (physicalQty === '0' || !physicalQty) {
      physicalQty = row.getAttribute('data-physical-qty') || '0';
    }

    // 3. Try to extract from visible table cells as final fallback
    if (lotQty === '0' || !lotQty) {
      const lotQtyCell = row.querySelector('.lot-qty');
      if (lotQtyCell) {
        lotQty = lotQtyCell.textContent.trim();
      }
    }

    if (missingQty === '0' || !missingQty) {
      const missingQtyInput = row.querySelector('.missing-qty-input');
      if (missingQtyInput && missingQtyInput.value.trim()) {
        missingQty = missingQtyInput.value.trim();
      }
    }

    // 4. Calculate physical qty if missing
    if (physicalQty === '0' || !physicalQty) {
      const lotQtyNum = parseInt(lotQty) || 0;
      const missingQtyNum = parseInt(missingQty) || 0;
      physicalQty = (lotQtyNum - missingQtyNum).toString();
    }

    console.log('🎯 Extracted values for modal:', {
      modelNo: modelNo,
      lotQty: lotQty,
      missingQty: missingQty,
      physicalQty: physicalQty
    });

    // ✅ Store values globally
    window.currentModalValues = {
      modelNo: modelNo || 'N/A',
      lotQty: lotQty,
      missingQty: missingQty,
      physicalQty: physicalQty
    };

    // ✅ IMMEDIATELY set the header values before showing modal
    setModalHeaderValues();

    // ✅ Set modal data attributes
    trayModal.dataset.batchId = batchId;
    trayModal.dataset.stockLotId = stockLotId;

    // ✅ HIDE old modal - we're using the new overlay modal system
    trayModal.classList.remove("open");
    trayModal.style.display = "none";

    // ✅ Show modal content in new overlay system
    if (isOnHold) {
      showReadOnlyRejectionData(stockLotId, detailsDiv);
    } else {
      showEditableRejectionForm(stockLotId, batchId, detailsDiv, row);
    }

    // ✅ SET VALUES MULTIPLE TIMES to ensure they persist after content loads
    setTimeout(() => setModalHeaderValues(), 100);
    setTimeout(() => setModalHeaderValues(), 300);
    setTimeout(() => setModalHeaderValues(), 500);
    setTimeout(() => setModalHeaderValues(), 1000);
  });
});

// ✅ Enhanced function that sets the modal header values
function setModalHeaderValues() {
  if (!window.currentModalValues) {
    console.warn('No currentModalValues found');
    return;
  }

  console.log('Setting modal header values:', window.currentModalValues);

  // Find all possible modal header elements
  const modalElements = {
    modelNo: document.getElementById('modalModelNo'),
    lotQty: document.getElementById('modalLotQty'), 
    missingQty: document.getElementById('modalMissingQty'),
    physicalQty: document.getElementById('modalPhysicalQty')
  };

  // Set Model No
  if (modalElements.modelNo && window.currentModalValues.modelNo) {
    modalElements.modelNo.textContent = window.currentModalValues.modelNo;
    console.log('✅ Set Model No:', window.currentModalValues.modelNo);
  }

  // Set RW Qty (Lot Qty)
  if (modalElements.lotQty && window.currentModalValues.lotQty) {
    modalElements.lotQty.textContent = window.currentModalValues.lotQty;
    console.log('✅ Set RW Qty:', window.currentModalValues.lotQty);
  }

  // Set Missing Qty
  if (modalElements.missingQty && window.currentModalValues.missingQty) {
    modalElements.missingQty.textContent = window.currentModalValues.missingQty;
    console.log('✅ Set Missing Qty:', window.currentModalValues.missingQty);
  }

  // Set Physical Qty
  if (modalElements.physicalQty && window.currentModalValues.physicalQty) {
    modalElements.physicalQty.textContent = window.currentModalValues.physicalQty;
    console.log('✅ Set Physical Qty:', window.currentModalValues.physicalQty);
  }

  // Also check if any elements weren't found
  Object.keys(modalElements).forEach(key => {
    if (!modalElements[key]) {
      console.warn(`Modal element not found: ${key}`);
    }
  });
}
// ✅ Also add a MutationObserver to watch for changes and re-set values
function setupModalHeaderWatcher() {
  const modalHeader = document.querySelector('#modalModelNo, #modalLotQty, #modalMissingQty, #modalPhysicalQty');
  if (!modalHeader) return;

  const observer = new MutationObserver(() => {
    if (window.currentModalValues) {
      setTimeout(() => setModalHeaderValues(), 50);
    }
  });

  observer.observe(document.getElementById('trayScanModal'), {
    childList: true,
    subtree: true
  });
}

// ✅ Call this when the page loads
document.addEventListener('DOMContentLoaded', setupModalHeaderWatcher);

// ✅ Helper function to fetch tray capacity dynamically - NO FALLBACK
async function fetchTrayCapacityDynamic(lotId) {
  console.log(`🔍 Fetching tray capacity for lot_id: ${lotId}`);
  
  try {
    const response = await fetch(`/iqf/get_tray_capacity/?lot_id=${encodeURIComponent(lotId)}`);
    const data = await response.json();
    
    console.log('📊 Tray capacity response:', data);
    
    if (data.success && data.tray_capacity && data.tray_capacity > 0) {
      console.log(`✅ Valid tray capacity: ${data.tray_capacity}`);
      return { success: true, tray_capacity: parseInt(data.tray_capacity, 10) };
    } else {
      console.error('❌ Invalid tray capacity from server:', data);
      return { 
        success: false, 
        error: data.error || 'No valid tray capacity found for this lot' 
      };
    }
  } catch (error) {
    console.error('❌ Network error fetching tray capacity:', error);
    return { 
      success: false, 
      error: `Network error: ${error.message}` 
    };
  }
}

// ✅ FIXED: Calculate optimal distribution - ONLY EXCLUDE VALID DELINK CANDIDATES
async function calculateOptimalRejectionDistribution(allRemainingTrays, lotId) {
  console.log('🎯 Calculating FIXED distribution with shuffled tray IDs...');
  
  // Store globally for validation function
  window.currentRemainingTrays = allRemainingTrays;
  
  // 1. ✅ Get scanned delink trays - BUT ONLY VALID ONES (is_delink_candidate: true)
  const validScannedDelinkTrays = [];
  document.querySelectorAll('.delink-tray-id-input').forEach(input => {
    const trayId = input.value.trim();
    const isValid = input.style.borderColor === 'rgb(40, 167, 69)';
    if (trayId && isValid) {
      validScannedDelinkTrays.push(trayId);
    }
  });
  
  // 2. ✅ Get ALL available tray IDs (excluding ONLY valid delink candidates)
  const availableTrayIds = allRemainingTrays
    .filter(tray => !validScannedDelinkTrays.includes(tray.tray_id))  
      .map(tray => tray.tray_id)
    .sort(); // Sort for consistent ordering
  console.log('🎯 Available tray IDs for rejection:', availableTrayIds);

  if (availableTrayIds.length === 0) {
    return {
      success: true,
      distributedTrays: [],
      iqfRejectionQty: 0,
      totalDistributed: 0
    };
  }
  
  // 3. ✅ GET IQF REJECTION QUANTITY from the saved rejection data
  let iqfRejectionQty = 0;
  try {
    const stockLotId = document.getElementById('trayScanModal')?.dataset.stockLotId || lotId;
    const rejectionResponse = await fetch(`/iqf/iqf_get_rejected_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`);
    const rejectionData = await rejectionResponse.json();
    
    if (rejectionData.success && rejectionData.rejection_rows) {
      iqfRejectionQty = rejectionData.rejection_rows.reduce((sum, row) => {
        return sum + (parseInt(row.qty) || 0);
      }, 0);
    }
    
    console.log('📊 IQF Rejection Quantity:', iqfRejectionQty);
    
  } catch (error) {
    console.error('❌ Error fetching IQF rejection data:', error);
    return {
      success: false,
      error: 'Failed to fetch IQF rejection quantity'
    };
  }
  
  if (iqfRejectionQty <= 0) {
    return {
      success: false,
      error: 'No IQF rejection quantity found to distribute'
    };
  }
  
  // 4. ✅ GET DYNAMIC TRAY CAPACITY
  let trayCapacity = null;
  try {
    const capacityResult = await fetchTrayCapacityDynamic(lotId);
    if (!capacityResult.success) {
      return {
        success: false,
        error: `Tray capacity error: ${capacityResult.error}`
      };
    }
    trayCapacity = capacityResult.tray_capacity;
  } catch (error) {
    return {
      success: false,
      error: `Failed to fetch tray capacity: ${error.message}`
    };
  }
  
  // 5. ✅ FIXED DISTRIBUTION ALGORITHM - FIXED QUANTITIES, SHUFFLE TRAY IDs
  const distributedTrays = [];
  
  // Calculate fixed distribution pattern (4, 12, 12, 12 for qty=40, capacity=12)
  const remainder = iqfRejectionQty % trayCapacity;
  const fullTraysNeeded = Math.floor(iqfRejectionQty / trayCapacity);
  
  const fixedQuantities = [];
  if (remainder > 0) {
    fixedQuantities.push(remainder); // First: 4 (Top Tray)
  }
  for (let i = 0; i < fullTraysNeeded; i++) {
    fixedQuantities.push(trayCapacity); // Then: 12, 12, 12
  }
  
  console.log('📊 Fixed quantities pattern:', fixedQuantities);
  
  // 6. ✅ Assign fixed quantities to available tray IDs
  for (let i = 0; i < fixedQuantities.length && i < availableTrayIds.length; i++) {
    distributedTrays.push({
      tray_id: availableTrayIds[i],
      distributed_qty: fixedQuantities[i],
      is_top_tray: i === 0 && remainder > 0
    });
  }
  
  const totalDistributed = distributedTrays.reduce((sum, t) => sum + t.distributed_qty, 0);
  
  console.log('🎯 FIXED DISTRIBUTION RESULT:', {
    iqfRejectionQty,
    trayCapacity,
    fixedQuantities,
    availableTrayIds,
    distributedTrays,
    totalDistributed,
    validScannedDelinkTrays
  });
  
  return {
    success: true,
    iqfRejectionQty,
    trayCapacity,
    distributedTrays,
    totalDistributed
  };
}

// ✅ UPDATED: Render rejection table with FIXED QUANTITIES, SHUFFLED TRAY IDs
async function renderOptimalRejectionTable(allRemainingTrays, lotId) {
  console.log('🎯 Rendering rejection table with FIXED quantities...');
  
  // Get distribution with fixed quantities and shuffled tray IDs
  const distribution = await calculateOptimalRejectionDistribution(allRemainingTrays, lotId);
  
  if (!distribution.success) {
    console.error('❌ Distribution calculation failed:', distribution.error);
    return `
      <tr>
        <td colspan="4" style="text-align: center; padding: 20px; color: #dc3545;">
          <div style="border: 2px solid #f44336; border-radius: 8px; background-color: #ffebee; padding: 15px;">
            <i class="fa fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 10px;"></i><br>
            <strong>Distribution Error:</strong><br>
            ${distribution.error}
          </div>
        </td>
      </tr>
    `;
  }
  
  const { distributedTrays, iqfRejectionQty, totalDistributed } = distribution;
  
  // ✅ Build table rows with FIXED quantities and shuffled tray IDs
  let tableRows = '';
  distributedTrays.forEach((tray, i) => {
    const isTopTray = tray.is_top_tray ? ' (Top Tray)' : '';
    tableRows += `
      <tr>
        <td style="padding: 6px;">${i + 1}${isTopTray}</td>
        <td style="padding: 6px;">
          <input type="text" class="rejection-tray-id-input" 
                 value="${tray.tray_id}" 
                 style="width: 100%; padding: 4px; font-size: 13px; background-color: #e8f5e9; border: 2px solid #28a745;" 
                 readonly />
        </td>
        <td style="padding: 6px;">
          <input type="number" class="rejection-qty-input" 
                 value="${tray.distributed_qty}" 
                 style="width: 80px; padding: 4px; font-size: 13px; background-color: #fff3cd; border: 2px solid #856404; font-weight: bold;" 
                 readonly 
                 title="Fixed distributed quantity" />
        </td>

      </tr>
    `;
  });
  
  // If no trays available, show message
  if (distributedTrays.length === 0) {
    tableRows += `
      <tr>
        <td colspan="4" style="text-align: center; padding: 20px; color: #666; font-style: italic;">
          No tray IDs available for rejection verification (all moved to delink)
        </td>
      </tr>
    `;
  }
  
  // Update count display
  const remainingCountSpan = document.getElementById('remaining-count');
  if (remainingCountSpan) {
    remainingCountSpan.textContent = distributedTrays.length;
    remainingCountSpan.style.color = '#28a745';
  }
  
  console.log(`✅ Rejection table rendered: ${distributedTrays.length} trays, total ${totalDistributed} (fixed quantities)`);
  return tableRows;
}

// ✅ Enhanced error handling for tray capacity failures
function showTrayCapacityError(errorMessage) {
  console.error('🚨 Tray Capacity Error:', errorMessage);
  
  const acceptedTrayContainer = document.getElementById('accepted-tray-table-container');
  if (acceptedTrayContainer) {
    acceptedTrayContainer.style.display = 'none';
  }
  
  hideAcceptanceRemarksSection();
  
  const msgDiv = document.getElementById("batchRejectionMsg");
  if (msgDiv) {
    msgDiv.style.color = "#d32f2f";
    msgDiv.innerHTML = `
      <div style="padding: 15px; border: 2px solid #f44336; border-radius: 8px; background-color: #ffebee; margin: 10px 0;">
        <i class="fa fa-exclamation-triangle" style="margin-right: 8px;"></i>
        <strong>Tray Capacity Error:</strong><br>
        ${errorMessage}
        <br><br>
        <button onclick="location.reload()" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; margin-right: 10px;">
          <i class="fa fa-refresh"></i> Retry
        </button>
        <small style="color: #666;">Please contact administrator if error persists.</small>
      </div>
    `;
  }
}

function showRejectionTableError(errorMessage) {
  const rejectionTableBody = document.getElementById('rejection-table-body');
  const remainingCountSpan = document.getElementById('remaining-count');
  
  if (rejectionTableBody) {
    rejectionTableBody.innerHTML = `
      <tr>
        <td colspan="4" style="text-align: center; padding: 20px;">
          <div style="color: #dc3545; border: 2px solid #f44336; border-radius: 8px; background-color: #ffebee; padding: 15px;">
            <i class="fa fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 10px;"></i><br>
            <strong>Tray Capacity Error:</strong><br>
            ${errorMessage}
            <br><br>
            <button onclick="location.reload()" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px;">
              <i class="fa fa-refresh"></i> Retry
            </button>
          </div>
        </td>
      </tr>
    `;
  }
  
  if (remainingCountSpan) {
    remainingCountSpan.textContent = 'Error';
    remainingCountSpan.style.color = '#dc3545';
  }
}

// ✅ FIXED: Function to show read-only saved rejection data with header quantities
function showReadOnlyRejectionData(lotId, detailsDiv) {
  fetch(`/iqf/iqf_get_rejected_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
    .then(res => res.json())
    .then(data => {
      // ✅ Get the stored values from global variable
      const displayModelNo = window.currentModalValues?.modelNo || 'N/A';
      const displayLotQty = window.currentModalValues?.lotQty || '0';
      const displayMissingQty = window.currentModalValues?.missingQty || '0';
      const displayPhysicalQty = window.currentModalValues?.physicalQty || '0';
      
      console.log('🎯 Building read-only HTML with values:', {
        displayModelNo, displayLotQty, displayMissingQty, displayPhysicalQty
      });

      let html = '';

      // ✅ ADD HEADER WITH QUANTITIES AT THE TOP
      html += `
        <!-- ✅ HEADER Section with quantities -->
        <div style="margin-bottom: 15px; border-bottom: 2px solid #dc3545; padding-bottom: 12px;">
          <h4 style="margin: 0; font-weight: bold; color: #333;">
            IQF / Rejection Window /
            <span id="modalModelNo" style="color:#028084; margin-left: 10px; font-size: 18px; font-weight: bold;">
              ${displayModelNo}
            </span>
          </h4>
          <div style="font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 8px; margin-top: 8px;">
            <span>RW Qty: <span id="modalLotQty" style="font-weight:bold; color:#e67e22;">${displayLotQty}</span></span>
            <span style="color: #ccc;">|</span>
            <span>Missing Qty: <span id="modalMissingQty" style="font-weight:bold; color:#d32f2f;">${displayMissingQty}</span></span>
            <span style="color: #ccc;">|</span>
            <span>Physical Qty: <span id="modalPhysicalQty" style="font-weight:bold; color:#388e3c;">${displayPhysicalQty}</span></span>
          </div>
        </div>
      `;

      // Calculate totals for Brass and IQF quantities
      let totalBrassQty = 0;
      let totalIqfQty = 0;

      // Rejection Table - ADDED BRASS REJECTION COLUMN
      let tableRows = '';
      (data.rejection_rows || []).forEach((row, index) => {
        const brassQty = row.brass_rejection_qty || 0;
        const iqfQty = row.qty || 0;
        
        // Add to totals
        totalBrassQty += parseInt(brassQty);
        totalIqfQty += parseInt(iqfQty);
        
        tableRows += `
          <tr>
            <td style="padding: 6px;">${index + 1}</td>
            <td style="padding: 6px; color: #666;">${row.reason_id}</td>
            <td style="padding: 6px; color: #666;">${row.reason}</td>
            <td style="padding: 6px; color: #666;">
              <input type="number" value="${brassQty}" class="form-control" style="width: 70px; background-color: #f5f5f5; font-size: 13px;" readonly />
            </td>
            <td style="padding: 6px;">
              <input type="number" value="${iqfQty}" class="form-control" style="width: 70px; background-color: #f5f5f5; font-size: 13px;" readonly />
            </td>
          </tr>
        `;
      });

      // Add totals row
      if ((data.rejection_rows || []).length > 0) {
        tableRows += `
          <tr style="background-color: #f8f9fa; border-top: 2px solid #dee2e6; font-weight: bold;">
            <td colspan="3" style="padding: 8px; text-align: right; color: #495057;">TOTAL:</td>
            <td style="padding: 6px; color: #dc3545;">
              <input type="number" value="${totalBrassQty}" class="form-control" style="width: 70px; background-color: #fff3cd; font-size: 13px; font-weight: bold; border: 2px solid #856404;" readonly />
            </td>
            <td style="padding: 6px; color: #dc3545;">
              <input type="number" value="${totalIqfQty}" class="form-control" style="width: 70px; background-color: #d1ecf1; font-size: 13px; font-weight: bold; border: 2px solid #0c5460;" readonly />
            </td>
          </tr>
        `;
      }

      if (!tableRows) {
        tableRows = `<tr><td colspan="5" style="text-align:center; color:#999; padding: 6px;">No rejection data found.</td></tr>`;
      }

      html += `
        <table class="table table-bordered" style="margin-bottom: 10px;">
          <thead>
            <tr>
              <th colspan="5" style="padding: 8px; text-align: center; background-color: #dc3545; color: white; font-weight: bold; font-size: 16px;">
                Rejected Trays
              </th>
            </tr>
            <tr>
              <th style="padding: 6px;">S.No</th>
              <th style="padding: 6px;">Reason ID</th>
              <th style="padding: 6px;">Rejection Reason</th>
              <th style="padding: 6px;">Brass Qty</th>
              <th style="padding: 6px;">IQF Qty</th>
            </tr>
          </thead>
          <tbody>
            ${tableRows}
          </tbody>
        </table>
      `;

      // ✅ NEW: Rejected Tray ID Table (similar to Brass QC)
      let rejectedTrayIdRows = '';
      const rejectedTrayIds = data.rejected_tray_ids || [];
      
      if (rejectedTrayIds.length > 0) {
        // Sort: top_tray first, then by ID
        rejectedTrayIds.sort((a, b) => {
          if (a.top_tray && !b.top_tray) return -1;
          if (!a.top_tray && b.top_tray) return 1;
          return 0;
        });

        rejectedTrayIds.forEach((trayObj, index) => {
          const displaySno = trayObj.top_tray ? '1 (Top Tray)' : (index + 1);
          rejectedTrayIdRows += `
            <tr>
              <td style="padding: 6px; ${trayObj.top_tray ? 'background-color: #fff3cd; font-weight: bold;' : ''}">${displaySno}</td>
              <td style="padding: 6px; ${trayObj.top_tray ? 'background-color: #fff3cd;' : ''}">${trayObj.tray_id || ''}</td>
              <td style="padding: 6px; ${trayObj.top_tray ? 'background-color: #fff3cd;' : ''}">${trayObj.qty || 0}</td>
            </tr>
          `;
        });

        html += `
          <table class="table table-bordered" style="margin-bottom: 10px;">
            <thead>
              <tr>
                <th colspan="3" style="padding: 8px; text-align: center; background-color: #28a745; color: white; font-weight: bold; font-size: 16px;">
                  <i class="fa fa-cube" style="margin-right: 8px;"></i>Rejection Tray ID
                </th>
              </tr>
              <tr>
                <th style="padding: 6px; background-color: #28a745; color: white;">S.No</th>
                <th style="padding: 6px; background-color: #28a745; color: white;">Tray ID</th>
                <th style="padding: 6px; background-color: #28a745; color: white;">Tray Qty</th>
              </tr>
            </thead>
            <tbody>
              ${rejectedTrayIdRows}
            </tbody>
          </table>
        `;
      }

      // Accepted Table
      let acceptedRows = '';
      let allComments = [];
      (data.accepted_trays || []).forEach((row, index) => {
        acceptedRows += `
          <tr>
            <td style="padding: 6px;">${index + 1}</td>
            <td style="padding: 6px;">${row.tray_id}</td>
            <td style="padding: 6px;">${row.tray_qty}</td>
          </tr>
        `;
        if (row.accepted_comment && row.accepted_comment.trim()) {
          allComments.push(row.accepted_comment.trim());
        }
      });
      if (!acceptedRows) {
        acceptedRows = `<tr><td colspan="3" style="text-align:center; color:#999; padding: 6px;">No accepted tray data found.</td></tr>`;
      }
      
      html += `
        <table class="table table-bordered" style="margin-bottom: 10px;">
          <thead>
            <tr>
              <th colspan="3" style="padding: 8px; text-align: center; background-color: #28a745; color: white; font-weight: bold; font-size: 16px;">
                Accepted Trays
              </th>
            </tr>
            <tr>
              <th style="padding: 6px;">S.No</th>
              <th style="padding: 6px;">Tray ID</th>
              <th style="padding: 6px;">Quantity</th>
            </tr>
          </thead>
          <tbody>
            ${acceptedRows}
          </tbody>
        </table>
      `;

      // Add comments section
      if (allComments.length > 0) {
        const uniqueComments = [...new Set(allComments)];
        
        html += `
          <div style="margin-top: 10px; padding: 10px; border: 1px solid #28a745; border-radius: 6px; background-color: #f8fff8;">
            <h6 style="color: #28a745; margin-bottom: 8px; font-size: 14px;">
              <i class="fa fa-comment"></i> Acceptance Comments:
            </h6>
            ${uniqueComments.map(comment => `
              <div style="padding: 6px 10px; margin-bottom: 6px; background-color: #ffffff; border: 1px solid #28a745; border-radius: 4px; font-size: 13px;">
                ${comment}
              </div>
            `).join('')}
          </div>
        `;
      }

      detailsDiv.innerHTML = html;

      console.log('✅ Read-only modal HTML generated with correct header values');

      // ✅ Show optimal distribution modal
      setTimeout(() => {
        showAcceptedTrayModalWithOptimalDistribution(data, lotId, true);
      }, 100);
      
    })
    .catch(error => {
      console.error('Error loading rejection data:', error);
      detailsDiv.innerHTML = `<div class="alert alert-danger">Error loading rejection data. Please try again.</div>`;
    });
}
// Function to fetch and show normal accepted tray data
function fetchAndShowAcceptedTrayData(lotId) {
  fetch(`/iqf/iqf_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
    .then(res => res.json())
    .then(rescanData => {
      if (rescanData.success) {
        showAcceptedTrayModalWithOptimalDistribution(rescanData, lotId, false);
      }
    })
    .catch(error => {
      console.error('Error fetching accepted tray data:', error);
      alert('Error loading accepted tray data. Please try again.');
    });
}

// Function to show read-only accepted tray data (for draft mode)
function showReadOnlyAcceptedTrayData(lotId, detailsDiv) {
  fetch(`/iqf/iqf_get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
    .then(res => res.json())
    .then(data => {
      if (data.success && data.has_draft) {
        showAcceptedTrayModalWithOptimalDistribution(data, lotId, true);
      } else {
        fetchAndShowAcceptedTrayData(lotId);
      }
    })
    .catch(error => {
      console.error('Error checking draft data:', error);
      fetchAndShowAcceptedTrayData(lotId);
    });
}

// ✅ ENHANCED: Modified showAcceptedTrayModalWithOptimalDistribution to check for draft
async function showAcceptedTrayModalWithOptimalDistribution(rescanData, lotId, isDraft) {
  let rows = rescanData.rows || [];   
  let modelNo = rescanData.model_no;
  rows.sort((a, b) => parseInt(a.tray_qty) - parseInt(b.tray_qty));
  
  rows.forEach((row, idx) => {
    row.sno = idx + 1;
  });

  let draftIndicator = isDraft ? ' (Draft)' : '';
  let draftAlert = '';
  
  // ✅ Check for optimal distribution draft
  const hasOptimalDraft = await loadOptimalDistributionDraft(lotId);
  if (hasOptimalDraft) {
    draftAlert = `

    `;
  }

  // Collect comments for display below table
  let allComments = [];
  rows.forEach((row, index) => {
    if (row.accepted_comment && row.accepted_comment.trim()) {
      allComments.push(row.accepted_comment.trim());
    }
  });

  // ✅ Fetch remaining trays to calculate optimal distribution
  let allRemainingTrays = [];
  
  try {
    const remainingTraysResponse = await fetch(`/iqf/iqf_get_remaining_trays/?lot_id=${encodeURIComponent(lotId)}`);
    const remainingTraysData = await remainingTraysResponse.json();
    
    if (remainingTraysData.success && remainingTraysData.remaining_trays) {
      allRemainingTrays = remainingTraysData.remaining_trays;
    }
    
    console.log('✅ All remaining trays from API:', allRemainingTrays);
    
    // Render the modal with OPTIMAL distribution
    await renderModalWithOptimalDistribution(allRemainingTrays, allComments, draftAlert, lotId);
    
    // ✅ Load draft data if exists and not already loaded
    if (!hasOptimalDraft) {
      setTimeout(() => {
        loadOptimalDistributionDraft(lotId);
      }, 1000);
    }
    
  } catch (error) {
    console.error('❌ Error fetching remaining trays:', error);
    await renderModalWithOptimalDistribution([], allComments, draftAlert, lotId);
  }
}

// ✅ FIXED: Update renderModalWithOptimalDistribution to use correct values
async function renderModalWithOptimalDistribution(allRemainingTrays, allComments, draftAlert, lotId) {
  // Calculate delink counts (unchanged)
  let delinkCount = 0;
  let availableTrays = [];
  
  try {
    const counts = await calculateDelinkAndRejectionCounts(allRemainingTrays, lotId);
    delinkCount = counts.delinkCount;
    availableTrays = counts.availableTrays;
  } catch (error) {
    console.error('❌ Error calculating counts:', error);
  }

  // ✅ FIXED: Use the same global values as left popup
  const displayModelNo = window.currentModalValues?.modelNo || 'N/A';
  const displayLotQty = window.currentModalValues?.lotQty || '0';
  const displayMissingQty = window.currentModalValues?.missingQty || '0';
  const displayPhysicalQty = window.currentModalValues?.physicalQty || '0';
  
  console.log('🎯 Using values for right popup:', {
    displayModelNo, displayLotQty, displayMissingQty, displayPhysicalQty
  });
  
  let html = `
    <!-- ✅ FIXED: Header Section with proper values -->
    <div style="margin-bottom: 10px; border-bottom: 1px solid #dc3545; padding-bottom: 8px;">
      <h4 style="margin: 0; font-weight: bold; color: #333;">
        IQF / Rejected Tray Scan /
        <span id="modalModelNo" style="color:#028084; margin-left: 10px; font-size: 18px; font-weight: bold;">
          ${displayModelNo}
        </span>
      </h4>

    </div>
    ${draftAlert}
  `;

  // Rest of the HTML remains the same...
  if (delinkCount > 0) {
    html += `
      <!-- Delink Table -->
      <table class="table table-bordered" style="margin-bottom: 15px;">
        <thead>
          <tr>
            <th colspan="2" style="padding: 8px; text-align: center; background-color: #6c757d; color: white; font-weight: bold; font-size: 16px;">
              Delink Table (${delinkCount} empty trays)
            </th>
          </tr>
          <tr>
            <th style="padding: 6px;">S.No</th>
            <th style="padding: 6px;">Tray ID (scan any available tray)</th>
          </tr>
        </thead>
        <tbody>
    `;
    
    for (let i = 0; i < delinkCount; i++) {
      html += `
        <tr>
          <td style="padding: 6px;">${i + 1}</td>
          <td style="padding: 6px;">
            <input type="text" class="delink-tray-id-input" 
                   placeholder="Scan any available tray ID" 
                   style="width: 100%; padding: 4px; font-size: 13px;" 
                   maxlength="9"
                   ${i === 0 ? 'autofocus' : ''}
                   data-index="${i}"
                   data-available-trays='${JSON.stringify(availableTrays)}'
                   data-lot-id="${lotId}" />
          </td>
        </tr>
      `;
    }
    
    html += `
        </tbody>
      </table>
    `;
  }

  // ✅ OPTIMAL DISTRIBUTION Rejection Table
  html += `
    <!-- Rejection Verification Table with OPTIMAL DISTRIBUTION -->
    <table class="table table-bordered" style="margin-bottom: 15px;">
      <thead>
        <tr>
          <th colspan="4" style="padding: 8px; text-align: center; background-color: #6c757d; color: white; font-weight: bold; font-size: 16px;">
            Rejection - Tray To be verify (<span id="remaining-count">calculating...</span> trays)
          </th>
        </tr>
        <tr>
          <th style="padding: 6px;">S.No</th>
          <th style="padding: 6px;">Tray ID</th>
          <th style="padding: 6px;">
            Qty
            <span style="margin-left: 10px;">
              <input type="checkbox" id="selectAllVerifyCheckbox" 
                     style="width: 18px; height: 18px; cursor: pointer; vertical-align: middle;" />
              <label for="selectAllVerifyCheckbox" style="font-size: 12px; cursor: pointer; margin: 0; vertical-align: middle;">
                Verify All
              </label>
            </span>
          </th>
        </tr>
      </thead>
      <tbody id="rejection-table-body">
        <tr>
          <td colspan="4" style="text-align: center; padding: 20px; color: #007bff;">
            <i class="fa fa-spinner fa-spin"></i> Calculating optimal distribution...
          </td>
        </tr>
      </tbody>
    </table>
  `;

  // Add comments section (if any)
  if (allComments.length > 0) {
    const uniqueComments = [...new Set(allComments)];
    
    html += `
      <div style="margin-top: 10px; padding: 10px; border: 1px solid #28a745; border-radius: 6px; background-color: #f8fff8;">
        <h6 style="color: #28a745; margin-bottom: 8px; font-size: 14px;">
          <i class="fa fa-comment"></i> Acceptance Comments:
        </h6>
        ${uniqueComments.map(comment => `
          <div style="padding: 6px 10px; margin-bottom: 6px; background-color: #ffffff; border: 1px solid #28a745; border-radius: 4px; font-size: 13px;">
            ${comment}
          </div>
        `).join('')}
      </div>
    `;
  }

  // Buttons
  html += `
    <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
      <button id="acceptedTrayDraftBtn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
      <button id="acceptedTraySubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
      <button id="acceptedTrayCancelBtn" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">Cancel</button>
    </div>
    <div id="acceptedTrayMsg" style="margin-top: 10px; text-align: center; font-weight: bold;"></div>
  `;
  
  document.querySelector("#newPopupModal .iqf-confirmation-modal-content").innerHTML = html;
  newPopupModal.classList.add("open");
  
  console.log('✅ Right popup rendered with model no:', displayModelNo);
  
  // ✅ Add scan handlers for delink table (this will auto-load the rejection table)
  addDelinkScanHandlers(availableTrays, allRemainingTrays, lotId);
  
  // ✅ Set focus on first delink input after handlers are attached
  setTimeout(() => {
    const firstDelinkInput = document.querySelector('.delink-tray-id-input');
    if (firstDelinkInput) {
      firstDelinkInput.focus();
      console.log('✅ Auto-focus set on first delink input');
    }
  }, 100);
  
  // Add event listeners
  addNormalModeEventListeners(lotId);
  
  // ✅ CRITICAL: Setup auto-save for accepted tray modal
  if (typeof autoSaveManager !== 'undefined') {
    // Setup auto-save listeners for this modal
    setTimeout(() => {
      autoSaveManager.setupAutoSaveListeners(lotId, '');
      console.log('✅ [AUTO-SAVE] Auto-save setup for accepted tray modal complete');
    }, 500);
  }
  
  // ✅ ADD THIS: Auto-load draft after modal is fully rendered
  setTimeout(async () => {
    console.log('🔄 Auto-loading draft on modal open for lot:', lotId);
    const result = await loadOptimalDistributionDraft(lotId);
    if (result.success) {
      console.log('✅ Draft auto-loaded successfully');
    } else {
      console.log('ℹ️ No existing draft found');
    }
  }, 1000);
}

// ✅ FIXED: calculateDelinkAndRejectionCounts - COUNT delink candidates, ALLOW ALL final remaining trays
async function calculateDelinkAndRejectionCounts(allRemainingTrays, lotId) {
  console.log('🔢 Calculating delink and rejection counts...');
  
  // 1. ✅ Count delink candidates for ROW COUNT purposes only
  const delinkCount = allRemainingTrays.filter(tray => tray.is_delink_candidate).length;
  
  // 2. ✅ Get ALL final remaining tray IDs (regardless of remaining_qty)
  const availableTrays = allRemainingTrays.map(tray => tray.tray_id);
  
  // 3. ✅ CRITICAL: Fetch tray capacity dynamically - NO FALLBACK
  let trayCapacity = null;
  try {
    const capacityResult = await fetchTrayCapacityDynamic(lotId);
    if (!capacityResult.success) {
      throw new Error(capacityResult.error);
    }
    trayCapacity = capacityResult.tray_capacity;
  } catch (error) {
    console.error('❌ Tray capacity error in calculateDelinkAndRejectionCounts:', error);
    throw new Error(`Tray capacity fetch failed: ${error.message}`);
  }

  if (!trayCapacity || trayCapacity <= 0) {
    throw new Error('Invalid tray capacity received from server');
  }
  
  console.log('📊 Calculated counts with dynamic capacity:', {
    delinkCount, // Count from delink candidates
    availableTrays: availableTrays, // ALL final remaining tray IDs
    trayCapacity
  });
  
  return {
    delinkCount: delinkCount,
    availableTrays: availableTrays, // ALL final remaining tray IDs for user scanning
    trayCapacity: trayCapacity
  };
}

// ✅ UPDATED: Enhanced delink scan handlers - ALLOW ANY AVAILABLE TRAY
function addDelinkScanHandlers(availableTrays, allRemainingTrays, lotId) {
  console.log('🎯 Adding delink scan handlers for ANY AVAILABLE TRAY...');
  console.log('🎯 Available trays for scanning:', availableTrays);
  
  // Store globally for validation
  window.currentRemainingTrays = allRemainingTrays;
  
  document.querySelectorAll('.delink-tray-id-input').forEach((input, idx) => {
    input.placeholder = `Available: ${availableTrays.slice(0, 5).join(', ')}${availableTrays.length > 5 ? '...' : ''}`;
    input.title = `Available trays: ${availableTrays.join(', ')}`;
    
    // ✅ INSTANT VALIDATION: Trigger when 9 characters are entered
    input.addEventListener('input', async function() {
      const scannedTrayId = input.value.trim();
      
      // Clear previous styling while typing
      if (scannedTrayId.length < 9) {
        resetInputStyling(input);
        clearValidationError(input);
        return;
      }
      
      // When 9 characters reached, validate instantly
      if (scannedTrayId.length === 9) {
        const validation = validateDelinkTray(scannedTrayId, availableTrays);
        
        if (validation.isValid) {
          input.style.borderColor = '#28a745';
          input.style.backgroundColor = '#f8fff8';
          clearValidationError(input);
          await refreshRejectionTable(allRemainingTrays, lotId);
          
          // Auto-advance to next input field
          const currentIndex = parseInt(input.getAttribute('data-index'));
          const allDelinkInputs = document.querySelectorAll('.delink-tray-id-input');
          if (!isNaN(currentIndex) && currentIndex + 1 < allDelinkInputs.length) {
            allDelinkInputs[currentIndex + 1].focus();
          }
        } else {
          // ✅ INSTANT AUTO-SELECT: No delay, select immediately
          input.style.borderColor = '#dc3545';
          input.style.backgroundColor = '#fff5f5';
          showInputValidationError(input, validation.error);
          input.select();
          await refreshRejectionTable(allRemainingTrays, lotId);
        }
      }
    });
    
    input.addEventListener('blur', async function() {
      const scannedTrayId = input.value.trim();

      // Always clear previous error
      clearValidationError(input);

      if (!scannedTrayId) {
        resetInputStyling(input);
        await refreshRejectionTable(allRemainingTrays, lotId);
        return;
      }

      const validation = validateDelinkTray(scannedTrayId, availableTrays);

      if (validation.isValid) {
        input.style.borderColor = '#28a745';
        input.style.backgroundColor = '#f8fff8';
        clearValidationError(input);
        await refreshRejectionTable(allRemainingTrays, lotId);
        
        // Auto-advance to next input field
        const currentIndex = parseInt(input.getAttribute('data-index'));
        const allDelinkInputs = document.querySelectorAll('.delink-tray-id-input');
        if (!isNaN(currentIndex) && currentIndex + 1 < allDelinkInputs.length) {
          allDelinkInputs[currentIndex + 1].focus();
        }
      } else {
        input.style.borderColor = '#dc3545';
        input.style.backgroundColor = '#fff5f5';
        showInputValidationError(input, validation.error);
        input.select();
        await refreshRejectionTable(allRemainingTrays, lotId);
      }
    });
    
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        input.blur();
      }
    });
  });

    document.querySelectorAll('.delink-tray-id-input').forEach(function(input) {
    input.addEventListener('input', function() {
      const trayId = input.value.trim();
      const selectAllCheckbox = document.getElementById('selectAllVerifyCheckbox');
      // If any delink tray input is filled, uncheck Verify All
      if (trayId && selectAllCheckbox && selectAllCheckbox.checked) {
        selectAllCheckbox.checked = false;
      }
    });
  });
  
  // ✅ Initial load of rejection table
  refreshRejectionTable(allRemainingTrays, lotId);
}


// ✅ NEW: Helper function to refresh rejection table
async function refreshRejectionTable(allRemainingTrays, lotId) {
  const rejectionTableBody = document.getElementById('rejection-table-body');
  if (rejectionTableBody) {
    rejectionTableBody.innerHTML = `
      <tr>
        <td colspan="4" style="text-align: center; padding: 10px; color: #007bff;">
          <i class="fa fa-spinner fa-spin"></i> Updating...
        </td>
      </tr>
    `;
    
    const tableRows = await renderOptimalRejectionTable(allRemainingTrays, lotId);
    rejectionTableBody.innerHTML = tableRows;
  }
}

// Validate delink tray - ✅ ONLY ALLOW is_delink_candidate: true TRAYS
function validateDelinkTray(trayId, availableTrays) {
  console.log(`🔍 FIXED VALIDATION: Checking tray: ${trayId}`);
  console.log(`🔍 Available trays:`, availableTrays);
  
  // 1. ONLY check if tray is in available pool - NO OTHER RESTRICTIONS
  if (!availableTrays.includes(trayId)) {
    console.log(`❌ Tray ${trayId} not in available list`);
    return {
      isValid: false,
      error: `Available trays: ${availableTrays.slice(0, 10).join(', ')}${availableTrays.length > 10 ? '...' : ''}`
    };
  }
  
  // 2. ❌ REMOVED: All delink candidate checks - ANY AVAILABLE TRAY IS ALLOWED
  
  // 3. Check for duplicates in delink table
  const allDelinkInputs = document.querySelectorAll('.delink-tray-id-input');
  let duplicateCount = 0;
  
  allDelinkInputs.forEach(input => {
    if (input.value.trim() === trayId) {
      duplicateCount++;
    }
  });
  
  if (duplicateCount > 1) {
    console.log(`❌ Duplicate tray ${trayId}`);
    return {
      isValid: false,
      error: 'Tray already scanned in delink table'
    };
  }
  
  // ✅ SUCCESS - NO DELINK CANDIDATE CHECKS
  console.log(`✅ FIXED VALIDATION: Tray ${trayId} is valid for delink`);
  return {
    isValid: true,
    error: null
  };
}

// Helper functions
function clearValidationError(input) {
  // Use the correct class name
  const existingError = input.parentNode.querySelector('.input-validation-error');
  if (existingError) existingError.remove();
}

function resetInputStyling(input) {
  input.style.borderColor = '';
  input.style.backgroundColor = '';
}

function showInputValidationError(input, errorMessage) {
  const errorDiv = document.createElement('div');
  errorDiv.className = 'validation-error';
  errorDiv.style.color = '#dc3545';
  errorDiv.style.fontSize = '11px';
  errorDiv.style.marginTop = '2px';
  errorDiv.style.fontWeight = 'bold';
  errorDiv.textContent = errorMessage;
  
  input.parentNode.appendChild(errorDiv);
}

// ✅ COMPLETE VALIDATION FUNCTION (add this near the top of your script):
function validateSubmitRequirementsWithFeedback() {
  // 1. Validate delink table (if present)
  const delinkInputs = document.querySelectorAll('.delink-tray-id-input');
  let allDelinkFilled = true;
  let emptyDelinkInputs = [];
  delinkInputs.forEach((input, index) => {
    const trayId = input.value.trim();
    const isValid = input.style.borderColor === 'rgb(40, 167, 69)'; // Green border
    if (!trayId || !isValid) {
      allDelinkFilled = false;
      emptyDelinkInputs.push(index + 1);
      input.style.borderColor = '#f44336';
      input.style.borderWidth = '3px';
      input.style.backgroundColor = '#ffebee';
    }
  });
  if (!allDelinkFilled && delinkInputs.length > 0) {
    // Show error for delink table
    let firstEmptyInput = delinkInputs[emptyDelinkInputs[0] - 1];
    if (firstEmptyInput) {
      firstEmptyInput.focus();
      firstEmptyInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    alert(`Please fill all delink tray IDs (missing: Row ${emptyDelinkInputs.join(', ')})`);
    return false;
  }

  // 2. Validate "Verify All" checkbox
  const selectAllCheckbox = document.getElementById('selectAllVerifyCheckbox');
  if (!selectAllCheckbox || !selectAllCheckbox.checked) {
    // Highlight and show error
    let label = document.querySelector('label[for="selectAllVerifyCheckbox"]');
    if (label) {
      label.style.color = '#d32f2f';
      label.style.fontWeight = 'bold';
    }
    selectAllCheckbox.style.outline = '3px solid #f44336';
    selectAllCheckbox.style.outlineOffset = '2px';
    selectAllCheckbox.scrollIntoView({ behavior: 'smooth', block: 'center' });
    setTimeout(() => {
      selectAllCheckbox.style.outline = '';
      selectAllCheckbox.style.outlineOffset = '';
      if (label) {
        label.style.color = '';
        label.style.fontWeight = '';
      }
    }, 3000);
    alert('Please check "Verify All" before submitting.');
    return false;
  }

  // 3. No individual row checkbox validation needed

  // All validations passed
  return true;
}

// ✅ Error display function
// Show validation error below the input and focus it
function showInputValidationError(input, message) {
  // Remove any previous error
  let errorDiv = input.parentElement.querySelector('.input-validation-error');
  if (errorDiv) errorDiv.remove();

  // Create error div
  errorDiv = document.createElement('div');
  errorDiv.className = 'input-validation-error';
  errorDiv.style.color = '#d32f2f';
  errorDiv.style.fontSize = '12px';
  errorDiv.style.marginTop = '2px';
  errorDiv.style.fontWeight = 'bold';
  errorDiv.textContent = message;

  input.parentElement.appendChild(errorDiv);

  // Focus the input
  input.focus();
  input.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

// ==========================================
// DRAFT DATA LOADING (Following Brass QC Pattern)
// ==========================================

async function loadDraftData(lotId) {
  if (!lotId) return;
  
  try {
    console.log('🔄 [DRAFT-LOAD] Loading draft data for lot:', lotId);
    
    // Load draft data from backend
    const response = await fetch(`/iqf/iqf_get_all_drafts/?lot_id=${lotId}`);
    const result = await response.json();
    
    console.log('📋 [DRAFT-LOAD] Backend response:', result);
    console.log('🔍 [DRAFT-LOAD] Response details:', {
      success: result.success,
      has_lot_rejection: result.has_lot_rejection,
      has_tray_rejection: result.has_tray_rejection,
      has_accepted_tray: result.has_accepted_tray,
      lot_rejection_keys: result.lot_rejection_data ? Object.keys(result.lot_rejection_data) : [],
      tray_rejection_keys: result.tray_rejection_data ? Object.keys(result.tray_rejection_data) : [],
      accepted_tray_keys: result.accepted_tray_data ? Object.keys(result.accepted_tray_data) : []
    });
    
    if (result.success) {
      let foundAnyDraft = false;
      
      // ✅ Load lot rejection draft (batch rejection)
      if (result.has_lot_rejection && result.lot_rejection_data) {
        console.log('🔄 [DRAFT-LOAD] Loading lot rejection draft:', result.lot_rejection_data);
        loadLotRejectionDraft(result.lot_rejection_data);
        foundAnyDraft = true;
      }
      
      // ✅ Load tray rejection draft
      if (result.has_tray_rejection && result.tray_rejection_data) {
        console.log('🔄 [DRAFT-LOAD] Loading tray rejection draft:', result.tray_rejection_data);
        loadTrayRejectionDraft(result.tray_rejection_data);
        foundAnyDraft = true;
      }
      
      // ✅ Load accepted tray draft (top tray and delink trays)
      if (result.has_accepted_tray && result.accepted_tray_data) {
        console.log('🔄 [DRAFT-LOAD] Loading accepted tray draft');
        loadAcceptedTrayDraft(result.accepted_tray_data);
        foundAnyDraft = true;
      }
      
      // Show notification if any draft was found
      if (foundAnyDraft) {
        autoSaveManager.showAutoSaveNotification('Draft data restored');
        console.log('✅ [DRAFT-LOAD] All draft data loaded successfully');
      } else {
        console.log('ℹ️ [DRAFT-LOAD] No existing draft data found');
      }
    } else {
      console.log('⚠️ [DRAFT-LOAD] Backend returned error:', result.error);
    }
  } catch (error) {
    console.error('❌ [DRAFT-LOAD] Error loading draft data:', error);
  }
}

function loadLotRejectionDraft(draftData) {
  try {
    console.log('🔄 [DRAFT-LOAD] Loading lot rejection draft:', draftData);
    
    // Set lot rejection checkbox if it's a batch rejection
    if (draftData.batch_rejection) {
      const batchCheckbox = document.getElementById('batchRejection');
      if (batchCheckbox) {
        batchCheckbox.checked = true;
        batchCheckbox.dispatchEvent(new Event('change'));
      }
    }
    
    // Restore lot rejection remarks
    if (draftData.lot_rejected_comment) {
      const remarksInput = document.getElementById('lotRejectionRemarksInput');
      if (remarksInput) {
        remarksInput.value = draftData.lot_rejected_comment;
      }
    }
    
    // Restore total quantity
    if (draftData.total_qty) {
      const totalQtyElement = document.getElementById('rejection-total-qty');
      if (totalQtyElement) {
        totalQtyElement.textContent = draftData.total_qty;
      }
    }
    
    console.log('✅ [DRAFT-LOAD] Lot rejection draft loaded successfully');
  } catch (error) {
    console.error('❌ [DRAFT-LOAD] Error loading lot rejection draft:', error);
  }
}

function loadTrayRejectionDraft(draftData) {
  try {
    console.log('🔄 [DRAFT-LOAD] Loading tray rejection draft:', draftData);
    console.log('🔍 [DRAFT-LOAD] Draft data structure:', {
      tray_rejections: draftData.tray_rejections,
      batch_rejection: draftData.batch_rejection,
      acceptance_remarks: draftData.acceptance_remarks,
      tray_id_mappings: draftData.tray_id_mappings
    });
    
    // ✅ CRITICAL: Wait for table to be ready
    const rejectionTable = document.getElementById('rejection-table-body');
    if (!rejectionTable) {
      console.log('❌ [DRAFT-LOAD] Rejection table not found, retrying in 500ms...');
      setTimeout(() => loadTrayRejectionDraft(draftData), 500);
      return;
    }
    
    // Restore rejection quantities and tray IDs
    if (draftData.tray_rejections && Array.isArray(draftData.tray_rejections)) {
      console.log(`🔍 [DRAFT-LOAD] Processing ${draftData.tray_rejections.length} tray rejections`);
      
      draftData.tray_rejections.forEach((rejection, index) => {
        console.log(`🔍 [DRAFT-LOAD] Processing rejection ${index}:`, rejection);
        
        const reasonId = rejection.reason_id;
        const qty = rejection.qty || rejection.quantity || 0;
        const trayId = rejection.tray_id || '';
        
        console.log(`🔍 [DRAFT-LOAD] Looking for reason ID: ${reasonId}, qty: ${qty}, tray: ${trayId}`);
        
        // Find the row with this reason ID
        const reasonCells = document.querySelectorAll('#rejection-table-body td:nth-child(2)');
        console.log(`🔍 [DRAFT-LOAD] Found ${reasonCells.length} reason cells`);
        
        if (reasonCells.length === 0) {
          console.log('❌ [DRAFT-LOAD] No reason cells found, table may not be populated yet');
          return;
        }
        
        reasonCells.forEach((cell, cellIndex) => {
          const cellText = cell.textContent.trim();
          console.log(`🔍 [DRAFT-LOAD] Cell ${cellIndex}: "${cellText}" vs "${reasonId}"`);
          
          if (cellText === reasonId) {
            console.log(`✅ [DRAFT-LOAD] Found matching cell for reason ${reasonId}`);
            const row = cell.closest('tr');
            
            // Set quantity
            const qtyInput = row.querySelector('.rejection-qty-input');
            if (qtyInput && qty > 0) {
              const oldQty = qtyInput.value;
              qtyInput.value = qty;
              qtyInput.dispatchEvent(new Event('input'));
              qtyInput.dispatchEvent(new Event('change'));
              console.log(`✅ [DRAFT-LOAD] Quantity input: "${oldQty}" → "${qtyInput.value}"`);
            } else {
              console.log(`⚠️ [DRAFT-LOAD] Quantity input not found or qty is 0 for reason ${reasonId}`);
            }
            
            // Set tray ID
            const trayInput = row.querySelector('.tray-id-input');
            if (trayInput && trayId) {
              const oldTray = trayInput.value;
              trayInput.value = trayId;
              trayInput.dispatchEvent(new Event('input'));
              trayInput.dispatchEvent(new Event('change'));
              console.log(`✅ [DRAFT-LOAD] Tray input: "${oldTray}" → "${trayInput.value}"`);
            }
          }
        });
      });
    } else {
      console.log('❌ [DRAFT-LOAD] No tray_rejections array found or invalid format');
    }
    
    // ✅ FIXED: Restore accepted trays AFTER table updates have completed
    if (draftData.accepted_trays && Array.isArray(draftData.accepted_trays)) {
      console.log('🔄 [DRAFT-LOAD] Restoring accepted trays data:', draftData.accepted_trays);
      
      // Add delay to ensure table is fully rendered after quantity changes
      setTimeout(() => {
        const rows = document.querySelectorAll('#accepted-tray-table-body tr');
        console.log(`🔍 [DRAFT-LOAD] Found ${rows.length} accepted tray rows for restoration`);
        
        draftData.accepted_trays.forEach((tray, index) => {
          if (rows[index] && tray.tray_id) {
            const trayInput = rows[index].querySelector('.accepted-tray-id-input');
            if (trayInput) {
              const oldValue = trayInput.value;
              trayInput.value = tray.tray_id;
              trayInput.dispatchEvent(new Event('input', { bubbles: true }));
              trayInput.dispatchEvent(new Event('change', { bubbles: true }));
              console.log(`✅ [DRAFT-LOAD] Restored tray ${index + 1}: "${oldValue}" → "${tray.tray_id}"`);
            } else {
              console.log(`⚠️ [DRAFT-LOAD] Tray input not found for row ${index + 1}`);
            }
          } else {
            console.log(`⚠️ [DRAFT-LOAD] Row ${index + 1} not found or no tray_id in data`);
          }
        });
      }, 200); // Small delay to ensure table updates are complete
    } else {
      console.log('ℹ️ [DRAFT-LOAD] No accepted_trays data to restore');
    }
    
    // ✅ ENHANCED: Restore acceptance remarks with better error handling
    if (draftData.acceptance_remarks) {
      const remarksInput = document.getElementById('acceptanceRemarksInput');
      if (remarksInput) {
        const oldRemarks = remarksInput.value;
        remarksInput.value = draftData.acceptance_remarks;
        remarksInput.dispatchEvent(new Event('input', { bubbles: true }));
        console.log(`✅ [DRAFT-LOAD] Restored acceptance remarks: "${oldRemarks}" → "${draftData.acceptance_remarks}"`);
      } else {
        console.log('⚠️ [DRAFT-LOAD] Acceptance remarks input not found');
        
        // Retry finding the input after a delay
        setTimeout(() => {
          const retryRemarksInput = document.getElementById('acceptanceRemarksInput');
          if (retryRemarksInput) {
            retryRemarksInput.value = draftData.acceptance_remarks;
            retryRemarksInput.dispatchEvent(new Event('input', { bubbles: true }));
            console.log(`✅ [DRAFT-LOAD] Restored acceptance remarks (retry): "${draftData.acceptance_remarks}"`);
          } else {
            console.log('❌ [DRAFT-LOAD] Acceptance remarks input still not found after retry');
          }
        }, 300);
      }
    } else {
      console.log('ℹ️ [DRAFT-LOAD] No acceptance_remarks to restore');
    }
    
    console.log('✅ [DRAFT-LOAD] Tray rejection draft loaded successfully');
  } catch (error) {
    console.error('❌ [DRAFT-LOAD] Error loading tray rejection draft:', error);
  }
}

// ✅ NEW: Load accepted tray draft (top tray and delink trays)
function loadAcceptedTrayDraft(draftData) {
  try {
    console.log('🔄 [DRAFT-LOAD] Loading accepted tray draft:', draftData);
    
    // Wait a bit for DOM to be ready, then restore
    setTimeout(() => {
      
      // Restore top tray ID
      if (draftData.top_tray_id) {
        const topTrayInput = document.getElementById('topTrayIdInput');
        if (topTrayInput) {
          topTrayInput.value = draftData.top_tray_id;
          topTrayInput.dispatchEvent(new Event('input'));
          console.log('✅ [DRAFT-LOAD] Restored top tray ID:', draftData.top_tray_id);
        }
      }
      
      // Restore delink trays
      if (draftData.delink_trays && Array.isArray(draftData.delink_trays)) {
        const delinkInputs = document.querySelectorAll('.delink-tray-input');
        draftData.delink_trays.forEach((trayId, index) => {
          if (delinkInputs[index] && trayId) {
            delinkInputs[index].value = trayId;
            delinkInputs[index].dispatchEvent(new Event('input'));
            console.log('✅ [DRAFT-LOAD] Restored delink tray:', trayId);
          }
        });
      }
      
      // Restore acceptance remarks  
      if (draftData.acceptance_remarks) {
        const remarksInput = document.getElementById('acceptanceRemarksInput');
        if (remarksInput) {
          remarksInput.value = draftData.acceptance_remarks;
          remarksInput.dispatchEvent(new Event('input', { bubbles: true }));
          console.log('✅ [DRAFT-LOAD] Restored acceptance remarks:', draftData.acceptance_remarks);
        } else {
          console.log('⚠️ [DRAFT-LOAD] Acceptance remarks input not found');
        }
      } else {
        console.log('ℹ️ [DRAFT-LOAD] No acceptance remarks to restore');
      }
      
      console.log('✅ [DRAFT-LOAD] Accepted tray draft loaded successfully');
    }, 300);
    
  } catch (error) {
    console.error('❌ [DRAFT-LOAD] Error loading accepted tray draft:', error);
  }
}

// Helper function for CSRF token
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}

async function saveDraftTrayIdsToBackend(lotId, batchId = "") {
  // Collect tray data from the accepted tray table
  const trayRows = document.querySelectorAll('#accepted-tray-table-body tr');
  const draftTrays = [];

  trayRows.forEach(row => {
    const trayInput = row.querySelector('.accepted-tray-id-input');
    const qtyCell = row.cells[2];
    const tray_id = trayInput ? trayInput.value.trim() : "";
    const tray_qty = qtyCell ? parseInt(qtyCell.textContent.trim()) || 0 : 0;
    if (tray_id) {
      draftTrays.push({ tray_id, tray_qty });
    }
  });

  if (!lotId || draftTrays.length === 0) {
    showErrorNotification("No tray data to save as draft.");
    return;
  }

  try {
    const response = await fetch('/iqf/iqf_save_draft_tray_ids/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({
        lot_id: lotId,
        trays: draftTrays,
        batch_id: batchId || ""
      })
    });
    const data = await response.json();
    if (data.success) {
      showSuccessNotification("Draft saved successfully!");
    } else {
      showErrorNotification(data.error || "Failed to save draft.");
    }
  } catch (error) {
    showErrorNotification("Network error saving draft.");
  }
}
// Attach to Draft button in your renderModalWithOptimalDistribution
document.getElementById('acceptedTrayDraftBtn').addEventListener('click', function () {
  saveDraftTrayIdsToBackend(window.currentLotId || '');
});

// ✅ ENHANCED: Update button text based on draft status
function addNormalModeEventListeners(lotId) {
  // Store lotId globally for easy access
  window.currentOptimalDistributionLotId = lotId;
  
  // ✅ FIXED: Manual draft button handler using unified API
  const draftBtn = document.getElementById("acceptedTrayDraftBtn");
  if (draftBtn) {
    draftBtn.addEventListener("click", async function () {
      console.log('💾 Manual draft button clicked for lot:', lotId);
      
      try {
        // ✅ Collect accepted tray data using unified approach
        const topTrayIdInput = document.getElementById('topTrayIdInput');
        const top_tray_id = topTrayIdInput ? topTrayIdInput.value.trim() : '';
        
        const delinkInputs = document.querySelectorAll('.delink-tray-input');
        const delink_trays = Array.from(delinkInputs)
          .map(input => input.value.trim())
          .filter(id => id);
        
        // Create comprehensive draft data
        const draftData = {
          is_draft: true,
          is_manual_draft: true,
          top_tray_id: top_tray_id,
          delink_trays: delink_trays,
          timestamp: new Date().toISOString()
        };
        
        // ✅ Use new unified manual draft API
        const response = await fetch('/iqf/iqf_save_accepted_tray_draft/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify({
            lot_id: lotId,
            batch_id: '',
            top_tray_id: top_tray_id,
            delink_trays: delink_trays,
            draft_save: true  // This is manual draft
          })
        });
        
        const result = await response.json();
        
        if (result.success) {
          console.log('✅ Manual draft saved successfully');
          autoSaveManager.showAutoSaveNotification('Manual draft saved successfully!');
          draftBtn.textContent = 'Draft';
          draftBtn.style.background = '#007bff';
          
          // Reload page to show "Draft" status
          setTimeout(() => {
            window.location.reload();
          }, 1500);
        } else {
          console.error('❌ Failed to save manual draft:', result.error);
          autoSaveManager.showAutoSaveNotification('Failed to save manual draft');
        }
      } catch (error) {
        console.error('❌ Manual draft save error:', error);
        autoSaveManager.showAutoSaveNotification('Network error saving draft');
      }
    });
  }

  // ✅ KEEP EXISTING SUBMIT BUTTON HANDLER (with validation)
  const submitBtn = document.getElementById("acceptedTraySubmitBtn");
  if (submitBtn) {
    submitBtn.addEventListener("click", function () {
      console.log('🎯 Submit button clicked, starting validation...');
      
      // ✅ CRITICAL: Add validation before processing (keeps existing validation)
      if (!validateSubmitRequirementsWithFeedback()) {
        console.log('❌ Submit validation failed, aborting submission');
        return; // Stop submission if validation fails
      }
      
      console.log('✅ Submit validation passed, proceeding with submission');
      processAllTrayData(lotId, false, "Data saved successfully!");
    });
  }

  // ✅ KEEP EXISTING CANCEL BUTTON HANDLER
  const cancelBtn = document.getElementById("acceptedTrayCancelBtn");
  if (cancelBtn) {
    cancelBtn.addEventListener("click", function () {
      document.getElementById("newPopupModal").classList.remove("open");
      document.getElementById("trayScanModal").classList.remove("open");
      window.location.reload();
    });
  }
}

// ✅ NEW: Function to check if optimal distribution draft exists
async function checkOptimalDistributionDraft(lotId) {
  try {
    const response = await fetch(`/iqf/iqf_check_optimal_distribution_draft/?lot_id=${encodeURIComponent(lotId)}`);
    const data = await response.json();
    return data.success && data.has_draft;
  } catch (error) {
    console.error('Error checking optimal distribution draft:', error);
    return false;
  }
}

// ✅ FIXED: Modified processAllTrayData to match backend expectations
function processAllTrayData(lotId, isDraft, successMessage) {
  const msgP = document.getElementById("acceptedTrayMsg");
  
  if (msgP) {
    msgP.style.color = "#007bff";
    msgP.textContent = isDraft ? "Saving draft..." : "Processing data...";
  }

  // ✅ FIXED: Collect delink tray data - BACKEND EXPECTS ARRAY OF STRINGS
  const delinkTrays = [];
  document.querySelectorAll('.delink-tray-id-input').forEach((input) => {
    const trayId = input.value.trim();
    const isValid = input.style.borderColor === 'rgb(40, 167, 69)';
    
    // ✅ For final submit: only include valid tray IDs as strings
    // ✅ For draft: we need to handle this differently or modify backend
    if (!isDraft && trayId && isValid) {
      delinkTrays.push(trayId); // Backend expects string, not object
    } else if (isDraft && trayId) {
      // For draft, we still need to send just the tray ID for now
      // TODO: Backend needs to be modified to handle draft delink data properly
      delinkTrays.push(trayId);
    }
  });

  // ✅ FIXED: Collect verification data - BACKEND EXPECTS ARRAY WITH {tray_id, verified, qty}
  const verifications = [];
  const selectAllCheckbox = document.getElementById('selectAllVerifyCheckbox');
  
  // Get rejection table data and format for backend
  document.querySelectorAll('.rejection-tray-id-input').forEach((input, idx) => {
    const trayId = input.value.trim();
    const qtyInput = document.querySelectorAll('.rejection-qty-input')[idx];
    const qty = qtyInput ? parseInt(qtyInput.value.trim()) || 0 : 0;
    const checkbox = document.querySelectorAll('.rejection-verify-checkbox')[idx];
    
    if (trayId && qty > 0) {
      if (isDraft) {
        // For draft: include all entries with their status
        verifications.push({
          tray_id: trayId,
          verified: checkbox ? checkbox.checked : false,
          qty: qty,
          is_draft_entry: true // Custom flag for draft handling
        });
      } else {
        // For final submit: only include verified items when selectAll is checked
        if (selectAllCheckbox && selectAllCheckbox.checked && checkbox && checkbox.checked && !checkbox.disabled) {
          verifications.push({
            tray_id: trayId,
            verified: true,
            qty: qty
          });
        }
      }
    }
  });

  // ✅ NEW: Collect rejection_top_trays if needed (backend expects this field)
  const rejectionTopTrays = [];
  // This might be needed based on your business logic - currently empty

  console.log('✅ FIXED: Submitting data in correct format:', {
    delinkTrays,
    verifications,
    rejectionTopTrays,
    isDraft
  });

  // ✅ FIXED: Send data in format backend expects
  const requestBody = {
    lot_id: lotId,
    delink_trays: delinkTrays,           // Array of strings
    verifications: verifications,         // Array of objects with {tray_id, verified, qty}
    rejection_top_trays: rejectionTopTrays, // Array of objects with {tray_id, qty}
    is_draft: isDraft
  };

  // ✅ OPTIONAL: Add draft-specific fields if backend supports them
  if (isDraft) {
    // You might want to add additional draft metadata here
    requestBody.draft_metadata = {
      delink_count: document.querySelectorAll('.delink-tray-id-input').length,
      rejection_count: document.querySelectorAll('.rejection-tray-id-input').length,
      timestamp: new Date().toISOString()
    };
  }

  // Send data to backend
  fetch('/iqf/iqf_process_all_tray_data/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify(requestBody)
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      if (msgP) {
        msgP.style.color = "#388e3c";
        msgP.textContent = successMessage;
      }
      
      console.log('✅ All data processed successfully:', data);
      
      setTimeout(function() {
        if (isDraft) {
          // For draft, show success message and stay on modal
          if (msgP) {
            msgP.textContent = "Draft saved successfully!";
          }
        } else {
          // For final submit, reload page
          window.location.reload();
        }
      }, 1200);
      
    } else {
      if (msgP) {
        msgP.style.color = "#d32f2f";
        msgP.textContent = data.message || data.error || "Failed to process data";
      }
      
      // ✅ Enhanced error logging
      console.error('❌ Failed to process data:', {
        success: data.success,
        message: data.message,
        error: data.error,
        results: data.results,
        errors: data.results?.errors
      });
      
      // ✅ Show specific errors if available
      if (data.results && data.results.errors && data.results.errors.length > 0) {
        console.error('❌ Specific errors:', data.results.errors);
        
        // Optionally show first few errors to user
        const errorMessage = data.results.errors.slice(0, 2).join('; ');
        if (msgP) {
          msgP.innerHTML = `Failed to process data:<br><small>${errorMessage}</small>`;
        }
      }
    }
  })
  .catch(error => {
    console.error('❌ Network error processing tray data:', error);
    if (msgP) {
      msgP.style.color = "#d32f2f";
      msgP.textContent = "Network error. Please try again.";
    }
  });
}

// Show editable rejection form
function showEditableRejectionForm(stockLotId, batchId, detailsDiv, row) {
  // ✅ IMPROVED: Better extraction of missing quantity from multiple sources
  let missingQty = '0';
  
  console.log('🔍 Starting missing qty extraction for row:', row);
  
  // Method 1: Try to get from missing-qty-input field
  const missingQtyInput = row.querySelector('.missing-qty-input');
  if (missingQtyInput && missingQtyInput.value.trim()) {
    missingQty = missingQtyInput.value.trim();
    console.log('📍 Method 1 - From input field:', missingQty);
  }
  
  // Method 2: Try to get from row data attribute
  if (missingQty === '0') {
    const dataAttr = row.getAttribute('data-missing-qty');
    if (dataAttr && dataAttr !== 'None' && dataAttr !== 'null' && dataAttr !== '0') {
      missingQty = dataAttr;
      console.log('📍 Method 2 - From data attribute:', missingQty);
    }
  }
  
  // Method 3: Try to get from tray scan button attributes
  if (missingQty === '0') {
    const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
    if (trayScanBtn) {
      const btnMissingQty = trayScanBtn.getAttribute('data-missing-qty');
      if (btnMissingQty && btnMissingQty !== 'None' && btnMissingQty !== 'null' && btnMissingQty !== '0') {
        missingQty = btnMissingQty;
        console.log('📍 Method 3 - From button attribute:', missingQty);
      }
    }
  }
  
  // Method 4: Check window global variable
  if (missingQty === '0' && window.currentMissingQty && window.currentMissingQty !== '0') {
    missingQty = window.currentMissingQty;
    console.log('📍 Method 4 - From global variable:', missingQty);
  }
  
  console.log('✅ Final Missing Qty extracted:', missingQty);
  
  // ✅ Store globally for use in modal
  window.currentMissingQty = missingQty;

  // ✅ CRITICAL FIX: Update modal header immediately with correct missing qty
  const updateModalHeaderMissingQty = () => {
    // Try multiple possible element IDs for missing qty display
    const possibleIds = ['modalMissingQty', 'modalMissingQty_DayPlanning', 'modal-missing-qty'];
    
    possibleIds.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = missingQty;
        console.log(`✅ Updated ${id} with missing qty:`, missingQty);
      }
    });
    
    // Also try to find by class or other selectors
    const missingQtyElements = document.querySelectorAll('[id*="missing"], [class*="missing-qty"], .modal-missing-qty');
    missingQtyElements.forEach(element => {
      if (element.textContent.includes('Missing Qty') || element.closest('.modal-top-header')) {
        const span = element.querySelector('span') || element;
        if (span) {
          span.textContent = missingQty;
          console.log('✅ Updated missing qty span:', missingQty);
        }
      }
    });
  };

  // ✅ Update immediately
  updateModalHeaderMissingQty();
  
  // ✅ Update again after modal content is loaded (with delay)
  setTimeout(updateModalHeaderMissingQty, 100);
  setTimeout(updateModalHeaderMissingQty, 500);
  
  // Continue with the rest of the function...
  fetch(`/iqf/iqf_get_all_drafts/?lot_id=${encodeURIComponent(stockLotId)}`)
    .then(res => res.json())
    .then(draftResponse => {
      const hasLotRejectionDraft = draftResponse.success && draftResponse.lot_rejection_draft && draftResponse.lot_rejection_draft.has_draft;
      const hasTrayRejectionDraft = draftResponse.success && draftResponse.tray_rejection_draft && draftResponse.tray_rejection_draft.has_draft;

      buildRejectionFormHTML(detailsDiv, stockLotId, batchId, hasLotRejectionDraft, hasTrayRejectionDraft);

      // ✅ Update missing qty again after form is built
      setTimeout(updateModalHeaderMissingQty, 200);

      if (hasLotRejectionDraft) {
        waitForElement('#lotRejectionRemarksInput', 2000).then(() => {
          let draftData = draftResponse.lot_rejection_draft.draft_data;
          if (draftData && draftData.lot_rejection) {
            draftData = draftData.lot_rejection;
          }
          loadLotRejectionDraft(draftData);
        });
      } else if (hasTrayRejectionDraft) {
        waitForElement('#acceptanceRemarksInput', 2000).then(() => {
          let draftData = draftResponse.tray_rejection_draft.draft_data;
          if (draftData && draftData.tray_rejection) {
            draftData = draftData.tray_rejection;
          }
          loadTrayRejectionDraft(draftData);
        });
      }

      addEditableFormEventListeners(row, batchId, stockLotId);
    })
    .catch(error => {
      console.error('Error checking for draft data:', error);
      buildRejectionFormHTML(detailsDiv, stockLotId, batchId, false, false);
      addEditableFormEventListeners(row, batchId, stockLotId);
    });
}

function waitForElement(selector, timeout = 1000) {
  return new Promise((resolve, reject) => {
    const start = Date.now();
    function check() {
      const el = document.querySelector(selector);
      if (el) return resolve(el);
      if (Date.now() - start > timeout) return reject(new Error('Element not found: ' + selector));
      setTimeout(check, 50);
    }
    check();
  });
}

// ✅ FIXED: Update buildRejectionFormHTML to use stored values
function buildRejectionFormHTML(detailsDiv, stockLotId, batchId, hasLotRejectionDraft, hasTrayRejectionDraft) {
  // ✅ Get the stored values from global variable
  const displayModelNo = window.currentModalValues?.modelNo || 'N/A';
  const displayLotQty = window.currentModalValues?.lotQty || '0';
  const displayMissingQty = window.currentModalValues?.missingQty || '0';
  const displayPhysicalQty = window.currentModalValues?.physicalQty || '0';
  
  console.log('🎯 Building HTML with values:', {
    displayModelNo, displayLotQty, displayMissingQty, displayPhysicalQty
  });
  
  const draftIndicator = (hasLotRejectionDraft || hasTrayRejectionDraft) ? 
    `<div class="alert alert-info" style="margin-bottom: 15px; padding: 12px 16px; border-left: 4px solid #007bff; background: linear-gradient(135deg, #e7f3ff 0%, #fff5bd 100%); border-radius: 8px; box-shadow: 0 2px 4px rgba(0,123,255,0.1);">
      <i class="fa fa-info-circle" style="color: #007bff; margin-right: 8px;"></i> 
      <strong style="color: #0056b3;">Draft Found:</strong> 
      <span style="color: #495057;">${hasLotRejectionDraft ? 'Lot rejection' : 'Tray rejection'} draft data loaded. You can continue editing.</span>
    </div>` : '';

  // ✅ CREATE FULL-SCREEN CENTERED MODAL OVERLAY
  let modalOverlay = document.getElementById('iqfRejectionModalOverlay');
  if (!modalOverlay) {
    modalOverlay = document.createElement('div');
    modalOverlay.id = 'iqfRejectionModalOverlay';
    modalOverlay.className = 'iqf-rejection-modal-overlay';
    document.body.appendChild(modalOverlay);
  }

  modalOverlay.innerHTML = `
    <!-- Alert Notification -->
    <div id="iqf-modal-alert" class="iqf-modal-alert" style="display: none;">
      <div class="alert alert-warning alert-dismissible fade show" role="alert">
        <strong>Warning!</strong> <span id="iqf-alert-message">This is a warning message.</span>
        <button type="button" class="btn-close" onclick="hideIQFModalAlert()"></button>
      </div>
    </div>

    <div class="iqf-rejection-modal-container">
      <!-- Modal Header -->
      <div class="iqf-rejection-modal-header">
        <div style="display: flex; align-items: center; gap: 20px;">
          <h3 class="iqf-rejection-modal-title" style="color: #000;">
            <i class="fa fa-clipboard-list"></i>
            IQF / Rejection Window
          </h3>
          <span class="iqf-rejection-model-badge" id="modalModelNo">${displayModelNo}</span>
        </div>
        <button class="iqf-rejection-modal-close" id="iqfModalCloseBtn" type="button">
          <i class="fa fa-times"></i>
        </button>
      </div>

      <!-- Modal Body -->
      <div class="iqf-rejection-modal-body">
        ${draftIndicator}
        
        <!-- Quantity Info Bar -->
        <div class="iqf-qty-info-bar">
          <div class="iqf-qty-item rw">
            <i class="fa fa-box"></i>
            <div>
              <div class="iqf-qty-label">RW Qty</div>
              <div class="iqf-qty-value" id="modalLotQty">${displayLotQty}</div>
            </div>
          </div>
          <div class="iqf-qty-item missing">
            <i class="fa fa-exclamation-triangle"></i>
            <div>
              <div class="iqf-qty-label">Missing Qty</div>
              <div class="iqf-qty-value" id="modalMissingQty">${displayMissingQty}</div>
            </div>
          </div>
          <div class="iqf-qty-item physical">
            <i class="fa fa-check-circle"></i>
            <div>
              <div class="iqf-qty-label">Physical Qty</div>
              <div class="iqf-qty-value" id="modalPhysicalQty">${displayPhysicalQty}</div>
            </div>
          </div>
        </div>

        <!-- Loading Indicator -->
        <div class="d-flex justify-content-center align-items-center" style="padding: 50px;">
          <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
            <span class="sr-only">Loading...</span>
          </div>
          <span style="margin-left: 15px; font-size: 16px; color: #6c757d; font-weight: 500;">Loading tray capacity and rejection data...</span>
        </div>
      </div>

      <!-- Modal Footer -->
      <div class="iqf-rejection-modal-footer" style="display: none;" id="iqfModalFooter">
        <button class="iqf-modal-btn draft" id="draftButton" type="button">
          <i class="fa fa-save"></i>
          ${(hasLotRejectionDraft || hasTrayRejectionDraft) ? 'Update Draft' : 'Save Draft'}
        </button>
        <button class="iqf-modal-btn proceed" id="proceedButton" type="button">
          <i class="fa fa-arrow-right"></i>
          Proceed
        </button>
        <button class="iqf-modal-btn cancel" id="cancelButton" type="button">
          <i class="fa fa-times"></i>
          Cancel
        </button>
      </div>
    </div>
  `;

  // Show the modal
  modalOverlay.classList.add('active');

  // Close button handler
  document.getElementById('iqfModalCloseBtn').addEventListener('click', function() {
    modalOverlay.classList.remove('active');
    window.location.reload();
  });

  // Click outside to close
  modalOverlay.addEventListener('click', function(e) {
    if (e.target === modalOverlay) {
      modalOverlay.classList.remove('active');
    }
  });

  const modalBodyContent = modalOverlay.querySelector('.iqf-rejection-modal-body');
  
  // ✅ Clear detailsDiv as modal is now handling all content
  detailsDiv.innerHTML = '';

  // ✅ Fetch tray capacity with proper error handling
  fetchTrayCapacityDynamic(stockLotId)
    .then(capacityResult => {
      if (!capacityResult.success) {
        modalBodyContent.innerHTML = `
          ${draftIndicator}
          <div class="iqf-qty-info-bar">
            <div class="iqf-qty-item rw">
              <i class="fa fa-box"></i>
              <div>
                <div class="iqf-qty-label">RW Qty</div>
                <div class="iqf-qty-value" id="modalLotQty">${displayLotQty}</div>
              </div>
            </div>
            <div class="iqf-qty-item missing">
              <i class="fa fa-exclamation-triangle"></i>
              <div>
                <div class="iqf-qty-label">Missing Qty</div>
                <div class="iqf-qty-value" id="modalMissingQty">${displayMissingQty}</div>
              </div>
            </div>
            <div class="iqf-qty-item physical">
              <i class="fa fa-check-circle"></i>
              <div>
                <div class="iqf-qty-label">Physical Qty</div>
                <div class="iqf-qty-value" id="modalPhysicalQty">${displayPhysicalQty}</div>
              </div>
            </div>
          </div>
          <div class="alert alert-danger text-center" style="padding: 20px; border-radius: 10px; border-left: 4px solid #dc3545; background: linear-gradient(135deg, #fff5f5 0%, #ffe6e6 100%);">
            <i class="fa fa-exclamation-triangle" style="font-size: 24px; color: #dc3545; margin-bottom: 10px;"></i>
            <h5 style="color: #721c24; margin-bottom: 8px;">Tray Capacity Error</h5>
            <p style="color: #856404; margin-bottom: 15px;">${capacityResult.error}</p>
            <div style="display: flex; justify-content: center; gap: 10px;">
              <button onclick="location.reload()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 25px; font-weight: 600;">
                <i class="fa fa-refresh" style="margin-right: 6px;"></i>Retry
              </button>
            </div>
          </div>
        `;
        document.getElementById('cancelButton').addEventListener('click', () => {
          modalOverlay.classList.remove('active');
        });
        document.getElementById('iqfModalFooter').style.display = 'flex';
        return;
      }

      const trayCapacity = capacityResult.tray_capacity;
      console.log(`🏗️ Using tray capacity: ${trayCapacity}`);

      // Continue with brass rejection data fetch
      return fetch(`/iqf/iqf_get_brass_rejection_quantities/?lot_id=${encodeURIComponent(stockLotId)}`);
    })
    .then(res => {
      if (!res) return;
      return res.json();
    })
    .then(data => {
      if (!data || !data.success) {
        throw new Error(data?.error || 'Failed to fetch rejection data');
      }

      const rejectionReasons = data.rejection_reasons || [];
      const brassRejectionQtyMap = data.brass_rejection_qty_map || {};
      const allBrassZero = Object.values(brassRejectionQtyMap).every(qty => !qty || qty === 0);
      const lotRejectedComment = data.lot_rejected_comment || "";

      if (rejectionReasons.length === 0) {
        modalBodyContent.innerHTML = `
          ${draftIndicator}
          <div class="iqf-qty-info-bar">
            <div class="iqf-qty-item rw">
              <i class="fa fa-box"></i>
              <div>
                <div class="iqf-qty-label">RW Qty</div>
                <div class="iqf-qty-value" id="modalLotQty">${displayLotQty}</div>
              </div>
            </div>
            <div class="iqf-qty-item missing">
              <i class="fa fa-exclamation-triangle"></i>
              <div>
                <div class="iqf-qty-label">Missing Qty</div>
                <div class="iqf-qty-value" id="modalMissingQty">${displayMissingQty}</div>
              </div>
            </div>
            <div class="iqf-qty-item physical">
              <i class="fa fa-check-circle"></i>
              <div>
                <div class="iqf-qty-label">Physical Qty</div>
                <div class="iqf-qty-value" id="modalPhysicalQty">${displayPhysicalQty}</div>
              </div>
            </div>
          </div>
          <div class="alert alert-warning text-center" style="padding: 20px; border-radius: 10px; border-left: 4px solid #ffc107; background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);">
            <i class="fa fa-exclamation-triangle" style="font-size: 24px; color: #856404; margin-bottom: 10px;"></i>
            <h5 style="color: #856404;">No Rejection Reasons Found</h5>
            <p style="color: #856404; margin-bottom: 0;">Please contact administrator to set up rejection reasons.</p>
          </div>
        `;
        return;
      }

      let html = `
        ${draftIndicator}
        
        <!-- Quantity Info Bar -->
        <div class="iqf-qty-info-bar">
          <div class="iqf-qty-item rw">
            <i class="fa fa-box"></i>
            <div>
              <div class="iqf-qty-label">RW Qty</div>
              <div class="iqf-qty-value" id="modalLotQty">${displayLotQty}</div>
            </div>
          </div>
          <div class="iqf-qty-item missing">
            <i class="fa fa-exclamation-triangle"></i>
            <div>
              <div class="iqf-qty-label">Missing Qty</div>
              <div class="iqf-qty-value" id="modalMissingQty">${displayMissingQty}</div>
            </div>
          </div>
          <div class="iqf-qty-item physical">
            <i class="fa fa-check-circle"></i>
            <div>
              <div class="iqf-qty-label">Physical Qty</div>
              <div class="iqf-qty-value" id="modalPhysicalQty">${displayPhysicalQty}</div>
            </div>
          </div>
        </div>
      `;

      // Add brass rejection comment if exists (display after quantity info bar)
      if (lotRejectedComment) {
        html += `
          <div style="margin: 18px 0; padding: 18px 20px; background: linear-gradient(135deg, #fffbf0 0%, #fff9e6 100%); border: 2px solid #ffd54f; border-radius: 12px; color: #ad6800; font-size: 15px; box-shadow: 0 4px 12px rgba(255,193,7,0.15);">
            <div style="display: flex; align-items: flex-start; gap: 12px;">
              <i class="fa fa-exclamation-triangle" style="color: #ff9800; font-size: 22px; margin-top: 2px; animation: pulse 2s infinite;"></i>
              <div style="flex: 1;">
                <strong style="color: #e65100; font-size: 16px; display: block; margin-bottom: 8px; font-weight: 700;">
                  <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                  Lot Rejection Comment (BrassQC Module)
                </strong>
                <div style="padding: 12px 16px; background: #ffffff; border-left: 4px solid #ff9800; border-radius: 6px; color: #bf360c; font-weight: 600; line-height: 1.5; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);">
                  ${lotRejectedComment}
                </div>
              </div>
            </div>
          </div>
          <style>
            @keyframes pulse {
              0%, 100% { opacity: 1; transform: scale(1); }
              50% { opacity: 0.8; transform: scale(1.1); }
            }
          </style>
        `;
      }

      html += `
        <!-- Section Header with Lot Rejection Toggle -->
        <div class="iqf-section-header">
          <h4 class="iqf-section-title">
            <i class="fa fa-list-alt"></i>
            Rejection Reason List
          </h4>
          
          <div class="iqf-lot-rejection-toggle">
            <input type="checkbox" id="batchRejection" ${hasLotRejectionDraft ? 'checked' : ''} />
            <label for="batchRejection">Lot Rejection</label>
          </div>
        </div>
      `;

      // Remove duplicate brass rejection comment section below
      if (false && allBrassZero && lotRejectedComment) {
        html += `
          <div style="margin: 18px 0; padding: 18px 20px; background: linear-gradient(135deg, #fffbf0 0%, #fff9e6 100%); border: 2px solid #ffd54f; border-radius: 12px; color: #ad6800; font-size: 15px; box-shadow: 0 4px 12px rgba(255,193,7,0.15);">
            <div style="display: flex; align-items: flex-start; gap: 12px;">
              <i class="fa fa-exclamation-triangle" style="color: #ff9800; font-size: 22px; margin-top: 2px; animation: pulse 2s infinite;"></i>
              <div style="flex: 1;">
                <strong style="color: #e65100; font-size: 16px; display: block; margin-bottom: 8px; font-weight: 700;">
                  <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                  Lot Rejection Comment (BrassQC Module)
                </strong>
                <div style="padding: 12px 16px; background: #ffffff; border-left: 4px solid #ff9800; border-radius: 6px; color: #bf360c; font-weight: 600; line-height: 1.5; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);">
                  ${lotRejectedComment}
                </div>
              </div>
            </div>
          </div>
          <style>
            @keyframes pulse {
              0%, 100% { opacity: 1; transform: scale(1); }
              50% { opacity: 0.8; transform: scale(1.1); }
            }
          </style>
        `;
      }

      html += `
        <!-- ✅ ENHANCED: Premium table design with superior styling -->

    <div id="rejection-reasons-section" class="table-responsive"
         style="max-height: 280px; min-width: 100% !important; overflow-y: auto; border: 2px solid #dee2e6; border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.12); background: #fff;">
           <table class="table table-bordered text-center mb-0" style="width: 100%; font-size: 14px; border-collapse: separate; border-spacing: 0;">
            <thead style="background: linear-gradient(135deg, #028084 0%, #026066 100%); position: sticky; top: 0; z-index: 10;">
              <tr>
                <th style="background-color: #028084 !important; padding: 16px 12px; font-size: 14px; font-weight: 700; border: 1px solid #026066; width: 8%; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                  <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                    <i class="fa fa-hashtag" style="font-size: 12px;"></i>
                    S.No
                  </div>
                </th>
                <th style="background-color: #028084 !important; padding: 16px 12px; font-size: 14px; font-weight: 700; border: 1px solid #026066; border-left: 1px solid rgba(255,255,255,0.2); width: 12%; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                  <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                    <i class="fa fa-barcode" style="font-size: 12px;"></i>
                    ID
                  </div>
                </th>
                <th style="background-color: #028084 !important; padding: 16px 16px; font-size: 14px; font-weight: 700; border: 1px solid #026066; border-left: 1px solid rgba(255,255,255,0.2); color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.3); width: 50%;">
                  <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <i class="fa fa-exclamation-circle" style="font-size: 12px;"></i>
                    Rejection Reason
                  </div>
                </th>
                <th style="background-color: #028084 !important; padding: 16px 12px; font-size: 14px; font-weight: 700; border: 1px solid #026066; border-left: 1px solid rgba(255,255,255,0.2); width: 15%; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                  <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                    <i class="fa fa-industry" style="font-size: 12px;"></i>
                    Brass Qty
                  </div>
                </th>
                <th style="background-color: #028084 !important; padding: 16px 12px; font-size: 14px; font-weight: 700; border: 1px solid #026066; border-left: 1px solid rgba(255,255,255,0.2); width: 15%; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                  <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                    <i class="fa fa-check-square" style="font-size: 12px;"></i>
                    IQF Qty
                  </div>
                </th>
              </tr>
            </thead>
            <tbody id="rejection-table-body" style="background: #fff;">
      `;

      rejectionReasons.forEach((reason, index) => {
        const brassQty = brassRejectionQtyMap[reason.rejection_reason] || 0;
        const shouldEnableInput = brassQty > 0 || (allBrassZero && lotRejectedComment);
        
        html += `
           <tr data-batch-id="${batchId}" data-stock-lot-id="${stockLotId}" style="border-bottom: 1px solid #f8f9fa; transition: all 0.2s ease; background: ${index % 2 === 0 ? '#ffffff' : '#f8fafb'};">
             <td style="padding: 12px 8px; font-size: 14px; font-weight: 700; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); color: #495057; border-right: 1px solid #e9ecef; text-align: center;">${index + 1}</td>
             <td style="padding: 10px 8px; font-size: 13px; font-weight: 700; border-right: 1px solid #e9ecef; background: ${index % 2 === 0 ? '#fafbfc' : '#f0f4f8'}; color: #6c757d; text-align: center;">${reason.rejection_reason_id}</td>
            <td style="padding: 10px 12px; font-size: 13px; text-align: left; font-weight: 600; border-right: 1px solid #e9ecef; color: #2c3e50; word-wrap: break-word; overflow-wrap: break-word;">
              ${reason.rejection_reason}
            </td> 
            <td style="padding: 8px 4px; border-right: 1px solid #e9ecef; background: ${index % 2 === 0 ? '#fafbfc' : '#f0f4f8'}; text-align: center;">
              <input 
                type="number" 
                value="${brassQty}" 
                readonly 
                style="width: 65px; height: 32px; padding: 0 8px; font-size: 13px; text-align: center; background: #fff; color: ${brassQty > 0 ? '#c62828' : '#6c757d'}; font-weight: ${brassQty > 0 ? 'bold' : 'normal'}; border: 2px solid ${brassQty > 0 ? '#ef9a9a' : '#e0e0e0'}; border-radius: 6px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);"
              />
            </td>
             <td style="padding: 8px 4px; border-right: 1px solid #e9ecef; background: ${index % 2 === 0 ? '#fafbfc' : '#f0f4f8'}; text-align: center;">
              <input
                type="number"
                min="0"
                max="${brassQty > 0 ? brassQty : ''}"
                value="0"
                class="form-control rejection-qty-input"
                name="quantity_${index + 1}"
                style="width: 100%; max-width: 70px; height: 32px; padding: 4px 8px; font-size: 13px; text-align: center; border: 2px solid #028084; border-radius: 6px; font-weight: 700; transition: all 0.3s ease; background-color: #fff; color: #028084; box-shadow: inset 0 1px 3px rgba(0,0,0,0.08);"
                data-reason-id="${reason.rejection_reason_id}"
                data-brass-qty="${brassQty}"
                data-has-lot-comment="${allBrassZero && lotRejectedComment ? 'true' : 'false'}"
              />
             </td>
           </tr>
        `;
      });

      html += `
              <!-- ✅ ENHANCED: Premium total rows with improved styling -->
              <tr style="background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%); border-top: 3px solid #ff9800; position: sticky; bottom: 0;">
                <td colspan="3" style="text-align: center; font-weight: 700; padding: 14px 12px; font-size: 15px; color: #2c3e50; border-right: 1px solid #dee2e6;">
                  <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <i class="fa fa-calculator" style="color: #ff9800; font-size: 18px;"></i>
                    <span style="font-size: 16px; font-weight: 700;">Total</span>
                  </div>
                </td>
                <td id="brass-rejection-total-qty" style="font-weight: 700; padding: 14px 12px; font-size: 16px; color: #e65100; background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); text-align: center; border-radius: 6px; border-right: 1px solid #dee2e6;">0</td>
                <td id="rejection-total-qty" style="font-weight: 700; padding: 14px 12px; font-size: 16px; color: #1b5e20; background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); text-align: center; border-radius: 6px;">0</td>
              </tr>
              </tbody>
            </table>
          </div>

          <!-- ✅ ENHANCED: Premium Accepted Tray Table Container -->
          <div id="accepted-tray-table-container" class="table-responsive"
               style="margin-top: 12px; display: none; border: 1px solid #dee2e6; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.06); background: #fff; overflow: hidden; scrollbar-width: thin; scrollbar-color: #fff #fff;">
            <div style="background: linear-gradient(135deg, #28a745 0%, #20a741 100%); padding: 6px 12px; border-bottom: 1px solid #1e7e34;">
              <h5 style="color: #fff; margin: 0; font-weight: 500; font-size: 14px; text-shadow: 0 1px 3px rgba(0,0,0,0.2); display: flex; align-items: center; gap: 5px;">
                Accepted Tray Table - Qty: <span id="accepted-qty-display" style="color: #d4edda; font-weight: 600;">0</span>
              </h5>
            </div>
            <table class="table table-bordered text-center mb-0" style="font-size: 13px;">
              <thead style="background: linear-gradient(135deg, #34ce57 0%, #28a745 100%);">
                <tr>
                  <th style="padding: 12px; font-weight: 700; color: black; border: 1px solid #1e7e34;">S.No</th>
                  <th style="padding: 12px; font-weight: 700; color: black; border: 1px solid #1e7e34;">Tray ID</th>
                  <th style="padding: 12px; font-weight: 700; color: black; border: 1px solid #1e7e34;">Tray Qty</th>
                </tr>
              </thead>
              <tbody id="accepted-tray-table-body" style="background: #fff;"></tbody>
            </table>
          </div>

          <!-- ✅ ENHANCED: Premium Acceptance Remarks Section -->
          <div id="acceptanceRemarksSection" style="display: none; margin-top: 20px; padding: 20px; border: 2px solid #28a745; border-radius: 12px; background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%); box-shadow: 0 4px 12px rgba(40, 167, 69, 0.15);">
            <div style="margin-bottom: 15px;">
              <label style="font-weight: 700; color: #28a745; margin-bottom: 8px; display: block; font-size: 15px; display: flex; align-items: center; gap: 8px;">
                <i class="fa fa-check-circle" style="font-size: 18px;"></i>
                Acceptance Remarks (Required)
              </label>
              <textarea 
                id="acceptanceRemarksInput" 
                placeholder="Please provide reason for accepting these trays..." 
                style="width: 100%; height: 85px; padding: 15px 18px; border: 2px solid #28a745; border-radius: 10px; font-size: 14px; resize: vertical; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #fff; transition: all 0.3s ease; box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);"
                maxlength="500"></textarea>
              <div style="text-align: right; margin-top: 6px; font-size: 12px; color: #6c757d;">
                <span id="acceptanceRemarksCharCount">0</span>/500 characters
              </div>
            </div>
            <div style="font-size: 13px; color: #155724; background-color: #d4edda; padding: 12px 16px; border-radius: 8px; border-left: 4px solid #28a745; display: flex; align-items: center; gap: 10px;">
              <i class="fa fa-info-circle" style="font-size: 16px; color: #28a745;"></i>
              <span><strong>Note:</strong> Acceptance remarks are required before filling tray IDs.</span>
            </div>
          </div>

          <!-- ✅ ENHANCED: Premium Lot Rejection Remarks Section with GREEN border -->
          <div id="lotRejectionRemarksSection" style="display: ${hasLotRejectionDraft ? 'block' : 'none'}; margin-top: 20px; padding: 20px; border: 2px solid #28a745; border-radius: 12px; background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%); box-shadow: 0 4px 12px rgba(40, 167, 69, 0.15);">
            <div style="margin-bottom: 15px;">
              <label style="font-weight: 700; color: #28a745; margin-bottom: 8px; display: block; font-size: 15px; display: flex; align-items: center; gap: 8px;">
                <i class="fa fa-check-circle" style="font-size: 18px;"></i>
                Lot Rejection Remarks (Required)
              </label>
              <textarea 
                id="lotRejectionRemarksInput" 
                placeholder="Please provide detailed reason for lot rejection..." 
                style="width: 100%; height: 85px; padding: 15px 18px; border: 2px solid #28a745; border-radius: 10px; font-size: 14px; resize: vertical; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #fff; transition: all 0.3s ease; box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);"
                maxlength="500"></textarea>
              <div style="text-align: right; margin-top: 6px; font-size: 12px; color: #6c757d;">
                <span id="lotRemarksCharCount">0</span>/500 characters
              </div>
            </div>
            <div style="font-size: 13px; color: #155724; background-color: #d4edda; padding: 12px 16px; border-radius: 8px; border-left: 4px solid #28a745; display: flex; align-items: center; gap: 10px;">
              <i class="fa fa-check-circle" style="font-size: 16px; color: #28a745;"></i>
              <span><strong>Note:</strong> Lot rejection remarks are mandatory when rejecting the entire lot.</span>
            </div>
          </div>

          <div id="batchRejectionMsg" style="margin: 15px 0; color: #d32f2f; font-weight: 600; font-size: 14px; text-align: center; min-height: 24px; padding: 8px; border-radius: 6px;"></div>
          
          </div>
          <!-- ✅ END SCROLLABLE CONTENT AREA -->
          
        </div>
        <!-- ✅ END MAIN CONTAINER -->
      `;

      modalBodyContent.innerHTML = html;
      document.getElementById('iqfModalFooter').style.display = 'flex';

      // Calculate brass total automatically
      let totalBrassQty = 0;
      rejectionReasons.forEach((reason) => {
        totalBrassQty += brassRejectionQtyMap[reason.rejection_reason] || 0;
      });
      const brassTotalElement = document.getElementById('brass-rejection-total-qty');
      if (brassTotalElement) brassTotalElement.textContent = totalBrassQty;

      // ✅ Add character count functionality for remarks
      const acceptanceRemarksInput = document.getElementById('acceptanceRemarksInput');
      const acceptanceCharCount = document.getElementById('acceptanceRemarksCharCount');
      const lotRemarksInput = document.getElementById('lotRejectionRemarksInput');
      const lotCharCount = document.getElementById('lotRemarksCharCount');

      if (acceptanceRemarksInput && acceptanceCharCount) {
        acceptanceRemarksInput.addEventListener('input', function() {
          acceptanceCharCount.textContent = this.value.length;
        });
      }

      if (lotRemarksInput && lotCharCount) {
        lotRemarksInput.addEventListener('input', function() {
          lotCharCount.textContent = this.value.length;
        });
      }

      // ✅ Enhanced button hover effects with scale and shadow animations
      const draftBtn = document.getElementById('draftButton');
      const proceedBtn = document.getElementById('proceedButton');
      const cancelBtn = document.getElementById('cancelButton');
      
      [draftBtn, proceedBtn, cancelBtn].forEach(button => {
        if (!button) return;
        
        button.addEventListener('mouseenter', function() {
          this.style.transform = 'translateY(-2px)';
        });
        
        button.addEventListener('mouseleave', function() {
          this.style.transform = 'translateY(0)';
        });
        
        button.addEventListener('mousedown', function() {
          this.style.transform = 'translateY(0) scale(0.98)';
        });
        
        button.addEventListener('mouseup', function() {
          this.style.transform = 'translateY(-2px)';
        });
      });

      // ✅ Cancel button closes modal
      if (cancelBtn) {
        cancelBtn.addEventListener('click', function() {
          modalOverlay.classList.remove('active');
        });
      }

      // ✅ FIXED: Add Lot Rejection checkbox behavior
      const batchRejectionCheckbox = document.getElementById('batchRejection');
      const rejectionReasonsSection = document.getElementById('rejection-reasons-section');
      const lotRejectionRemarksSection = document.getElementById('lotRejectionRemarksSection');
      
      if (batchRejectionCheckbox) {
        batchRejectionCheckbox.addEventListener('change', function() {
          if (this.checked) {
            // When Lot Rejection is checked: Hide rejection reasons table, show only remarks section
            rejectionReasonsSection.style.display = 'none';
            lotRejectionRemarksSection.style.display = 'block';
            
            // Clear all rejection reason quantities when switching to lot rejection
            const qtyInputs = document.querySelectorAll('.rejection-qty-input');
            qtyInputs.forEach(input => {
              input.value = '';
            });
            
            // Update total quantities to 0
            const totalQtyElement = document.getElementById('rejection-total-qty');
            const brassTotalElement = document.getElementById('brass-rejection-total-qty');
            if (totalQtyElement) totalQtyElement.textContent = '0';
            if (brassTotalElement) brassTotalElement.textContent = '0';
          } else {
            // When Lot Rejection is unchecked: Show rejection reasons table, hide remarks section
            rejectionReasonsSection.style.display = 'block';
            lotRejectionRemarksSection.style.display = 'none';
            
            // Clear lot rejection remarks when switching back
            const lotRemarksInput = document.getElementById('lotRejectionRemarksInput');
            if (lotRemarksInput) {
              lotRemarksInput.value = '';
            }
            
            // Recalculate brass total
            let totalBrassQty = 0;
            rejectionReasons.forEach((reason) => {
              totalBrassQty += brassRejectionQtyMap[reason.rejection_reason] || 0;
            });
            const brassTotalElement = document.getElementById('brass-rejection-total-qty');
            if (brassTotalElement) brassTotalElement.textContent = totalBrassQty;
          }
        });
      }

      // ✅ CRITICAL: Load draft data AFTER table is fully populated
      console.log('🔧 [DRAFT-TIMING] Table fully built, now setting up event listeners and loading drafts');
      
      setupEnhancedFormEventListeners(batchId, stockLotId, hasLotRejectionDraft, hasTrayRejectionDraft, allBrassZero, lotRejectedComment);
      
      // ✅ FIXED: Load draft data AFTER rejection table is fully populated
      if (stockLotId && typeof loadDraftData === 'function') {
        console.log('🔧 [DRAFT-TIMING] Loading draft data for lot:', stockLotId);
        // Small delay to ensure DOM is fully rendered
        setTimeout(() => {
          loadDraftData(stockLotId);
        }, 100);
      }
    })
    .catch(error => {
      console.error('Error in buildRejectionFormHTML:', error);
      detailsDiv.innerHTML = `
        <div class="alert alert-danger text-center" style="padding: 20px; border-radius: 12px; border-left: 4px solid #dc3545; background: linear-gradient(135deg, #fff5f5 0%, #ffe6e6 100%); box-shadow: 0 4px 12px rgba(220,53,69,0.1);">
          <i class="fa fa-exclamation-triangle" style="font-size: 24px; color: #dc3545; margin-bottom: 10px;"></i>
          <h5 style="color: #721c24; margin-bottom: 8px;">Error Loading Data</h5>
          <p style="color: #856404; margin-bottom: 15px;">${error.message || 'Could not load required data. Please try again.'}</p>
          <button onclick="location.reload()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 25px; font-weight: 600;">
            <i class="fa fa-refresh" style="margin-right: 6px;"></i>Retry
          </button>
        </div>
      `;
    });
}



function setupEnhancedFormEventListeners(batchId, stockLotId, hasLotRejectionDraft, hasTrayRejectionDraft, allBrassZero, lotRejectedComment) {
  const batchRejectionCheckbox = document.getElementById("batchRejection");
  const rejectionTableBody = document.getElementById("rejection-table-body");
  const lotRejectionRemarksSection = document.getElementById("lotRejectionRemarksSection");

  // ✅ CRITICAL: Initialize auto-save functionality
  console.log('🔧 [AUTO-SAVE] Initializing auto-save for IQF modal');
  if (stockLotId && typeof autoSaveManager !== 'undefined') {
    // Setup auto-save listeners for all inputs
    autoSaveManager.setupAutoSaveListeners(stockLotId, batchId);
    console.log('✅ [AUTO-SAVE] Auto-save setup complete for lot:', stockLotId);
    
    // ✅ NOTE: loadDraftData is now called AFTER table is fully populated in buildRejectionFormHTML
    console.log('ℹ️ [DRAFT-TIMING] Draft loading moved to after table population for better timing');
  } else {
    console.log('⚠️ [AUTO-SAVE] Cannot setup auto-save - missing lotId or autoSaveManager');
  }

  if (batchRejectionCheckbox && rejectionTableBody) {
    batchRejectionCheckbox.addEventListener("change", function () {
      const inputs = rejectionTableBody.querySelectorAll("input");

      if (this.checked) {
        if (lotRejectionRemarksSection) {
          lotRejectionRemarksSection.style.display = "block";
        }
        inputs.forEach(input => {
          input.disabled = true;
          input.value = "";
        });
        document.getElementById('rejection-total-qty').textContent = "0";
        hideAcceptedTrayTable();
      } else {
        if (lotRejectionRemarksSection) {
          lotRejectionRemarksSection.style.display = "none";
        }
        inputs.forEach(input => {
          input.disabled = false;
        });
      }
    });
  }

  // ✅ FIXED: Enhanced rejection quantity validation against Physical Qty
document.querySelectorAll('.rejection-qty-input').forEach(function(input, idx, allInputs) {
  input.addEventListener('input', async function() {
    const row = input.closest('tr');
    const brassInput = row.querySelector('input[readonly]');
    const brassQty = parseInt(brassInput.value) || 0;
    const hasLotComment = input.getAttribute('data-has-lot-comment') === 'true';
    let qty = parseInt(input.value) || 0;

    // ✅ Get Physical Qty from modal header
    const modalPhysicalQty = document.getElementById('modalPhysicalQty');
    const maxAllowedQty = modalPhysicalQty ? parseInt(modalPhysicalQty.textContent) || 0 : 0;

    console.log("Physical Qty from modal:", maxAllowedQty);

    if (brassQty === 0 && !hasLotComment) {
      input.value = '';
      input.disabled = true;
      input.style.backgroundColor = '#f5f5f5';
      return;
    } else {
      input.disabled = false;
      input.style.backgroundColor = '';
    }

    // ✅ Validate individual input against brass qty (if applicable)
    if (brassQty > 0 && qty > brassQty) {
      input.value = brassQty;
      qty = brassQty;
    }

    // ✅ Calculate total entered quantity across all inputs
    let totalEnteredQty = 0;
    let totalBrassQty = 0;
    
    allInputs.forEach(function(qtyInput) {
      totalEnteredQty += parseInt(qtyInput.value) || 0;
      const row = qtyInput.closest('tr');
      const brassInput = row.querySelector('input[readonly]');
      totalBrassQty += parseInt(brassInput.value) || 0;
    });

    // ✅ Validate total against Physical Qty
    if (totalEnteredQty > maxAllowedQty) {
      // Calculate how much to reduce from current input
      const excess = totalEnteredQty - maxAllowedQty;
      const newQty = Math.max(0, qty - excess);
      input.value = newQty;
      
      // Recalculate total after adjustment
      totalEnteredQty = 0;
      allInputs.forEach(function(qtyInput) {
        totalEnteredQty += parseInt(qtyInput.value) || 0;
      });

      // Show error message
      showQuantityError(input, `Total quantity cannot exceed Physical Qty (${maxAllowedQty})`);
    } else {
      // Clear any existing error
      clearQuantityError(input);
    }

    // Update totals display
    const totalQtyElement = document.getElementById('rejection-total-qty');
    const brassTotalElement = document.getElementById('brass-rejection-total-qty');
    if (totalQtyElement) totalQtyElement.textContent = totalEnteredQty;
    if (brassTotalElement) brassTotalElement.textContent = totalBrassQty;

    try {
      const capacityResult = await fetchTrayCapacityDynamic(stockLotId);
      
      if (!capacityResult.success) {
        showTrayCapacityError(capacityResult.error);
        return;
      }

      const trayCapacity = capacityResult.tray_capacity;
      
      // ✅ FIXED: Pass totalBrassQty but function will use Physical Qty internally
      await updateAcceptedTrayTable(totalBrassQty, totalEnteredQty, trayCapacity);
      
    } catch (error) {
      showTrayCapacityError(`Error fetching tray capacity: ${error.message}`);
    }
  });
});

  // Rest of the button event listeners remain the same...
  const draftButton = document.getElementById("draftButton");
  if (draftButton) {
    draftButton.addEventListener("click", () => {
      const batchRejectionCheckbox = document.getElementById("batchRejection");
      const msgDiv = document.getElementById("batchRejectionMsg");
      
      if (batchRejectionCheckbox && batchRejectionCheckbox.checked) {
        handleLotRejectionDraft(batchId, stockLotId, msgDiv, draftButton);
      } else {
        handleTrayWiseRejectionDraft(batchId, stockLotId, msgDiv, draftButton);
      }
    });
  }

// Updated Proceed button event listener with integrated delink functionality AND auto lot rejection
const proceedButton = document.getElementById("proceedButton");
if (proceedButton) {
  proceedButton.addEventListener("click", () => {
    if (proceedButton.disabled) return;
    proceedButton.disabled = true;
    
    const batchRejectionCheckbox = document.getElementById("batchRejection");
    const msgDiv = document.getElementById("batchRejectionMsg");
    if (msgDiv) msgDiv.textContent = "";

    // Get physical quantity and total IQF rejection quantity for auto-detection
    const modalPhysicalQty = document.getElementById('modalPhysicalQty');
    const physicalQty = modalPhysicalQty ? parseInt(modalPhysicalQty.textContent) || 0 : 0;
    const totalQtyElement = document.getElementById('rejection-total-qty');
    const totalEnteredQty = totalQtyElement ? parseInt(totalQtyElement.textContent) || 0 : 0;
    const isFullLotRejection = (physicalQty > 0 && totalEnteredQty === physicalQty);

    if (batchRejectionCheckbox && batchRejectionCheckbox.checked) {
      // ✅ ENHANCED: Lot Rejection with Delink Integration
      const lotRejectionRemarksInput = document.getElementById('lotRejectionRemarksInput');
      const lotRejectionRemarks = lotRejectionRemarksInput ? lotRejectionRemarksInput.value.trim() : '';
      
      if (!lotRejectionRemarks) {
        if (msgDiv) {
          msgDiv.style.color = "#d32f2f";
          msgDiv.textContent = 'Lot rejection remarks are required for Lot Rejection.';
        }
        proceedButton.disabled = false;
        return;
      }

      const batchId = trayModal.dataset.batchId;
      const lotId = trayModal.dataset.stockLotId;
      const totalQty = document.getElementById('rejection-total-qty').textContent || "0";
      
      if (!batchId || !lotId) {
        if (msgDiv) {
          msgDiv.style.color = "#d32f2f";
          msgDiv.textContent = "Batch ID or Lot ID not found.";
        }
        proceedButton.disabled = false;
        return;
      }

      // ✅ NEW: Check for missing quantity in batch rejection
      const currentRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
      const missingQtyInput = currentRow ? currentRow.querySelector('.missing-qty-input') : null;
      const missingQty = missingQtyInput ? parseInt(missingQtyInput.value) || 0 : 0;

      console.log(`🔍 [Batch Rejection] Checking missing qty: ${missingQty} for lot: ${lotId}`);

      if (missingQty > 0) {
        // ✅ Show delink modal for batch rejection
        console.log('🔗 Showing delink modal for batch rejection with missing qty:', missingQty);
        
        // Close the current rejection modal
        const trayModal = document.getElementById("trayScanModal");
        if (trayModal) {
          trayModal.classList.remove("open");
          trayModal.style.display = "none";
        }
        
        // Show delink modal with batch rejection context
        showBatchRejectionDelinkModal(lotId, batchId, missingQty, lotRejectionRemarks, totalQty);
        
      } else {
        // ✅ No missing quantity - proceed with normal batch rejection
        console.log('✅ No missing quantity - proceeding with normal batch rejection');
        performBatchRejection(batchId, lotId, totalQty, lotRejectionRemarks);
      }
      
    } else if (isFullLotRejection) {
      // ✅ NEW: Auto-detected Full Lot Rejection (100% of physical qty rejected)
      console.log(`🎯 Auto Lot Rejection detected: IQF qty (${totalEnteredQty}) = Physical qty (${physicalQty})`);
      
      const batchId = trayModal.dataset.batchId;
      const lotId = trayModal.dataset.stockLotId;
      
      if (!batchId || !lotId) {
        if (msgDiv) {
          msgDiv.style.color = "#d32f2f";
          msgDiv.textContent = "Batch ID or Lot ID not found.";
        }
        proceedButton.disabled = false;
        return;
      }

      // Use default remark for full quantity rejection
      const lotRejectionRemarks = 'Full lot rejected';
      const totalQty = totalEnteredQty.toString();

      // Check for missing quantity in auto lot rejection
      const currentRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
      const missingQtyInput = currentRow ? currentRow.querySelector('.missing-qty-input') : null;
      const missingQty = missingQtyInput ? parseInt(missingQtyInput.value) || 0 : 0;

      console.log(`🔍 [Auto Lot Rejection] Checking missing qty: ${missingQty} for lot: ${lotId}`);

      if (missingQty > 0) {
        // Show delink modal for auto lot rejection
        console.log('🔗 Showing delink modal for auto lot rejection with missing qty:', missingQty);
        
        // Close the current rejection modal
        const trayModal = document.getElementById("trayScanModal");
        if (trayModal) {
          trayModal.classList.remove("open");
          trayModal.style.display = "none";
        }
        
        // Show delink modal with auto lot rejection context
        showBatchRejectionDelinkModal(lotId, batchId, missingQty, lotRejectionRemarks, totalQty);
        
      } else {
        // No missing quantity - proceed with normal lot rejection
        console.log('✅ No missing quantity - proceeding with auto lot rejection');
        handleLotRejection(batchId, lotId, msgDiv, proceedButton);
      }
      
    } else {
      // Tray-wise rejection logic (unchanged)
      handleTrayWiseRejectionWithAcceptance(batchId, stockLotId, msgDiv, proceedButton);
    }
  });
}

// ✅ NEW: Function to show delink modal specifically for batch rejection
function showBatchRejectionDelinkModal(lotId, batchId, missingQty, lotRejectionRemarks, totalQty) {
  console.log('🔗 Showing batch rejection delink modal for lot:', lotId, 'missing qty:', missingQty);
  
  const modal = document.getElementById('delinkModal');
  if (!modal) {
    console.error('❌ Delink modal not found!');
    // Fallback to normal batch rejection
    performBatchRejection(batchId, lotId, totalQty, lotRejectionRemarks);
    return;
  }
  
  const missingQtySpan = document.getElementById('delinkMissingQty');
  const loadingDiv = document.getElementById('delinkLoadingDiv');
  const contentDiv = document.getElementById('delinkContentDiv');
  const errorDiv = document.getElementById('delinkErrorDiv');
  const confirmBtn = document.getElementById('confirmDelinkBtn');
  
  // Reset modal state
  if (missingQtySpan) missingQtySpan.textContent = missingQty;
  if (loadingDiv) loadingDiv.style.display = 'block';
  if (contentDiv) contentDiv.style.display = 'none';
  if (errorDiv) errorDiv.style.display = 'none';
  if (confirmBtn) {
    confirmBtn.style.display = 'none';
    confirmBtn.disabled = true;
  }
  
  // Update modal title for batch rejection context - compact version
  const modalTitle = modal.querySelector('h2');
  if (modalTitle) {
    modalTitle.innerHTML = `
      <span style="font-size: 16px; font-weight: 600;">Set Top Tray</span>
    `;
    modalTitle.style.margin = '0 0 12px 0';
    modalTitle.style.padding = '8px 0';
  }
  
  // Show modal
  modal.style.display = 'block';
  console.log('👁️ Batch rejection delink modal should be visible now');
  
  // ✅ CRITICAL: Store batch rejection context and override existing handlers
  modal.dataset.lotId = lotId;
  modal.dataset.batchId = batchId;
  modal.dataset.missingQty = missingQty;
  modal.dataset.lotRejectionRemarks = lotRejectionRemarks;
  modal.dataset.totalQty = totalQty;
  modal.dataset.isBatchRejection = 'true'; // Flag to indicate this is batch rejection
  
  // ✅ OVERRIDE: Replace confirm button with batch rejection specific handler
  if (confirmBtn) {
    // Clone button to remove all existing event listeners
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    
    // Add batch rejection specific handler
    newConfirmBtn.addEventListener('click', function() {
      console.log('✅ BATCH REJECTION: Confirm button clicked');
      
      // Collect tray IDs
      const delinkTrayInputs = document.querySelectorAll('.delink-tray-input');
      const topTrayInput = document.getElementById('topTrayIdInput');
      
      const delinkTrayIds = Array.from(delinkTrayInputs).map(input => input.value.trim()).filter(id => id);
      const topTrayId = topTrayInput ? topTrayInput.value.trim() : '';
      const topTrayQtyElement = document.querySelector('#topTrayTableBody td:last-child');
      const topTrayQty = topTrayQtyElement ? topTrayQtyElement.textContent.trim() : '';
      
      console.log('📦 BATCH REJECTION: Collected data:', { 
        lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty 
      });
      
      // Close modal
      modal.style.display = 'none';
      
      // Show batch rejection confirmation with custom button text
      if (typeof Swal !== 'undefined') {
        Swal.fire({
          title: 'Confirm Batch Rejection',
          text: `This will REJECT the entire batch. Are you sure?`,
          icon: 'warning',
          showCancelButton: true,
          confirmButtonColor: '#dc3545',
          cancelButtonColor: '#6c757d',
          confirmButtonText: 'Yes, Reject',
          cancelButtonText: 'Cancel',
          reverseButtons: true
        }).then((result) => {
          if (result.isConfirmed) {
            console.log('🚀 BATCH REJECTION: User confirmed, calling performBatchRejectionWithDelink');
            performBatchRejectionWithDelink(lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty);
          }
        });
      } else {
        if (confirm('Confirm Batch Rejection\n\nThis will delink ' + missingQty + ' pieces and REJECT the entire batch. Are you sure?')) {
          console.log('🚀 BATCH REJECTION: User confirmed, calling performBatchRejectionWithDelink');
          performBatchRejectionWithDelink(lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty);
        }
      }
    });
  }
  
  // Fetch delink calculation
  fetchDelinkCalculationForBatchRejection(lotId, missingQty);
}

// ✅ NEW: Fetch delink calculation specifically for batch rejection
function fetchDelinkCalculationForBatchRejection(lotId, missingQty) {
  console.log('📡 Fetching delink calculation for batch rejection - lot:', lotId, 'missing qty:', missingQty);
  
  const loadingDiv = document.getElementById('delinkLoadingDiv');
  const contentDiv = document.getElementById('delinkContentDiv');
  const errorDiv = document.getElementById('delinkErrorDiv');
  const confirmBtn = document.getElementById('confirmDelinkBtn');
  
  const apiUrl = `/iqf/iqf_tray_delink_top_tray_calc/?lot_id=${encodeURIComponent(lotId)}&missing_qty=${missingQty}`;
  console.log('🌐 API URL:', apiUrl);
  
  fetch(apiUrl)
    .then(response => {
      console.log('📥 API Response status:', response.status);
      return response.json();
    })
    .then(data => {
      console.log('📊 API Response data:', data);
      
      if (loadingDiv) loadingDiv.style.display = 'none';
      
      if (data.success) {
        populateDelinkTablesForBatchRejection(data);
        if (contentDiv) contentDiv.style.display = 'block';
        if (confirmBtn) {
          confirmBtn.style.display = 'inline-block';
          // Update button text for batch rejection
          confirmBtn.innerHTML = `
            <i class="fa fa-check" style="margin-right: 6px;"></i>
            Submit
          `;
        }
      } else {
        showDelinkError(data.error || 'Failed to calculate delink requirements for batch rejection');
      }
    })
    .catch(error => {
      console.error('❌ API Error:', error);
      if (loadingDiv) loadingDiv.style.display = 'none';
      showDelinkError('Network error while calculating delink requirements for batch rejection.');
    });
}

// ✅ NEW: Populate delink tables for batch rejection (compact version)
function populateDelinkTablesForBatchRejection(data) {
  console.log('📋 Populating compact delink tables for batch rejection with data:', data);
  
  const delinkTraysSection = document.getElementById('delinkTraysSection');
  const topTraySection = document.getElementById('topTraySection');
  const delinkTableBody = document.getElementById('delinkTableBody');
  const topTrayTableBody = document.getElementById('topTrayTableBody');
  const delinkCountSpan = document.getElementById('delinkCount');
  
  // Clear existing content
  if (delinkTableBody) delinkTableBody.innerHTML = '';
  if (topTrayTableBody) topTrayTableBody.innerHTML = '';
  
      // Delink Trays Section - Compact
    if (data.delink_trays && data.delink_trays.length > 0) {
        if (delinkCountSpan) delinkCountSpan.textContent = data.delink_count || data.delink_trays.length;
        data.delink_trays.forEach((_, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td style="font-weight: 600; background: #ffebee; padding: 4px; font-size: 12px; width: 40px;">${index + 1}</td>
                <td style="padding: 4px;">
                    <input type="text" class="form-control delink-tray-input" value="" maxlength="9" placeholder="Scan Tray ID (max 9 chars)" autocomplete="off" style="width: 100%; padding: 6px; font-size: 12px; height: 28px;" />
                    <div class="tray-id-error" style="display: none; font-size: 10px; margin-top: 2px;"></div>
                </td>
            `;
            if (delinkTableBody) delinkTableBody.appendChild(row);
        });
        if (delinkTraysSection) delinkTraysSection.style.display = 'block';
    } else {
        if (delinkTraysSection) delinkTraysSection.style.display = 'none';
    }

    // Compact Top Tray Section
    if (data.top_tray) {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td style="padding: 4px;">
                <input type="text" id="topTrayIdInput" class="form-control" value="" maxlength="9" placeholder="Scan Top Tray ID (max 9 chars)" autocomplete="off" style="width: 100%; padding: 6px; font-size: 12px; height: 28px;" />
                <div class="tray-id-error" style="display: none; font-size: 10px; margin-top: 2px;"></div>
            </td>
            <td style="font-weight: 600; color: #2e7d32; padding: 4px; font-size: 12px; text-align: center; width: 60px;">${data.top_tray.qty}</td>
        `;
        if (topTrayTableBody) topTrayTableBody.appendChild(row);
        if (topTraySection) topTraySection.style.display = 'block';
    } else {
        if (topTraySection) topTraySection.style.display = 'none';
    }

  // Make tables more compact
  const tables = document.querySelectorAll('#delinkTraysSection table, #topTraySection table');
  tables.forEach(table => {
    table.style.margin = '8px 0';
    table.style.fontSize = '12px';
    // Make table headers more compact
    const headers = table.querySelectorAll('th');
    headers.forEach(th => {
      th.style.padding = '6px 8px';
      th.style.fontSize = '11px';
    });
  });

  // Attach validation to inputs
  setTimeout(() => {
    attachValidationToInputsForBatchRejection();
  }, 100);
}


// FIXED: Attach validation AFTER modal content is loaded
function attachValidationToInputsForBatchRejection() {
  console.log('[VALIDATION] Waiting for modal inputs to load...');
  
  // Wait for inputs to be available
  const waitForInputs = () => {
    const inputs = document.querySelectorAll('.delink-tray-input, #topTrayIdInput');
    
    if (inputs.length === 0) {
      console.log('[VALIDATION] No inputs found, retrying in 100ms...');
      setTimeout(waitForInputs, 100);
      return;
    }
    
    console.log(`[VALIDATION] Found ${inputs.length} inputs, setting up validation`);
    setupValidation(inputs);
  };
  
  const setupValidation = (inputs) => {
    const inputArray = Array.from(inputs);
    
    inputs.forEach((input, index) => {
      console.log(`[SETUP] Configuring input ${index}:`, input);
      
      // Remove any existing listeners
      const newInput = input.cloneNode(true);
      input.parentNode.replaceChild(newInput, input);
      inputArray[index] = newInput;
      
      // Get error div
      let errorDiv = newInput.parentElement.querySelector('.tray-id-error');
      if (!errorDiv) {
        errorDiv = document.createElement('div');
        errorDiv.className = 'tray-id-error';
        errorDiv.style.cssText = 'display: none; font-size: 10px; margin-top: 2px; color: #dc3545; font-weight: bold;';
        newInput.parentElement.appendChild(errorDiv);
      }
      
      // Navigation helper
      const moveToNextInput = () => {
        const currentIndex = inputArray.indexOf(newInput);
        const nextInput = inputArray[currentIndex + 1];
        
        if (nextInput) {
          console.log(`[MOVE] Moving from input ${currentIndex} to ${currentIndex + 1}`);
          setTimeout(() => {
            nextInput.focus();
            nextInput.select();
          }, 100);
        } else {
          console.log('[MOVE] Last input reached, focusing submit button');
          const submitBtn = document.getElementById('confirmDelinkBtn');
          if (submitBtn) {
            setTimeout(() => submitBtn.focus(), 100);
          }
        }
      };
      
      // Duplicate check function
      const checkForDuplicates = (trayId) => {
        let duplicateFound = false;
        inputArray.forEach((otherInput, otherIndex) => {
          if (otherIndex !== index && otherInput.value.trim() === trayId) {
            duplicateFound = true;
          }
        });
        return duplicateFound;
      };
      
      // Validation function
      const validateInput = (moveOnSuccess = false) => {
        const trayId = newInput.value.trim();
        console.log(`[VALIDATE] Input ${index}: "${trayId}"`);
        
        // Clear previous states
        newInput._hasError = false;
        newInput.style.border = '';
        newInput.style.backgroundColor = '';
        errorDiv.style.display = 'none';
        
        if (!trayId) {
          if (moveOnSuccess) moveToNextInput();
          return;
        }
        
        // CHECK FOR DUPLICATES FIRST
        if (checkForDuplicates(trayId)) {
          console.log(`[DUPLICATE] Found duplicate tray ID: ${trayId}`);
          newInput._hasError = true;
          newInput.style.border = '2px solid #dc3545';
          newInput.style.backgroundColor = '#ffebee';
          errorDiv.textContent = `Duplicate Tray ID: "${trayId}"`;
          errorDiv.style.color = '#dc3545';
          errorDiv.style.display = 'block';
          
          // Stay on current input and select text
          setTimeout(() => {
            newInput.focus();
            newInput.select();
          }, 100);
          
          validateAllInputsAndUpdateButtonsForBatchRejection();
          return;
        }
        
        // Show validation state
        newInput.style.border = '2px solid #ffc107';
        newInput.style.backgroundColor = '#fff3cd';
        errorDiv.textContent = 'Validating...';
        errorDiv.style.color = '#856404';
        errorDiv.style.display = 'block';
        
        const lotId = getCurrentLotId();
        console.log(`[API] Validating tray ${trayId} for lot ${lotId}`);
        
        fetch(`/iqf/iqf_validate_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
          .then(res => res.json())
          .then(data => {
            console.log(`[API-RESPONSE] Input ${index}:`, data);
            
            if (data && data.exists && data.valid_for_lot) {
              // SUCCESS
              newInput.style.border = '2px solid #28a745';
              newInput.style.backgroundColor = '#f8fff8';
              newInput._hasError = false;
              
              errorDiv.textContent = '✓ Valid';
              errorDiv.style.color = '#28a745';
              errorDiv.style.display = 'block';
              
              setTimeout(() => errorDiv.style.display = 'none', 1500);
              
              if (moveOnSuccess) {
                moveToNextInput();
              }
              
            } else {
              // ERROR
              newInput.style.border = '2px solid #dc3545';
              newInput.style.backgroundColor = '#ffebee';
              newInput._hasError = true;
              
              errorDiv.textContent = data.error || 'Invalid tray ID';
              errorDiv.style.color = '#dc3545';
              errorDiv.style.display = 'block';
              
              // Stay on current input
              setTimeout(() => {
                newInput.focus();
                newInput.select();
              }, 100);
            }
            
            // Update buttons
            validateAllInputsAndUpdateButtonsForBatchRejection();
          })
          .catch(error => {
            console.error(`[API-ERROR] Input ${index}:`, error);
            newInput._hasError = true;
            newInput.style.border = '2px solid #dc3545';
            newInput.style.backgroundColor = '#ffebee';
            errorDiv.textContent = 'Network error';
            errorDiv.style.color = '#dc3545';
            errorDiv.style.display = 'block';
            
            validateAllInputsAndUpdateButtonsForBatchRejection();
          });
      };
      
      // ENTER KEY EVENT
      newInput.addEventListener('keydown', function(e) {
        console.log(`[KEY] Input ${index} - Key: ${e.key}`);
        
        if (e.key === 'Enter') {
          console.log(`[ENTER] Detected on input ${index}`);
          e.preventDefault();
          e.stopPropagation();
          
          // Validate and move to next
          validateInput(true);
          return false;
        }
        
        if (e.key === 'Tab' && this._hasError) {
          e.preventDefault();
          this.focus();
          this.select();
          return false;
        }
      });
      
      // BLUR EVENT
      newInput.addEventListener('blur', function() {
        console.log(`[BLUR] Input ${index}`);
        validateInput(false);
      });
      
      // INPUT EVENT (clear errors while typing)
      newInput.addEventListener('input', function() {
        if (this._hasError) {
          this._hasError = false;
          this.style.border = '';
          this.style.backgroundColor = '';
          errorDiv.style.display = 'none';
          validateAllInputsAndUpdateButtonsForBatchRejection();
        }
      });
      
      console.log(`[READY] Input ${index} configured with Enter navigation`);
    });
    
    console.log('[SUCCESS] All inputs configured for Enter + validation');
  };
  
  // Start the process
  waitForInputs();
}

// Helper function 
function getCurrentLotId() {
  const modal = document.getElementById('delinkModal');
  return modal?.dataset?.lotId || null;
}


// ✅ NEW: Validate inputs for batch rejection
function validateAllInputsAndUpdateButtonsForBatchRejection() {
  const confirmBtn = document.getElementById('confirmDelinkBtn');
  if (!confirmBtn) return;
  
  const allInputs = document.querySelectorAll('.delink-tray-input, #topTrayIdInput');
  let hasErrors = false;
  let hasEmptyInputs = false;
  
  allInputs.forEach(input => {
    if (input._hasError) {
      hasErrors = true;
    }
    if (!input.value.trim()) {
      hasEmptyInputs = true;
    }
  });
  
  // Enable/disable confirm button
  if (hasErrors || hasEmptyInputs) {
    confirmBtn.disabled = true;
    confirmBtn.style.opacity = '0.5';
    confirmBtn.style.cursor = 'not-allowed';
  } else {
    confirmBtn.disabled = false;
    confirmBtn.style.opacity = '1';
    confirmBtn.style.cursor = 'pointer';
  }
}

// ✅ UPDATED: Enhanced confirm button handler that properly detects batch rejection
function setupDelinkConfirmButton() {
  const confirmDelinkBtn = document.getElementById('confirmDelinkBtn');
  if (confirmDelinkBtn) {
    // Remove existing listener and add new one
    const newConfirmBtn = confirmDelinkBtn.cloneNode(true);
    confirmDelinkBtn.parentNode.replaceChild(newConfirmBtn, confirmDelinkBtn);
    
    newConfirmBtn.addEventListener('click', function() {
      console.log('Confirm delink button clicked');
      
      const modal = document.getElementById('delinkModal');
      const lotId = modal ? modal.dataset.lotId : null;
      const batchId = modal ? modal.dataset.batchId : null;
      const missingQty = modal ? modal.dataset.missingQty : null;
      
      // ✅ FIXED: Properly detect batch rejection context
      const isBatchRejection = modal ? modal.dataset.isBatchRejection === 'true' : false;
      const lotRejectionRemarks = modal ? modal.dataset.lotRejectionRemarks : '';
      const totalQty = modal ? modal.dataset.totalQty : '0';
      
      console.log('Context detection:', { 
        lotId, 
        batchId, 
        missingQty, 
        isBatchRejection,
        lotRejectionRemarks,
        totalQty
      });
      
      if (!lotId) {
        showAlert('Error', 'Lot ID not found', 'error');
        return;
      }
      
      // Collect tray IDs
      const delinkTrayInputs = document.querySelectorAll('.delink-tray-input');
      const topTrayInput = document.getElementById('topTrayIdInput');
      
      const delinkTrayIds = Array.from(delinkTrayInputs).map(input => input.value.trim()).filter(id => id);
      const topTrayId = topTrayInput ? topTrayInput.value.trim() : '';
      const topTrayQtyElement = document.querySelector('#topTrayTableBody td:last-child');
      const topTrayQty = topTrayQtyElement ? topTrayQtyElement.textContent.trim() : '';
      
      console.log('Collected tray data:', { delinkTrayIds, topTrayId, topTrayQty });
      
      // Close delink modal
      if (modal) modal.style.display = 'none';
      
      // ✅ FIXED: Route to correct endpoint based on context
      if (isBatchRejection && batchId && lotRejectionRemarks) {
        console.log('ROUTING TO: Batch Rejection with Delink');
        showConfirm(
          'Confirm Batch Rejection',
          `This will reject the entire batch. Are you sure?`,
          function() {
            performBatchRejectionWithDelink(lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty);
          }
        );
      } else {
        console.log('ROUTING TO: Accept with Delink (default)');
        showConfirm(
          'Confirm Delink & Accept',
          `This will delink ${missingQty} pieces and accept the remaining lot. Are you sure?`,
          function() {
            performDelinkAcceptAction(lotId, delinkTrayIds, topTrayId, topTrayQty);
          }
        );
      }
    });
  }
}

// Call this function when setting up modal event listeners
document.addEventListener('DOMContentLoaded', function() {
  setupDelinkConfirmButton();
});

// ✅ NEW: Function to perform batch rejection with delink - EXPLICIT ENDPOINT ROUTING
function performBatchRejectionWithDelink(lotId, batchId, delinkTrayIds, topTrayId, topTrayQty, lotRejectionRemarks, totalQty) {
  console.log('🎯 BATCH REJECTION: Starting performBatchRejectionWithDelink');
  console.log('📊 BATCH REJECTION: Parameters:', { 
    lotId, 
    batchId, 
    delinkTrayIds, 
    topTrayId, 
    topTrayQty, 
    lotRejectionRemarks,
    totalQty 
  });

  // Parse top tray quantity
  let parsedTopTrayQty = null;
  if (topTrayQty && topTrayQty !== '') {
    parsedTopTrayQty = parseInt(topTrayQty, 10);
    if (isNaN(parsedTopTrayQty)) {
      console.error('❌ BATCH REJECTION: Invalid top tray quantity:', topTrayQty);
      showAlert('Error', 'Invalid top tray quantity', 'error');
      return;
    }
  }

  const delinkPayload = {
    lot_id: lotId,
    delink_tray_ids: delinkTrayIds,
    top_tray_id: topTrayId,
    top_tray_qty: parsedTopTrayQty
  };

  console.log('📤 BATCH REJECTION: Sending delink payload:', delinkPayload);

  // Step 1: Perform delink operation first
  fetch('/iqf/iqf_tray_delink_and_top_tray_update/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify(delinkPayload)
  })
  .then(res => {
    console.log('📡 BATCH REJECTION: Delink API status:', res.status);
    return res.json();
  })
  .then(data => {
    console.log('📊 BATCH REJECTION: Delink API Response:', data);
    if (data && data.success) {
      console.log('✅ BATCH REJECTION: Delink successful, now calling BATCH REJECTION endpoint...');
      
      // Step 2: EXPLICIT BATCH REJECTION CALL
      const batchRejectionPayload = {
        batch_id: batchId,
        lot_id: lotId,
        total_qty: totalQty,
        lot_rejected_comment: lotRejectionRemarks
      };
      
      console.log('📤 BATCH REJECTION: Sending to /iqf/iqf_lot_rejection/');
      console.log('📦 BATCH REJECTION: Payload:', batchRejectionPayload);
      
      // ✅ EXPLICIT: Call batch rejection endpoint (NOT accept endpoint)
      return fetch('/iqf/iqf_lot_rejection/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(batchRejectionPayload)
      });
    } else {
      throw new Error(data.error || 'Failed to perform delink operation');
    }
  })
  .then(res => {
    console.log('📡 BATCH REJECTION: Batch rejection API status:', res.status);
    
    // Check if it's a redirect response (which shouldn't happen for batch rejection)
    if (res.redirected) {
      console.warn('⚠️ BATCH REJECTION: Unexpected redirect to:', res.url);
    }
    
    return res.json();
  })
  .then(data => {
    console.log('📊 BATCH REJECTION: Final API Response:', data);
    
    if (data && data.success) {
      console.log('✅ BATCH REJECTION: Success - showing success message');
      showSuccess('Lot Rejection completed successfully!', function() {
        window.location.reload();
      });
    } else {
      console.error('❌ BATCH REJECTION: Failed with error:', data.error);
      showAlert('Error', 'Delink successful but lot rejection failed: ' + (data.error || 'Unknown error'), 'error');
    }
  })
  .catch(error => {
    console.error('❌ BATCH REJECTION: Network/processing error:', error);
    showAlert('Error', 'Error during lot rejection with delink: ' + error.message, 'error');
  });
}

// ✅ NEW: Function to perform normal batch rejection (without delink)
function performBatchRejection(batchId, lotId, totalQty, lotRejectionRemarks) {
  console.log('🎯 Performing normal batch rejection:', { batchId, lotId, totalQty, lotRejectionRemarks });
  
  const msgDiv = document.getElementById("batchRejectionMsg");
  if (msgDiv) {
    msgDiv.style.color = "#007bff";
    msgDiv.textContent = "Saving batch rejection...";
  }
  
  fetch('/iqf/iqf_lot_rejection/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      batch_id: batchId,
      lot_id: lotId,
      total_qty: totalQty,
      lot_rejected_comment: lotRejectionRemarks
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = "Lot rejection saved successfully!";
      }
      setTimeout(() => {
        const trayModal = document.getElementById("trayScanModal");
        if (trayModal) trayModal.classList.remove("open");
        if (msgDiv) msgDiv.textContent = "";
        window.location.reload();
      }, 1200);
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save Batch Rejection";
      }
      document.getElementById("proceedButton").disabled = false;
    }
  })
  .catch(() => {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Network error";
    }
    document.getElementById("proceedButton").disabled = false;
  });
}

  const cancelButton = document.getElementById("cancelButton");
  if (cancelButton) {
    cancelButton.addEventListener("click", () => {
       window.location.reload();
      trayModal.classList.remove("open");
    });
  }
}

// ✅ Helper functions for quantity validation errors
function showQuantityError(input, message) {
  clearQuantityError(input);
  
  const errorDiv = document.createElement('div');
  errorDiv.className = 'qty-validation-error';
  errorDiv.style.cssText = `
    color: #d32f2f;
    font-size: 12px;
    margin-top: 4px;
    padding: 4px 8px;
    background-color: #ffebee;
    border: 1px solid #f44336;
    border-radius: 4px;
    font-weight: bold;
    text-align: center;
  `;
  errorDiv.textContent = message;
  
  input.parentElement.appendChild(errorDiv);
  
  // Auto-remove error after 3 seconds
  setTimeout(() => {
    clearQuantityError(input);
  }, 3000);
}

function clearQuantityError(input) {
  const existingError = input.parentElement.querySelector('.qty-validation-error');
  if (existingError) {
    existingError.remove();
  }
}

// ✅ Enhanced validation on form submit
function validateTotalQuantityBeforeSubmit() {
  const modalPhysicalQty = document.getElementById('modalPhysicalQty');
  const maxAllowedQty = modalPhysicalQty ? parseInt(modalPhysicalQty.textContent) || 0 : 0;
  
  let totalEnteredQty = 0;
  document.querySelectorAll('.rejection-qty-input').forEach(function(input) {
    totalEnteredQty += parseInt(input.value) || 0;
  });
  
  if (totalEnteredQty > maxAllowedQty) {
    const msgDiv = document.getElementById("batchRejectionMsg");
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.innerHTML = `
        <i class="fa fa-exclamation-triangle"></i> 
        Total quantity (${totalEnteredQty}) cannot exceed Physical Qty (${maxAllowedQty})
      `;
    }
    return false;
  }
  
  return true;
}

// ✅ UPDATED: Enhanced updateAcceptedTrayTable with dynamic tray capacity
async function updateAcceptedTrayTable(totalBrassQty, totalEnteredQty, providedTrayCapacity = null) {
  const acceptedTrayContainer = document.getElementById('accepted-tray-table-container');
  const acceptedTrayTableBody = document.getElementById('accepted-tray-table-body');

  if (!acceptedTrayTableBody || !acceptedTrayContainer) return;

  let trayCapacity = providedTrayCapacity;

  // ✅ If no tray capacity provided, fetch it dynamically - NO FALLBACK
  if (!trayCapacity || trayCapacity <= 0) {
    const stockLotId = document.getElementById('trayScanModal').dataset.stockLotId || '';
    if (!stockLotId) {
      console.error('❌ No stock lot ID found for tray capacity fetch');
      showTrayCapacityError('Stock lot ID not found');
      return;
    }

    console.log('🔄 Fetching tray capacity for accepted tray table...');
    try {
      const capacityResult = await fetchTrayCapacityDynamic(stockLotId);
      
      if (!capacityResult.success) {
        console.error('❌ Failed to fetch tray capacity:', capacityResult.error);
        showTrayCapacityError(capacityResult.error);
        return;
      }

      trayCapacity = capacityResult.tray_capacity;
      
      if (!trayCapacity || trayCapacity <= 0) {
        showTrayCapacityError('Invalid tray capacity received from server');
        return;
      }

    } catch (error) {
      console.error('❌ Network error fetching tray capacity:', error);
      showTrayCapacityError(`Network error: ${error.message}`);
      return;
    }
    
    // Update hidden input
    const trayCapacityInput = document.getElementById('tray-capacity');
    if (trayCapacityInput) {
      trayCapacityInput.value = trayCapacity;
    }
  }

  console.log(`📊 Using verified tray capacity: ${trayCapacity} for accepted tray calculation`);

  // ✅ FIXED: Calculate accepted quantity from Physical Qty instead of Brass Qty
  const modalPhysicalQty = document.getElementById('modalPhysicalQty');
  const physicalQty = modalPhysicalQty ? parseInt(modalPhysicalQty.textContent) || 0 : 0;
  

  // ✅ NEW CALCULATION: Physical Qty - Total Entered Rejections = Accepted Qty
  let acceptedQty = physicalQty - totalEnteredQty;
  
  // ✅ Ensure accepted quantity is not negative
  if (acceptedQty < 0) {
    acceptedQty = 0;
    console.warn('⚠️ Accepted quantity was negative, set to 0');
  }

  if (acceptedQty > 0) {
    acceptedTrayContainer.style.display = '';
    
    // ✅ CRITICAL FIX: Preserve existing tray IDs before rebuilding table
    const existingTrayIds = [];
    const existingRows = acceptedTrayTableBody.querySelectorAll('tr');
    existingRows.forEach((row, index) => {
      const trayInput = row.querySelector('.accepted-tray-id-input');
      existingTrayIds[index] = trayInput ? trayInput.value.trim() : '';
    });
    console.log('🔄 [PRESERVE] Saving existing tray IDs:', existingTrayIds);
    
    acceptedTrayTableBody.innerHTML = '';

    const headerQtyElement = document.getElementById('accepted-qty-display');
    if (headerQtyElement) {
      headerQtyElement.textContent = acceptedQty;
    }

    // Calculate tray distribution with verified capacity
    const remainder = acceptedQty % trayCapacity;
    const fullTrays = Math.floor(acceptedQty / trayCapacity);

    // Safety limit
    const MAX_TRAYS = 1000;
    if (fullTrays > MAX_TRAYS) {
      console.error('Too many trays calculated:', fullTrays);
      showTrayCapacityError(`Too many trays required (${fullTrays}). Please check quantities.`);
      return;
    }

    const trayQuantities = [];
    
    if (remainder > 0) {
      trayQuantities.push(remainder);
    }
    
    for (let i = 0; i < fullTrays; i++) {
      trayQuantities.push(trayCapacity);
    }

    // ✅ FIXED: Create rows and restore existing tray IDs
    trayQuantities.forEach((qty, idx) => {
      const savedTrayId = existingTrayIds[idx] || '';
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${idx + 1}${idx === 0 && remainder > 0 ? ' (Top Tray)' : ''}</td>
        <td>
          <input type="text" 
                 class="accepted-tray-id-input" 
                 value="${savedTrayId}" 
                 placeholder="Scan Tray ID" 
                 maxlength="9"
                 ${idx === 0 ? 'autofocus' : ''}
                 data-row-index="${idx}"
                 data-tray-qty="${qty}"
                 style="width: 100%;" />
          <div class="tray-id-validation-msg" style="display: none; margin-top: 4px; font-size: 12px;"></div>
        </td>
        <td>${qty}</td>
      `;
      acceptedTrayTableBody.appendChild(row);
      
      if (savedTrayId) {
        console.log(`✅ [PRESERVE] Restored tray ${idx + 1}: "${savedTrayId}"`);
      }
    });

    addAcceptedTrayIdValidation();
    showAcceptanceRemarksSection();

  } else {
    acceptedTrayContainer.style.display = 'none';
    acceptedTrayTableBody.innerHTML = '';
    hideAcceptanceRemarksSection();
  }
}

// ✅ Enhanced accepted tray ID validation using global validation system with auto-save
function addAcceptedTrayIdValidation() {
  console.log('🔄 [IQF] Setting up accepted tray validation with instant validation...');
  
  // Helper to get current lot ID (reuse from global validation)
  function getCurrentLotId() {
    const modal = document.getElementById('trayScanModal') || document.getElementById('delinkModal');
    if (modal && modal.dataset.stockLotId) return modal.dataset.stockLotId;
    if (modal && modal.dataset.lotId) return modal.dataset.lotId;
    const btn = document.querySelector('.btn-twitter');
    if (btn && btn.getAttribute('data-lot-id')) return btn.getAttribute('data-lot-id');
    return '';
  }
  
  // Use the global validation system for instant validation
  if (window.IQFTrayValidation) {
    const currentLotId = getCurrentLotId();
    const container = document.getElementById('accepted-tray-table-container') || document;
    
    // ✅ AUTO-SAVE: Setup auto-save for accepted tray container
    if (currentLotId) {
      window.IQFTrayValidation.onModalOpen(container, currentLotId);
    } else {
      window.IQFTrayValidation.attachToContainer(container);
    }
  }
  
  // Keep existing duplicate check logic for accepted trays
  const trayInputs = document.querySelectorAll('.accepted-tray-id-input');

  trayInputs.forEach((input, idx, allInputs) => {
    // Track validation state for each input
    input.validationState = 'pending'; // 'pending', 'success', 'error'
    
    // ✅ INSTANT VALIDATION: Trigger when 9 characters are entered
    input.addEventListener('input', async function() {
      const trayId = input.value.trim();
      const msgDiv = input.parentElement.querySelector('.tray-id-validation-msg');
      
      // Clear styling while typing if less than 9 characters
      if (trayId.length < 9) {
        input.style.borderColor = '';
        input.style.backgroundColor = '';
        if (msgDiv) {
          msgDiv.textContent = '';
          msgDiv.style.display = 'none';
        }
        return;
      }
      
      // When 9 characters reached, validate instantly
      if (trayId.length === 9) {
        // Check for duplicates first
        let duplicateRow = null;
        allInputs.forEach(function(otherInput, otherIdx) {
          if (otherIdx !== idx && otherInput.value.trim() === trayId) {
            duplicateRow = otherIdx + 1;
          }
        });
        
        if (duplicateRow) {
          input.style.borderColor = '#dc3545';
          input.style.backgroundColor = '#fff5f5';
          if (msgDiv) {
            msgDiv.innerHTML = '<i class=\"fa fa-times\" style=\"margin-right: 6px;\"></i>Duplicate Tray ID: \"' + trayId + '\" already in row ' + duplicateRow + '.';
            msgDiv.style.display = 'block';
            msgDiv.style.backgroundColor = '#ffebee';
            msgDiv.style.color = '#c62828';
            msgDiv.style.border = '1px solid #f44336';
            msgDiv.style.padding = '8px 12px';
            msgDiv.style.borderRadius = '4px';
            msgDiv.style.fontWeight = 'bold';
            msgDiv.style.fontSize = '12px';
            msgDiv.style.textAlign = 'center';
          }
          // ✅ INSTANT AUTO-SELECT on error
          input.select();
          input.validationState = 'error';
          return;
        }
        
        // Server validation
        const qtyCell = input.parentElement.parentElement.querySelector('td:nth-child(3)');
        const trayQty = qtyCell ? parseInt(qtyCell.textContent.trim()) : 0;
        
        let currentRejectionTotal = 0;
        let alreadyAllocated = 0;
        
        try {
          const totalQtyElement = document.getElementById('rejection-total-qty');
          if (totalQtyElement) {
            currentRejectionTotal = parseInt(totalQtyElement.textContent) || 0;
          }
          
          if (currentRejectionTotal === 0) {
            const rejectionInputs = document.querySelectorAll('.rejection-qty-input');
            rejectionInputs.forEach(function(rejInput) {
              currentRejectionTotal += parseInt(rejInput.value) || 0;
            });
          }
          
          allInputs.forEach(function(otherInput, otherIdx) {
            if (otherIdx < idx && otherInput.value.trim()) {
              alreadyAllocated++;
            }
          });
        } catch (e) {
          console.log('Could not get rejection total:', e);
        }
        
        const lotId = getCurrentLotId();
        
        try {
          const response = await fetch(`/iqf/iqf_reject_check_tray_id_simple/?tray_id=${trayId}&lot_id=${lotId}&tray_qty=${trayQty}&total_iqf_qty=${currentRejectionTotal}&already_allocated=${alreadyAllocated}`);
          const data = await response.json();
          
          const statusMsg = data.status_message || '';
          
          // ✅ FIXED: Check for SUCCESS conditions first
          const isSuccess = statusMsg === 'Available (can rearrange)' || 
                           statusMsg === 'New Tray Available' || 
                           statusMsg === 'Reuse' || 
                           statusMsg === 'Available' ||
                           (data.is_valid === true);
          
          // ✅ FIXED: Check for ERROR conditions
          const isError = statusMsg === 'Different Lot' || 
                         statusMsg === 'HOLD' || 
                         statusMsg === 'Wrong Tray Type' ||
                         statusMsg === 'Invalid Barcode' ||
                         statusMsg === 'Need New Tray' ||
                         statusMsg.includes('Not Found') ||
                         data.is_valid === false;
          
          if (isSuccess) {
            // ✅ Success state with auto-advance
            input.style.borderColor = '#28a745';
            input.style.backgroundColor = '#f8fff8';
            input.validationState = 'success';
            
            if (msgDiv) {
              msgDiv.innerHTML = '<i class=\"fa fa-check\"></i> ' + (data.message || statusMsg);
              msgDiv.style.display = 'block';
              msgDiv.style.backgroundColor = '#e8f5e9';
              msgDiv.style.color = '#2e7d32';
              msgDiv.style.border = '1px solid #4caf50';
              msgDiv.style.padding = '8px 12px';
              msgDiv.style.borderRadius = '4px';
              msgDiv.style.fontWeight = 'bold';
              msgDiv.style.fontSize = '12px';
              msgDiv.style.textAlign = 'center';
            }
            
            // ✅ AUTO-ADVANCE to next input
            const currentIndex = parseInt(input.getAttribute('data-row-index'));
            if (!isNaN(currentIndex) && currentIndex + 1 < allInputs.length) {
              allInputs[currentIndex + 1].focus();
            }
          } else if (isError) {
            // ✅ Error state with instant auto-select
            input.style.borderColor = '#dc3545';
            input.style.backgroundColor = '#fff5f5';
            input.validationState = 'error';
            
            if (msgDiv) {
              msgDiv.innerHTML = '<i class=\"fa fa-times\"></i> ' + (data.message || statusMsg);
              msgDiv.style.display = 'block';
              msgDiv.style.backgroundColor = '#ffebee';
              msgDiv.style.color = '#c62828';
              msgDiv.style.border = '1px solid #f44336';
              msgDiv.style.padding = '8px 12px';
              msgDiv.style.borderRadius = '4px';
              msgDiv.style.fontWeight = 'bold';
              msgDiv.style.fontSize = '12px';
              msgDiv.style.textAlign = 'center';
            }
            
            // ✅ INSTANT AUTO-SELECT on error
            input.select();
          } else {
            // Unknown status - treat as neutral/pending
            input.style.borderColor = '#ffc107';
            input.style.backgroundColor = '#fffef5';
            input.validationState = 'pending';
            
            if (msgDiv) {
              msgDiv.innerHTML = '<i class=\"fa fa-info-circle\"></i> ' + (data.message || statusMsg);
              msgDiv.style.display = 'block';
              msgDiv.style.backgroundColor = '#fff3cd';
              msgDiv.style.color = '#856404';
              msgDiv.style.border = '1px solid #ffc107';
              msgDiv.style.padding = '8px 12px';
              msgDiv.style.borderRadius = '4px';
              msgDiv.style.fontWeight = 'bold';
              msgDiv.style.fontSize = '12px';
              msgDiv.style.textAlign = 'center';
            }
          }
        } catch (error) {
          console.error('Validation error:', error);
          input.style.borderColor = '#dc3545';
          input.style.backgroundColor = '#fff5f5';
          input.select();
        }
      }
    });
    
    // Enhanced blur handler for duplicate checking (in addition to instant validation)
    input.addEventListener('blur', function() {
      const trayId = input.value.trim();
      const msgDiv = input.parentElement.querySelector('.tray-id-validation-msg');
      
      // Clear previous duplicate messages only
      if (msgDiv && msgDiv.textContent.includes('Duplicate')) {
        msgDiv.textContent = '';
        msgDiv.style.display = 'none';
      }
      input.validationState = 'pending';
      
      if (!trayId) {
        return;
      }

      // Check for duplicate tray ID in other rows
      let duplicateRow = null;
      allInputs.forEach(function(otherInput, otherIdx) {
        if (otherIdx !== idx && otherInput.value.trim() === trayId) {
          duplicateRow = otherIdx + 1;
        }
      });
      
      if (duplicateRow) {
        if (msgDiv) {
          msgDiv.innerHTML = '<i class="fa fa-times" style="margin-right: 6px;"></i>Duplicate Tray ID: "' + trayId + '" already in row ' + duplicateRow + '.';
          msgDiv.style.display = 'block';
          msgDiv.style.backgroundColor = '#ffebee';
          msgDiv.style.color = '#c62828';
          msgDiv.style.border = '1px solid #f44336';
          msgDiv.style.padding = '8px 12px';
          msgDiv.style.borderRadius = '4px';
          msgDiv.style.fontWeight = 'bold';
          msgDiv.style.fontSize = '12px';
          msgDiv.style.textAlign = 'center';
        }
        input.validationState = 'error';
        return;
      }

      // Get trayQty from the same row
      const qtyCell = input.parentElement.parentElement.querySelector('td:nth-child(3)');
      const trayQty = qtyCell ? parseInt(qtyCell.textContent.trim()) : 0;

      // ✅ FIXED: Get current rejection total from form + count already allocated trays
      let currentRejectionTotal = 0;
      let alreadyAllocated = 0;
      
      try {
        // Method 1: Get from total display element
        const totalQtyElement = document.getElementById('rejection-total-qty');
        if (totalQtyElement) {
          currentRejectionTotal = parseInt(totalQtyElement.textContent) || 0;
        }
        
        // Method 2: Calculate from all rejection input fields if total element not found
        if (currentRejectionTotal === 0) {
          const rejectionInputs = document.querySelectorAll('.rejection-qty-input');
          rejectionInputs.forEach(function(rejInput) {
            currentRejectionTotal += parseInt(rejInput.value) || 0;
          });
        }
        
        // ✅ NEW: Count how many acceptance trays are already filled (before current one)
        allInputs.forEach(function(otherInput, otherIdx) {
          if (otherIdx < idx && otherInput.value.trim()) {
            alreadyAllocated++;
          }
        });
        
      } catch (e) {
        console.log('Could not get rejection total:', e);
        currentRejectionTotal = 0;
        alreadyAllocated = 0;
      }

      console.log(`[DEBUG] Validation for ${trayId}: rejection=${currentRejectionTotal}, allocated=${alreadyAllocated}`);

      // ✅ Server validation for accepted trays with allocation count
      const lotId = document.getElementById('trayScanModal').dataset.stockLotId || '';
      
      fetch(`/iqf/iqf_reject_check_tray_id_simple/?tray_id=${trayId}&lot_id=${lotId}&tray_qty=${trayQty}&total_iqf_qty=${currentRejectionTotal}&already_allocated=${alreadyAllocated}`)
        .then(res => res.json())
        .then(data => {
          msgDiv.style.display = 'block';
          msgDiv.style.fontWeight = 'bold';
          msgDiv.style.fontSize = '12px';
          msgDiv.style.padding = '8px 12px';
          msgDiv.style.borderRadius = '4px';
          msgDiv.style.textAlign = 'center';
          msgDiv.style.border = '1px solid';
          msgDiv.style.marginTop = '4px';
          
          // Style based on status message
          const statusMsg = data.status_message || '';
          
          if (statusMsg === 'Different Lot') {
            msgDiv.innerHTML = '<i class="fa fa-times" style="margin-right: 6px;"></i>' + statusMsg;
            msgDiv.style.backgroundColor = '#ffebee';
            msgDiv.style.color = '#c62828';
            msgDiv.style.borderColor = '#f44336';
            input.validationState = 'error';
          } else if (statusMsg === 'Available (can rearrange)') {
            msgDiv.innerHTML = '<i class="fa fa-check" style="margin-right: 6px;"></i>' + statusMsg;
            msgDiv.style.backgroundColor = '#e8f5e9';
            msgDiv.style.color = '#2e7d32';
            msgDiv.style.borderColor = '#4caf50';
            input.validationState = 'success';
          } else if (statusMsg === 'New Tray Available') {
            msgDiv.innerHTML = '<i class="fa fa-check" style="margin-right: 6px;"></i>' + statusMsg;
            msgDiv.style.backgroundColor = '#e8f5e9';
            msgDiv.style.color = '#2e7d32';
            msgDiv.style.borderColor = '#4caf50';
            input.validationState = 'success';
          } else if (statusMsg === 'Wrong Tray Type') {
            msgDiv.innerHTML = '<i class="fa fa-exclamation-triangle" style="margin-right: 6px;"></i>' + statusMsg;
            msgDiv.style.backgroundColor = '#fff3e0';
            msgDiv.style.color = '#f57c00';
            msgDiv.style.borderColor = '#ff9800';
            input.validationState = 'error';
          } else if (statusMsg === 'Invalid Barcode') {
            msgDiv.innerHTML = '<i class="fa fa-times" style="margin-right: 6px;"></i>' + statusMsg;
            msgDiv.style.backgroundColor = '#ffebee';
            msgDiv.style.color = '#c62828';
            msgDiv.style.borderColor = '#f44336';
            input.validationState = 'error';
          } else if (statusMsg === 'Need New Tray') {
            msgDiv.innerHTML = '<i class="fa fa-times" style="margin-right: 6px;"></i>' + statusMsg;
            msgDiv.style.backgroundColor = '#ffebee';
            msgDiv.style.color = '#c62828';
            msgDiv.style.borderColor = '#f44336';
            input.validationState = 'error';
          } else {
            msgDiv.innerHTML = '<i class="fa fa-times" style="margin-right: 6px;"></i>' + (statusMsg || 'Invalid tray ID');
            msgDiv.style.backgroundColor = '#ffebee';
            msgDiv.style.color = '#c62828';
            msgDiv.style.borderColor = '#f44336';
            input.validationState = 'error';
          }
        })
        .catch(() => {
          msgDiv.textContent = 'Network error validating Tray ID';
          msgDiv.style.display = 'block';
          msgDiv.style.backgroundColor = '#ffebee';
          msgDiv.style.color = '#c62828';
          msgDiv.style.border = '1px solid #f44336';
          msgDiv.style.padding = '8px 12px';
          msgDiv.style.borderRadius = '4px';
          msgDiv.style.fontWeight = 'bold';
          msgDiv.style.fontSize = '12px';
          msgDiv.style.textAlign = 'center';
          input.validationState = 'error';
        });
    });

    // ✅ Enter key navigation - works with instant validation
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        // With instant validation, the state is already set when user presses Enter
        // No need to blur, just check validation state
        if (input.validationState === 'error') {
          input.select(); // Select all text for easy correction
          return;
        }
        
        // Move to next input if validation passed
        const currentIndex = parseInt(input.getAttribute('data-row-index'));
        if (!isNaN(currentIndex) && currentIndex + 1 < allInputs.length) {
          allInputs[currentIndex + 1].focus();
        }
      }
      
      // Prevent Tab away from error field
      if (e.key === 'Tab' && input.validationState === 'error') {
        e.preventDefault();
        input.select();
      }
    });
  });
}

// Helper function to check lot rejection comment scenario
function checkIfLotRejectionCommentScenario() {
  // ✅ SIMPLIFIED: Since we're always using Physical Qty now, 
  // we don't need special handling for lot rejection comments
  return false;
}

// Hide/Show functions
function hideAcceptedTrayTable() {
  const acceptedTrayContainer = document.getElementById('accepted-tray-table-container');
  if (acceptedTrayContainer) {
    acceptedTrayContainer.style.display = 'none';
  }
  hideAcceptanceRemarksSection();
}

function showAcceptanceRemarksSection() {
  const remarksSection = document.getElementById('acceptanceRemarksSection');
  if (remarksSection) {
    remarksSection.style.display = 'block';
  }
}

function hideAcceptanceRemarksSection() {
  const remarksSection = document.getElementById('acceptanceRemarksSection');
  if (remarksSection) {
    remarksSection.style.display = 'none';
  }
}

// Handle lot rejection
function handleLotRejection(batchId, stockLotId, msgDiv, proceedButton) {
  // Get lot rejection remarks if available, otherwise use a default message for full rejection
  const lotRejectionRemarksInput = document.getElementById('lotRejectionRemarksInput');
  let lotRejectionRemarks = lotRejectionRemarksInput ? lotRejectionRemarksInput.value.trim() : '';
  
  // If no remarks provided and it's a full quantity rejection, use default remark
  if (!lotRejectionRemarks) {
    const modalPhysicalQty = document.getElementById('modalPhysicalQty');
    const physicalQty = modalPhysicalQty ? parseInt(modalPhysicalQty.textContent) || 0 : 0;
    const totalQtyElement = document.getElementById('rejection-total-qty');
    const totalEnteredQty = totalQtyElement ? parseInt(totalQtyElement.textContent) || 0 : 0;
    
    if (physicalQty > 0 && totalEnteredQty === physicalQty) {
      lotRejectionRemarks = 'Full lot rejected';
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = 'Lot rejection remarks are required for lot rejection.';
      }
      proceedButton.disabled = false;
      return;
    }
  }

  const totalQty = document.getElementById('rejection-total-qty').textContent || "0";

  if (msgDiv) {
    msgDiv.style.color = "#007bff";
    msgDiv.textContent = "Processing lot rejection...";
  }

  fetch('/iqf/iqf_lot_rejection/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      batch_id: batchId,
      lot_id: stockLotId,
      total_qty: totalQty,
      lot_rejected_comment: lotRejectionRemarks
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = "Lot rejection saved successfully!";
      }
      setTimeout(() => {
        const trayModal = document.getElementById("trayScanModal");
        if (trayModal) {
          trayModal.classList.remove("open");
        }
        window.location.reload();
      }, 1200);
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save lot rejection";
      }
      proceedButton.disabled = false;
    }
  })
  .catch(error => {
    console.error('Error in lot rejection:', error);
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Network error occurred";
    }
    proceedButton.disabled = false;
  });
}

function handleTrayWiseRejectionWithAcceptance(batchId, stockLotId, msgDiv, proceedButton) {
  // Add validation before proceeding
  if (!validateTotalQuantityBeforeSubmit()) {
    proceedButton.disabled = false;
    return;
  }

  // ✅ SMART FIX: Check if it's full lot rejection first
  const modalPhysicalQty = document.getElementById('modalPhysicalQty');
  const physicalQty = modalPhysicalQty ? parseInt(modalPhysicalQty.textContent) || 0 : 0;
  const totalQtyElement = document.getElementById('rejection-total-qty');
  const totalEnteredQty = totalQtyElement ? parseInt(totalQtyElement.textContent) || 0 : 0;
  
  const isFullLotRejection = (physicalQty > 0 && totalEnteredQty === physicalQty);
  
  // Only require acceptance remarks for partial rejections
  const acceptanceRemarksInput = document.getElementById('acceptanceRemarksInput');
  const acceptanceRemarks = acceptanceRemarksInput ? acceptanceRemarksInput.value.trim() : '';
  
  if (false && !isFullLotRejection && !acceptanceRemarks) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Acceptance remarks are required for partial rejection.";
    }
    
    proceedButton.disabled = false;
    return;
  }

  // Rest of your existing logic remains the same...
  const rejectionRows = document.querySelectorAll("#rejection-table-body tr");
  let tray_rejections = [];

  rejectionRows.forEach((row, index) => {
    const qtyInput = row.querySelector('input.rejection-qty-input');
    const brassInput = row.querySelector('input[readonly]');
    
    if (!qtyInput || !brassInput) return;

    const brassQty = parseInt(brassInput.value) || 0;
    const hasLotComment = qtyInput.getAttribute('data-has-lot-comment') === 'true';
    const qty = parseInt(qtyInput.value.trim()) || 0;

    if (qty > 0 && (brassQty > 0 || hasLotComment)) {
      const reason_id = row.querySelectorAll("td")[1].textContent.trim();
      tray_rejections.push({
        reason_id: reason_id,
        quantity: qty
      });
    }
  });

  // ✅ For full lot rejection, send dummy accepted_trays to pass backend validation
  let accepted_trays = [];
  
  if (isFullLotRejection) {
    // Backend requires accepted_trays to not be empty, send dummy entry
    accepted_trays = [{ tray_id: "FULL_REJECTION", qty: 0, sequence: 1 }];
  } else {
    const acceptedTrayRows = document.querySelectorAll("#accepted-tray-table-body tr");
    acceptedTrayRows.forEach((row, idx) => {
      const trayInput = row.querySelector('.accepted-tray-id-input');
      const qtyCell = row.cells[2];
      
      if (trayInput && qtyCell) {
        const tray_id = trayInput.value.trim();
        const qty = parseInt(qtyCell.textContent.trim()) || 0;
        
        if (tray_id && qty > 0) {
          accepted_trays.push({
            tray_id: tray_id,
            qty: qty,
            sequence: idx + 1
          });
        }
      }
    });
  }

  if (msgDiv) {
    msgDiv.style.color = "#007bff";
    msgDiv.textContent = isFullLotRejection ? "Saving full lot rejection..." : "Saving rejection and acceptance data...";
  }

  fetch('/iqf/iqf_tray_rejection/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      lot_id: stockLotId,
      batch_id: batchId,
      tray_rejections: tray_rejections,
      accepted_trays: accepted_trays,
      acceptance_remarks: acceptanceRemarks // Will be empty for full lot rejection
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = isFullLotRejection ? "Full lot rejection saved successfully!" : "Rejection and acceptance data saved successfully!";
      }
      
      setTimeout(() => {
        if (isFullLotRejection) {
          // ✅ For full lot rejection: just reload page, no popups
          window.location.reload();
        } else {
          // For partial rejection: show popups
          const trayModal = document.getElementById("trayScanModal");
          const detailsDiv = document.getElementById("trayScanDetails");
          if (trayModal && detailsDiv) {
            trayModal.classList.add("open");
            showReadOnlyRejectionData(stockLotId, detailsDiv);
          }
          
          fetch(`/iqf/iqf_get_rejected_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
            .then(res => res.json())
            .then(rescanData => {
              if (rescanData.success) {
                showAcceptedTrayModalWithOptimalDistribution(rescanData, stockLotId, false);
              } else {
                window.location.reload();
              }
            })
            .catch(() => {
              window.location.reload();
            });
        }
      }, 1000);
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save data";
      }
      proceedButton.disabled = false;
    }
  });
}

// ✅ FIXED: Simplified lot rejection draft (Following Brass QC pattern)
function handleLotRejectionDraft(batchId, stockLotId, msgDiv, draftButton) {
  const lotRejectionRemarksInput = document.getElementById('lotRejectionRemarksInput');
  const lotRejectionRemarks = lotRejectionRemarksInput ? lotRejectionRemarksInput.value.trim() : '';

  if (!lotRejectionRemarks) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = 'Lot rejection remarks are required for lot rejection draft.';
    }
    draftButton.disabled = false;
    return;
  }

  const totalQty = document.getElementById('rejection-total-qty').textContent || "0";

  // ✅ Collect comprehensive draft data
  const draftData = {
    is_draft: true,
    batch_rejection: true,
    total_qty: totalQty,
    lot_rejected_comment: lotRejectionRemarks,
    timestamp: new Date().toISOString()
  };

  // ✅ Use new unified draft API
  fetch('/iqf/iqf_set_manual_draft/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      lot_id: stockLotId,
      batch_id: batchId,
      draft_type: 'batch_rejection',
      draft_data: draftData
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = "Manual draft saved successfully!";
      }
      setTimeout(() => {
        window.location.reload();
      }, 1500);
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save manual draft";
      }
      draftButton.disabled = false;
    }
  });
}

// ✅ FIXED: Simplified tray rejection draft (Following Brass QC pattern)
function handleTrayWiseRejectionDraft(batchId, stockLotId, msgDiv, draftButton) {
  // ✅ Collect tray rejection reasons with enhanced structure
  const rejectionRows = document.querySelectorAll("#rejection-table-body tr");
  let tray_rejections = [];
  let tray_id_mappings = [];  // ✅ Enhanced: Track tray ID mappings
  
  rejectionRows.forEach((row, index) => {
    const qtyInput = row.querySelector('input.rejection-qty-input');
    const reasonIdCell = row.querySelectorAll("td")[1];
    const trayInput = row.querySelector('.tray-id-input');  // ✅ Enhanced: Collect tray IDs
    
    const qty = parseInt(qtyInput?.value.trim()) || 0;
    const reason_id = reasonIdCell?.textContent.trim();
    const tray_id = trayInput ? trayInput.value.trim() : '';
    
    if (qty > 0 && reason_id) {
      tray_rejections.push({ 
        reason_id, 
        qty: qty,  // ✅ Use consistent 'qty' field name
        quantity: qty, 
        tray_id: tray_id,
        row_index: index
      });
      
      // ✅ Enhanced: Store tray ID mapping for restoration
      if (tray_id) {
        tray_id_mappings.push({
          row_index: index,
          reason_id: reason_id,
          tray_id: tray_id,
          qty: qty
        });
      }
    }
  });

  // ✅ Collect accepted trays with enhanced structure
  const acceptedTrayRows = document.querySelectorAll("#accepted-tray-table-body tr");
  let accepted_trays = [];
  acceptedTrayRows.forEach((row, idx) => {
    const trayInput = row.querySelector('.accepted-tray-id-input');
    const qtyCell = row.cells[2];
    const tray_id = trayInput ? trayInput.value.trim() : "";
    const qty = qtyCell ? parseInt(qtyCell.textContent.trim()) || 0 : 0;
    
    // Always push, even if tray_id is empty (for draft restoration)
    accepted_trays.push({ 
      tray_id, 
      qty, 
      tray_qty: qty,  // ✅ Alias for compatibility
      sequence: idx + 1 
    });
  });

  // Get acceptance remarks
  const acceptanceRemarksInput = document.getElementById('acceptanceRemarksInput');
  const acceptance_remarks = acceptanceRemarksInput ? acceptanceRemarksInput.value.trim() : '';

  // ✅ Relaxed validation: Accept partial data for drafts
  if (!acceptance_remarks && tray_rejections.length === 0 && accepted_trays.filter(t => t.tray_id).length === 0) {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Please enter some data before saving draft.";
    }
    draftButton.disabled = false;
    return;
  }

  // ✅ Create comprehensive draft data structure
  const draftData = {
    is_draft: true,
    batch_rejection: false,
    tray_rejections: tray_rejections,
    tray_id_mappings: tray_id_mappings,
    accepted_trays: accepted_trays,
    acceptance_remarks: acceptance_remarks,
    timestamp: new Date().toISOString()
  };

  // ✅ Use new unified draft API
  fetch('/iqf/iqf_set_manual_draft/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      lot_id: stockLotId,
      batch_id: batchId,
      draft_type: 'tray_rejection',
      draft_data: draftData
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = "Manual draft saved successfully!";
      }
      setTimeout(() => {
        window.location.reload();
      }, 1500);
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save manual draft";
      }
      draftButton.disabled = false;
    }
  });
}

function loadLotRejectionDraft(draftData) {
  console.log("🚩 loadLotRejectionDraft called", draftData);
  const remarksInput = document.getElementById('lotRejectionRemarksInput');
  const remarksSection = document.getElementById('lotRejectionRemarksSection');
  if (remarksSection) {
    remarksSection.style.display = "block";
  }
  if (remarksInput && draftData && draftData.lot_rejected_comment) {
    remarksInput.value = draftData.lot_rejected_comment;
    console.log("Lot Rejection Draft loaded, remarks value:", draftData.lot_rejected_comment);
    console.log("Textarea current value:", remarksInput.value);
  } else {
    console.log("Lot Rejection Draft: remarksInput or lot_rejected_comment missing", {remarksInput, draftData});
  }
  const totalQtyElement = document.getElementById('rejection-total-qty');
  if (totalQtyElement && draftData && draftData.total_qty) {
    totalQtyElement.textContent = draftData.total_qty;
  }
}

// ✅ DUPLICATE FUNCTION REMOVED - Using the enhanced version above with proper preservation logic

// Add editable form event listeners
function addEditableFormEventListeners(row, batchId, stockLotId) {
  const availableQty = parseInt(row.getAttribute('data-available-qty'), 10) || 0;        
  document.querySelectorAll('.rejection-qty-input').forEach(function(input, idx, allInputs) {
    input.addEventListener('input', function() {
      document.querySelectorAll('.qty-error').forEach(function(span) { span.remove(); });

      let total = 0;
      let errorRow = null;
      let errorInput = null;

      allInputs.forEach(function(qtyInput, i) {
        const val = parseInt(qtyInput.value) || 0;
        total += val;
        if (!errorRow && total > availableQty) {
          errorRow = i + 1;
          errorInput = qtyInput;
        }
      });

      document.getElementById('rejection-total-qty').textContent = total;

      if (errorInput) {
        let errorSpan = document.createElement('span');
        errorSpan.className = 'qty-error';
        errorSpan.style.color = '#d32f2f';
        errorSpan.style.fontSize = '12px';
        errorSpan.style.display = 'block';
        errorSpan.style.marginTop = '2px';
        errorSpan.textContent = `Row ${errorRow}: Quantity exceeds available (${availableQty}).`;
        errorInput.parentElement.appendChild(errorSpan);
      }
    });
  });
}

// Existing modal close event listeners
closeTrayBtn.addEventListener("click", () => {
  trayModal.classList.remove("open");
});

trayModal.addEventListener("click", (event) => {
  if (event.target === trayModal) {
    trayModal.classList.remove("open");
  }
});

closeNewPopupBtn.addEventListener("click", () => {
  newPopupModal.classList.remove("open");
});

});
</script>

<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      document.querySelectorAll('.ip-checkbox').forEach(function (checkbox) {
        const row = checkbox.closest('tr');
        const lotQtySpan = row.querySelector('.lot-qty');
        const totalQty = parseInt(lotQtySpan.textContent.trim(), 10);
        const missingQtyInput = row.querySelector('.missing-qty-input');
        const physicalQtyInput = row.querySelector('.physical-qty-input');
    
        // Enable input on page load if not checked/disabled
        if (!checkbox.checked && !checkbox.disabled) {
          missingQtyInput.disabled = false;
        }
    
        // Live update physical qty as user types
        missingQtyInput.addEventListener('input', function () {
          let missingQty = parseInt(missingQtyInput.value, 10);
          if (isNaN(missingQty) || missingQty < 0) {
            physicalQtyInput.value = totalQty;
            return;
          }
          if (missingQty > totalQty) {
            missingQtyInput.value = totalQty;
            missingQty = totalQty;
          }
          physicalQtyInput.value = totalQty - missingQty;
        });
    
        checkbox.addEventListener('change', function () {
          if (checkbox.checked && !checkbox.disabled) {
            missingQtyInput.disabled = false;
            missingQtyInput.focus();
          } else {
            missingQtyInput.value = '';
            missingQtyInput.disabled = false;
            if (physicalQtyInput) physicalQtyInput.value = totalQty;
          }
        });
    
        // Save on checkbox check
        checkbox.addEventListener('change', function () {
          if (!checkbox.checked || checkbox.disabled) return;
          const lotId = checkbox.getAttribute('data-lot-id');
          let missingQty = missingQtyInput.value.trim();
          if (!lotId) {
            Swal.fire('Error', 'Lot ID not found.', 'error');
            checkbox.checked = false;
            return;
          }
          if (!missingQty || isNaN(missingQty) || parseInt(missingQty) < 0) {
            Swal.fire('Error', 'Enter a valid missing quantity.', 'error');
            checkbox.checked = false;
            return;
          }
          fetch('/iqf/iqf_save_ip_checkbox/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
              lot_id: lotId,
              missing_qty: missingQty
            })
          })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              checkbox.checked = true;
              checkbox.disabled = true;
              missingQtyInput.disabled = true;
              // Update physical qty
              if (physicalQtyInput) {
                physicalQtyInput.value = totalQty - parseInt(missingQty);
              }
              // Update process status icon to green
              const processIcons = row.querySelectorAll('.d-flex > div');
              if (processIcons.length > 0) {
                processIcons[0].style.backgroundColor = '#0c8249';
              }
             

              

              // Enable Accept and Reject buttons
              const acceptBtn = row.querySelector('.btn-twitter');
              const rejectBtn = row.querySelector('.btn-youtube');
              if (acceptBtn) acceptBtn.disabled = false;
              if (rejectBtn) rejectBtn.disabled = false;

                window.location.reload();

            } else {
              Swal.fire('Error', data.error || 'Failed to save checkbox', 'error');
              checkbox.checked = false;
            }
          })
          .catch(() => {
            Swal.fire('Error', 'Network error', 'error');
            checkbox.checked = false;
          });
        });
      });
    });
</script>

<!--Accept functionality - Updated with confirmation dialog like IS_PickTable-->
<script nonce="{{csp_nonce}}">
console.log('🚀 Starting Accept Button Debug Script');

document.addEventListener("DOMContentLoaded", function () {
    console.log('📋 DOM Content Loaded - Starting Debug');
    
    const acceptButtons = document.querySelectorAll('.btn-twitter');
    console.log('🔍 Found accept buttons:', acceptButtons.length);
    
    setTimeout(() => {
        console.log('⏰ Timeout reached, initializing...');
        initializeAcceptFunctionality();
    }, 1000);
});

function initializeAcceptFunctionality() {
    console.log('🎬 Initializing Accept Functionality');
    
    addDelinkModal();
    addDelinkStyles();
    
    setTimeout(() => {
        setupAcceptButtons();
    }, 100);
}

function addDelinkStyles() {
    console.log('🎨 Adding Compact Delink Styles');
    
    if (document.getElementById('delink-styles')) {
        console.log('⚠️ Styles already exist, skipping');
        return;
    }
    
    const delinkModalCSS = `
    .delink-modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
    }

    .delink-modal-content {
        background-color: #fff;
        margin: 8% auto;
        padding: 15px;
        border: none;
        border-radius: 8px;
        width: 85%;
        max-width: 450px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }

    .delink-close {
        color: #aaa;
        float: right;
        font-size: 22px;
        font-weight: bold;
        cursor: pointer;
    }

    .delink-close:hover {
        color: #000;
    }

    .delink-table, .top-tray-table {
        width: 100%;
        border-collapse: collapse;
        margin: 8px 0;
        border-radius: 6px;
        overflow: hidden;
        font-size: 12px;
    }

    .delink-table th {
        background: #e74c3c;
        color: white;
        padding: 6px 8px;
        text-align: center;
        font-weight: 600;
        font-size: 11px;
    }

    .delink-table td {
        padding: 4px;
        text-align: center;
        border: 1px solid #ddd;
        background: #f9f9f9;
    }

    .top-tray-table th {
        background: #27ae60;
        color: white;
        padding: 6px 8px;
        text-align: center;
        font-weight: 600;
        font-size: 11px;
    }

    .top-tray-table td {
        padding: 4px;
        text-align: center;
        border: 1px solid #ddd;
        background: #f8fff8;
    }

    .delink-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
        padding: 10px 0;
    }

    .delink-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 20px;
        font-weight: 600;
        cursor: pointer;
        font-size: 12px;
        min-width: 80px;
    }

    .delink-btn-confirm {
        background: #27ae60;
        color: white;
    }

    .delink-btn-confirm:disabled {
        background: #95a5a6;
        cursor: not-allowed;
        opacity: 0.5;
    }

    .delink-btn-cancel {
        background: #95a5a6;
        color: white;
    }

    .section-header {
        background: #f8f9fa;
        padding: 6px 10px;
        border-radius: 4px;
        margin: 8px 0 6px 0;
        border-left: 3px solid #028084;
        font-weight: 600;
        color: #2c3e50;
        font-size: 14px;
    }

    .missing-qty-info {
        background: #fff3cd;
        border: 2px solid #ffc107;
        border-radius: 6px;
        padding: 8px 12px;
        margin: 8px 0;
        color: #856404;
        font-weight: 600;
        text-align: center;
        font-size: 13px;
    }

    .loading-spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #028084;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 8px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .error-message {
        background: #ffebee;
        border: 2px solid #f44336;
        color: #c62828;
        padding: 8px 12px;
        border-radius: 4px;
        margin: 8px 0;
        text-align: center;
        font-weight: 600;
        font-size: 12px;
    }

    .tray-id-error {
        font-size: 10px;
        margin-top: 2px;
        padding: 2px 4px;
        border-radius: 3px;
        font-weight: 600;
    }
    `;
    
    const styleSheet = document.createElement("style");
    styleSheet.id = 'delink-styles';
    styleSheet.textContent = delinkModalCSS;
    document.head.appendChild(styleSheet);
    console.log('✅ Compact styles added successfully');
}

function addDelinkModal() {
    console.log('🏗️ Adding Compact Delink Modal');
    
    if (document.getElementById('delinkModal')) {
        console.log('⚠️ Modal already exists, skipping');
        return;
    }
    
    const modalHTML = `
    <div id="delinkModal" class="delink-modal">
        <div class="delink-modal-content">
            <span class="delink-close" id="closeDelinkModal">&times;</span>
            
            <h2 style="text-align: center; color: #2c3e50; margin: 0 0 12px 0; font-size: 16px; font-weight: 600;">
                Delink Confirmation
            </h2>
            
            <div class="missing-qty-info">
                <i class="fa fa-info-circle" style="margin-right: 4px;"></i>
                Missing Quantity: <span id="delinkMissingQty">0</span> pieces detected
            </div>
            
            <div id="delinkLoadingDiv" style="text-align: center; padding: 15px;">
                <div class="loading-spinner"></div>
                Calculating delink requirements...
            </div>
            
            <div id="delinkContentDiv" style="display: none;">
                <div id="delinkTraysSection" style="display: none;">
                    <div class="section-header">
                        <i class="fa fa-unlink" style="margin-right: 6px; color: #e74c3c; font-size: 12px;"></i>
                        Trays to Delink (<span id="delinkCount">0</span> trays)
                    </div>
                    <table class="delink-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">S.No</th>
                                <th>Tray ID</th>
                            </tr>
                        </thead>
                        <tbody id="delinkTableBody">
                        </tbody>
                    </table>
                </div>
                
                <div id="topTraySection" style="display: none;">
                    <div class="section-header">
                        <i class="fa fa-layer-group" style="margin-right: 6px; color: #27ae60; font-size: 12px;"></i>
                        Top Tray (Partial)
                    </div>
                    <table class="top-tray-table">
                        <thead>
                            <tr>
                                <th>Tray ID</th>
                                <th style="width: 60px;">Remaining Qty</th>
                            </tr>
                        </thead>
                        <tbody id="topTrayTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div id="delinkErrorDiv" class="error-message" style="display: none;">
            </div>
            
            <div class="delink-buttons">
                <button id="confirmDelinkBtn" class="delink-btn delink-btn-confirm" style="display: none;" disabled>
                    <i class="fa fa-check" style="margin-right: 4px;"></i>
                    Confirm Delink & Accept
                </button>
                <button id="cancelDelinkBtn" class="delink-btn delink-btn-cancel">
                    <i class="fa fa-times" style="margin-right: 4px;"></i>
                    Cancel
                </button>
            </div>
        </div>
    </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    console.log('✅ Compact modal added successfully');
    
    setupModalEventListeners();
}

function setupAcceptButtons() {
    console.log('🔧 Setting up Accept Buttons');
    
    const acceptButtons = document.querySelectorAll('.btn-twitter');
    console.log(`🎯 Found ${acceptButtons.length} accept buttons`);
    
    if (acceptButtons.length === 0) {
        console.error('❌ No accept buttons found!');
        return;
    }
    
    acceptButtons.forEach((acceptBtn, index) => {
        console.log(`🔄 Setting up button ${index}:`, acceptBtn);
        
        const newBtn = acceptBtn.cloneNode(true);
        acceptBtn.parentNode.replaceChild(newBtn, acceptBtn);
        
        newBtn.addEventListener('click', function(event) {
            console.log('🖱️ Accept button clicked!', event);
            
            event.preventDefault();
            event.stopPropagation();
            
            if (newBtn.disabled) {
                console.log('⚠️ Button is disabled, ignoring click');
                return;
            }
            
            handleAcceptButtonClick(newBtn);
        });
        
        console.log(`✅ Button ${index} setup complete`);
    });
    
    console.log('🎉 All accept buttons setup complete');
}

function handleAcceptButtonClick(acceptBtn) {
    console.log('🎬 Handling accept button click');
    
    const row = acceptBtn.closest('tr');
    console.log('📍 Found row:', row);
    
    let lotId = acceptBtn.getAttribute('data-lot-id');
    console.log('🏷️ Lot ID from button:', lotId);
    
    if (!lotId) {
        const checkbox = row ? row.querySelector('.brass-checkbox') : null;
        lotId = checkbox ? checkbox.getAttribute('data-lot-id') : null;
        console.log('🏷️ Lot ID from checkbox:', lotId);
    }
    
    if (!lotId) {
        lotId = row ? row.getAttribute('data-stock-lot-id') : null;
        console.log('🏷️ Lot ID from row:', lotId);
    }
    
    if (!lotId) {
        console.error('❌ Lot ID not found!');
        showAlert('Error', 'Lot ID not found', 'error');
        return;
    }
    
    console.log('✅ Using Lot ID:', lotId);
    
    const missingQtyInput = row ? row.querySelector('.missing-qty-input') : null;
    const missingQty = missingQtyInput ? parseInt(missingQtyInput.value) || 0 : 0;
    console.log('📊 Missing quantity:', missingQty);
    
    if (missingQty > 0) {
        console.log('🔗 Showing delink modal for missing qty:', missingQty);
        showDelinkModal(lotId, missingQty);
    } else {
        console.log('✅ Showing normal accept confirmation');
        showNormalAcceptConfirmation(lotId);
    }
}

function showAlert(title, text, icon) {
    console.log('🚨 Showing alert:', title, text, icon);
    
    if (typeof Swal !== 'undefined') {
        Swal.fire(title, text, icon);
    } else {
        alert(title + (text ? '\n' + text : ''));
    }
}

function showConfirm(title, text, onConfirm) {
    console.log('❓ Showing confirmation:', title, text);
    
    if (typeof Swal !== 'undefined') {
        Swal.fire({
            title: title,
            text: text,
            icon: 'question',
            showCancelButton: true,
            confirmButtonColor: '#28a745',
            cancelButtonColor: '#6c757d',
            confirmButtonText: 'Yes, Accept',
            cancelButtonText: 'Cancel',
            reverseButtons: true
        }).then((result) => {
            if (result.isConfirmed) {
                onConfirm();
            }
        });
    } else {
        if (confirm(title + '\n' + text)) {
            onConfirm();
        }
    }
}

function showSuccess(title, onComplete) {
    console.log('🎉 Showing success:', title);
    
    if (typeof Swal !== 'undefined') {
        Swal.fire({
            icon: 'success',
            title: title,
            showConfirmButton: false,
            timer: 1200
        }).then(onComplete);
    } else {
        alert(title);
        onComplete();
    }
}

function showNormalAcceptConfirmation(lotId) {
    console.log('📝 Showing normal accept confirmation for lot:', lotId);
    
    showConfirm(
        'Lot Accept', 
        'Are you sure you want to accept this lot?',
        function() {
            console.log('✅ User confirmed accept');
            performAcceptAction(lotId);
        }
    );
}

function showDelinkModal(lotId, missingQty) {
    console.log('🔗 Showing compact delink modal for lot:', lotId, 'missing qty:', missingQty);
    
    const modal = document.getElementById('delinkModal');
    if (!modal) {
        console.error('❌ Delink modal not found!');
        showNormalAcceptConfirmation(lotId);
        return;
    }
    
    const missingQtySpan = document.getElementById('delinkMissingQty');
    const loadingDiv = document.getElementById('delinkLoadingDiv');
    const contentDiv = document.getElementById('delinkContentDiv');
    const errorDiv = document.getElementById('delinkErrorDiv');
    const confirmBtn = document.getElementById('confirmDelinkBtn');
    
    if (missingQtySpan) missingQtySpan.textContent = missingQty;
    if (loadingDiv) loadingDiv.style.display = 'block';
    if (contentDiv) contentDiv.style.display = 'none';
    if (errorDiv) errorDiv.style.display = 'none';
    if (confirmBtn) {
        confirmBtn.style.display = 'none';
        confirmBtn.disabled = true;
    }
    
    modal.style.display = 'block';
    console.log('👁️ Modal should be visible now');
    
    modal.dataset.lotId = lotId;
    modal.dataset.missingQty = missingQty;
    
    fetchDelinkCalculation(lotId, missingQty);
}

function fetchDelinkCalculation(lotId, missingQty) {
    console.log('📡 Fetching delink calculation for lot:', lotId, 'missing qty:', missingQty);
    
    const loadingDiv = document.getElementById('delinkLoadingDiv');
    const contentDiv = document.getElementById('delinkContentDiv');
    const errorDiv = document.getElementById('delinkErrorDiv');
    const confirmBtn = document.getElementById('confirmDelinkBtn');
    
    const apiUrl = `/iqf/iqf_tray_delink_top_tray_calc/?lot_id=${encodeURIComponent(lotId)}&missing_qty=${missingQty}`;
    console.log('🌐 API URL:', apiUrl);
    
    fetch(apiUrl)
        .then(response => {
            console.log('📥 API Response status:', response.status);
            return response.json();
        })
        .then(data => {
            console.log('📊 API Response data:', data);
            
            if (loadingDiv) loadingDiv.style.display = 'none';
            
            if (data.success) {
                populateDelinkTables(data);
                if (contentDiv) contentDiv.style.display = 'block';
                if (confirmBtn) confirmBtn.style.display = 'inline-block';
            } else {
                showDelinkError(data.error || 'Failed to calculate delink requirements');
            }
        })
        .catch(error => {
            console.error('❌ API Error:', error);
            if (loadingDiv) loadingDiv.style.display = 'none';
            showDelinkError('Network error while calculating delink requirements.');
        });
}

function populateDelinkTables(data) {
    console.log('📋 Populating compact delink tables with data:', data);
    
    const delinkTraysSection = document.getElementById('delinkTraysSection');
    const topTraySection = document.getElementById('topTraySection');
    const delinkTableBody = document.getElementById('delinkTableBody');
    const topTrayTableBody = document.getElementById('topTrayTableBody');
    const delinkCountSpan = document.getElementById('delinkCount');
    
    if (delinkTableBody) delinkTableBody.innerHTML = '';
    if (topTrayTableBody) topTrayTableBody.innerHTML = '';
    
    // Compact Delink Trays Section
    if (data.delink_trays && data.delink_trays.length > 0) {
        if (delinkCountSpan) delinkCountSpan.textContent = data.delink_count || data.delink_trays.length;
        data.delink_trays.forEach((_, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td style="font-weight: 600; background: #ffebee; padding: 4px; font-size: 12px; width: 40px;">${index + 1}</td>
                <td style="padding: 4px;">
                    <input type="text" class="form-control delink-tray-input" value="" placeholder="Scan Tray ID" autocomplete="off" style="width: 100%; padding: 6px; font-size: 12px; height: 28px;" />
                    <div class="tray-id-error" style="display: none; font-size: 10px; margin-top: 2px;"></div>
                </td>
            `;
            if (delinkTableBody) delinkTableBody.appendChild(row);
        });
        if (delinkTraysSection) delinkTraysSection.style.display = 'block';
    } else {
        if (delinkTraysSection) delinkTraysSection.style.display = 'none';
    }

    // Compact Top Tray Section
    if (data.top_tray) {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td style="padding: 4px;">
                <input type="text" id="topTrayIdInput" class="form-control" value="" placeholder="Scan Top Tray ID" autocomplete="off" style="width: 100%; padding: 6px; font-size: 12px; height: 28px;" />
                <div class="tray-id-error" style="display: none; font-size: 10px; margin-top: 2px;"></div>
            </td>
            <td style="font-weight: 600; color: #2e7d32; padding: 4px; font-size: 12px; text-align: center; width: 60px;">${data.top_tray.qty}</td>
        `;
        if (topTrayTableBody) topTrayTableBody.appendChild(row);
        if (topTraySection) topTraySection.style.display = 'block';
    } else {
        if (topTraySection) topTraySection.style.display = 'none';
    }

    setTimeout(() => {
        attachValidationToInputs();
    }, 100);
}



function getCurrentLotId() {
    const modal = document.getElementById('delinkModal');
    if (modal && modal.dataset.lotId) {
        return modal.dataset.lotId;
    }
    
    const acceptButtons = document.querySelectorAll('.btn-twitter');
    if (acceptButtons.length > 0) {
        const firstButton = acceptButtons[0];
        let lotId = firstButton.getAttribute('data-lot-id');
        
        if (!lotId) {
            const row = firstButton.closest('tr');
            const checkbox = row ? row.querySelector('.brass-checkbox') : null;
            lotId = checkbox ? checkbox.getAttribute('data-lot-id') : null;
        }
        
        if (!lotId) {
            const row = firstButton.closest('tr');
            lotId = row ? row.getAttribute('data-stock-lot-id') : null;
        }
        
        return lotId;
    }
    
    return null;
}

function validateAllInputsAndUpdateButtons() {
    const confirmBtn = document.getElementById('confirmDelinkBtn');
    if (!confirmBtn) return;
    
    const allInputs = document.querySelectorAll('.delink-tray-input, #topTrayIdInput');
    let hasErrors = false;
    let hasEmptyInputs = false;
    
    allInputs.forEach(input => {
        if (input._hasError) {
            hasErrors = true;
        }
        if (!input.value.trim()) {
            hasEmptyInputs = true;
        }
    });
    
    if (hasErrors || hasEmptyInputs) {
        confirmBtn.disabled = true;
        confirmBtn.style.opacity = '0.5';
        confirmBtn.style.cursor = 'not-allowed';
    } else {
        confirmBtn.disabled = false;
        confirmBtn.style.opacity = '1';
        confirmBtn.style.cursor = 'pointer';
    }
}

function showDelinkError(message) {
    console.log('❌ Showing delink error:', message);
    
    const errorDiv = document.getElementById('delinkErrorDiv');
    if (errorDiv) {
        errorDiv.innerHTML = `<i class="fa fa-exclamation-triangle" style="margin-right: 4px;"></i>${message}`;
        errorDiv.style.display = 'block';
    }
}

function performAcceptAction(lotId) {
    console.log('🎯 Performing accept action for lot:', lotId);
    
    fetch('/iqf/iqf_accepted_form/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({ stock_lot_id: lotId })
    })
    .then(res => {
        console.log('📥 Accept API Response status:', res.status);
        
        if (res.redirected) {
            console.log('🔄 Redirected to:', res.url);
            window.location.href = res.url;
            return;
        }
        return res.json();
    })
    .then(data => {
        console.log('📊 Accept API Response data:', data);
        
        if (data && data.success) {
            showSuccess('Accepted successfully!', function() {
                window.location.reload();
            });
        } else if (data && data.error) {
            showAlert('Error', data.error, 'error');
        }
    })
    .catch(error => {
        console.error('❌ Accept API Error:', error);
        showAlert('Error', 'Network error', 'error');
    });
}

function setupModalEventListeners() {
    console.log('🎪 Setting up modal event listeners');
    
    const delinkModal = document.getElementById('delinkModal');
    const closeDelinkModal = document.getElementById('closeDelinkModal');
    const cancelDelinkBtn = document.getElementById('cancelDelinkBtn');
    const confirmDelinkBtn = document.getElementById('confirmDelinkBtn');
    
    if (closeDelinkModal) {
        closeDelinkModal.addEventListener('click', function() {
            console.log('❌ Close button clicked');
            if (delinkModal) delinkModal.style.display = 'none';
        });
    }
    
    if (cancelDelinkBtn) {
        cancelDelinkBtn.addEventListener('click', function() {
            console.log('🚫 Cancel button clicked');
            if (delinkModal) delinkModal.style.display = 'none';
        });
    }
    
    if (delinkModal) {
        delinkModal.addEventListener('click', function(event) {
            if (event.target === delinkModal) {
                console.log('🖱️ Clicked outside modal, closing');
                delinkModal.style.display = 'none';
            }
        });
    }
    
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape' && delinkModal && delinkModal.style.display === 'block') {
            console.log('⌨️ ESC key pressed, closing modal');
            delinkModal.style.display = 'none';
        }
    });
    
    if (confirmDelinkBtn) {
        confirmDelinkBtn.addEventListener('click', function() {
            console.log('✅ Confirm delink button clicked');
            
            const lotId = delinkModal ? delinkModal.dataset.lotId : null;
            const missingQty = delinkModal ? delinkModal.dataset.missingQty : null;
            
            console.log('📊 Confirming delink for lot:', lotId, 'missing qty:', missingQty);
            
            if (!lotId) {
                showAlert('Error', 'Lot ID not found', 'error');
                return;
            }
            
            const delinkTrayInputs = document.querySelectorAll('.delink-tray-input');
            const topTrayInput = document.getElementById('topTrayIdInput');
            
            const delinkTrayIds = Array.from(delinkTrayInputs).map(input => input.value.trim()).filter(id => id);
            const topTrayId = topTrayInput ? topTrayInput.value.trim() : '';
            
            const topTrayQtyElement = document.querySelector('#topTrayTableBody td:last-child');
            const topTrayQty = topTrayQtyElement ? topTrayQtyElement.textContent.trim() : '';
            
            console.log('📝 Collected tray IDs:', { delinkTrayIds, topTrayId, topTrayQty });
            
            if (delinkModal) delinkModal.style.display = 'none';
            
            showConfirm(
                'Confirm Delink & Accept',
                `This will delink ${missingQty} pieces and accept the remaining lot. Are you sure?`,
                function() {
                    performDelinkAcceptAction(lotId, delinkTrayIds, topTrayId, topTrayQty);
                }
            );
        });
    }
    
    console.log('✅ Modal event listeners setup complete');
}

function performDelinkAcceptAction(lotId, delinkTrayIds, topTrayId, topTrayQty) {
    console.log('🎯 Performing delink accept action:', { lotId, delinkTrayIds, topTrayId, topTrayQty });

    let parsedTopTrayQty = null;
    if (topTrayQty && topTrayQty !== '') {
        parsedTopTrayQty = parseInt(topTrayQty, 10);
        if (isNaN(parsedTopTrayQty)) {
            console.error('❌ Invalid top tray quantity:', topTrayQty);
            showAlert('Error', 'Invalid top tray quantity', 'error');
            return;
        }
    }

    const payload = {
        lot_id: lotId,
        delink_tray_ids: delinkTrayIds,
        top_tray_id: topTrayId,
        top_tray_qty: parsedTopTrayQty
    };

    console.log('📤 Sending delink payload:', payload);

    fetch('/iqf/iqf_tray_delink_and_top_tray_update/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(payload)
    })
    .then(res => res.json())
    .then(data => {
        console.log('📊 Delink & Top Tray Update API Response:', data);
        if (data && data.success) {
            console.log('✅ Delink successful, now calling accept API...');
            
            return fetch('/iqf/iqf_accepted_form/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ stock_lot_id: lotId })
            });
        } else {
            throw new Error(data.error || 'Failed to update trays');
        }
    })
    .then(res => {
        console.log('📥 Accept API Response status:', res.status);
        
        if (res.redirected) {
            console.log('🔄 Redirected to:', res.url);
            window.location.href = res.url;
            return;
        }
        return res.json();
    })
    .then(data => {
        console.log('📊 Accept API Response data:', data);
        
        if (data && data.success) {
            showSuccess('Delink and Accept completed successfully!', function() {
                window.location.reload();
            });
        } else if (data && data.error) {
            showAlert('Error', 'Delink successful but accept failed: ' + data.error, 'error');
        }
    })
    .catch(error => {
        console.error('❌ Delink or Accept API Error:', error);
        showAlert('Error', error.message || 'Network error during operation', 'error');
    });
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

console.log('📝 Compact script loaded, waiting for DOM...');
</script>

<script nonce="{{ csp_nonce }}">
      document.addEventListener("DOMContentLoaded", function () {
      
        const cancelBtn = document.getElementById("trayScanCancelBtn");
        if (cancelBtn) {
          cancelBtn.addEventListener("click", function () {
            const modal = document.getElementById("trayScanModal_BQ");
            if (modal) modal.classList.remove("open");
          });
        }
      
         // DELETE BUTTON HANDLER
    document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
        btn.addEventListener('click', function(e) {
          e.preventDefault();
          const row = btn.closest('tr');
          if (!row) return;
          const batchId = btn.getAttribute('data-batch-id');
          const stockLotId = btn.getAttribute('data-stock-lot-id');
          if (!batchId || !stockLotId) {
            Swal.fire('Error', 'Batch ID or Stock Lot ID not found!', 'error');
            return;
          }
          Swal.fire({
            title: 'Are you sure?',
            text: 'Do you really want to delete this batch?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#d33',
            cancelButtonColor: '#3085d6',
            confirmButtonText: 'Yes, delete it!',
            cancelButtonText: 'Cancel'
          }).then((result) => {
            if (result.isConfirmed) {
              fetch('/iqf/iqf_delete_batch/', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ batch_id: batchId, stock_lot_id: stockLotId })
              })
              .then(res => res.json())
              .then(data => {
                if (data.success) {
                  row.remove();
                  Swal.fire({
                    icon: 'success',
                    title: 'Deleted!',
                    text: 'Batch has been deleted.',
                    timer: 1200,
                    showConfirmButton: false
                  });                  
                } else {
                  Swal.fire('Error', data.error || 'Delete failed', 'error');
                }
              });
            }
          });
        });
      });
      

// Helper function to show success notification (same as main script)
function showSuccessNotification(message) {
  // Create or get existing notification element
  let notification = document.getElementById('success-notification');
  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'success-notification';
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #28a745;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10001;
      font-weight: 500;
      transform: translateX(400px);
      transition: transform 0.3s ease;
    `;
    document.body.appendChild(notification);
  }
  
  notification.textContent = message;
  
  // Show notification
  setTimeout(() => {
    notification.style.transform = 'translateX(0)';
  }, 100);
  
  // Hide notification after 3 seconds
  setTimeout(() => {
    notification.style.transform = 'translateX(400px)';
  }, 3000);
}

// Helper function to show error notification
function showErrorNotification(message) {
  // Create or get existing notification element
  let notification = document.getElementById('error-notification');
  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'error-notification';
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #dc3545;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(220,53,69,0.15);
      z-index: 10001;
      font-weight: 500;
      transform: translateX(400px);
      transition: transform 0.3s ease;
    `;
    document.body.appendChild(notification);
  }
  
  notification.textContent = message;
  
  // Show notification
  setTimeout(() => {
    notification.style.transform = 'translateX(0)';
  }, 100);
  
  // Hide notification after 4 seconds (longer for errors)
  setTimeout(() => {
    notification.style.transform = 'translateX(400px)';
  }, 4000);
}

const table = document.getElementById("order-listing");
        if (!table) {
          console.warn("Table with ID 'order-listing' not found.");
          return;
        }
      
        const headers = table.querySelectorAll("thead th");
        const tbody = table.querySelector("tbody");
      
        let sortDirection = {};
      
        headers.forEach((header, index) => {
          header.style.cursor = "pointer";
      
          header.addEventListener("click", function () {
            const rows = Array.from(tbody.querySelectorAll("tr"));
            const dir = sortDirection[index] === "asc" ? "desc" : "asc";
            sortDirection[index] = dir;
      
            rows.sort((a, b) => {
              const cellA = a.children[index].textContent.trim();
              const cellB = b.children[index].textContent.trim();
              const valA = isNaN(cellA) ? cellA : parseFloat(cellA);
              const valB = isNaN(cellB) ? cellB : parseFloat(cellB);
      
              if (valA < valB) return dir === "asc" ? -1 : 1;
              if (valA > valB) return dir === "asc" ? 1 : -1;
              return 0;
            });
      
            tbody.innerHTML = "";
            rows.forEach((row) => tbody.appendChild(row));
          });
        });
      });
</script>
<!-- Script for Tray Scan - Modal Popup -->
<script nonce="{{ csp_nonce }}">
      // Helper to get CSRF token
      function getCookie(name) {
          let cookieValue = null;
          if (document.cookie && document.cookie !== '') {
              const cookies = document.cookie.split(';');
              for (let i = 0; i < cookies.length; i++) {
                  const cookie = cookies[i].trim();
                  if (cookie.substring(0, name.length + 1) === (name + '=')) {
                      cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                      break;
                  }
              }
          }
          return cookieValue;
      }
      
      document.addEventListener("DOMContentLoaded", () => {
          const trayScanLinks = document.querySelectorAll(".tray-scan-btn-BQ");
          const modal = document.getElementById("trayScanModal_BQ");
          const closeBtn = document.getElementById("closetrayScanModal_BQ");
          const detailsDiv = document.getElementById("trayScanDetails_BQ");
          const modalModelNo = document.getElementById("modalModelNo");
      
          trayScanLinks.forEach((link) => {
              link.addEventListener("click", async (event) => {
                  event.preventDefault();
                  window.currentTrayScanBatchId = event.target.getAttribute("data-batch-id");
      
                  const row = event.target.closest("tr");
                  if (!row) return;
      
                  
      
                  // Get dynamic data from the clicked row
                  const batchId = event.target.getAttribute("data-batch-id");
                  const modelNo = event.target.getAttribute("data-model-no");
                  const noOfTrays = parseInt(event.target.getAttribute("data-no-of-trays")) || 0;
                  const trayCapacity = event.target.getAttribute("data-tray-capacity") || "";
      
                  // Highlight the clicked row
                  document.querySelectorAll("tbody tr").forEach((row) => {
                      row.classList.remove("highlighted-tray-scan");
                  });
                  row.classList.add("highlighted-tray-scan");
      
                  // Update modal with dynamic model number
                  if (modalModelNo && modelNo) {
                      modalModelNo.textContent = modelNo;
                  }
      
                  // Try to fetch DraftTrayId data first, fallback to TrayId
                  let traysData = [];
                  let isDraft = false;
                  try {
                      const draftResp = await fetch(`/dayplanning/draft_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
                      const draftResult = await draftResp.json();
                      if (draftResult.success && Array.isArray(draftResult.trays) && draftResult.trays.length > 0) {
                          traysData = draftResult.trays;
                          isDraft = true;
                      } else {
                          // Fallback to TrayId (readonly)
                          const resp = await fetch(`/dayplanning/tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
                          const result = await resp.json();
                          if (result.success && Array.isArray(result.trays) && result.trays.length > 0) {
                              traysData = result.trays;
                              isDraft = false;
                          }
                      }
                  } catch (e) {
                      // Ignore fetch errors, fallback to default
                  }
      
                  let html = `
                      <div>S.no</div>
                      <div>Tray ID</div>
                      <div>Tray Qty</div>
                      <div>Tray Validation Status</div>
                  `;
      
                  let showButtons = true;
      
                                // ...existing code...
                  let trayQtyList = [];
                  try {
                      trayQtyList = JSON.parse(event.target.getAttribute("data-tray-qty-list") || "[]");
                  } catch (e) {
                      trayQtyList = [];
                  }
                  let totalRows = noOfTrays;
                  for (let i = 0; i < totalRows; i++) {
                      const tray = traysData[i] || {};
                      const trayQty = tray.tray_quantity || trayQtyList[i] || trayCapacity;
                      html += `
                          <div>${i === 0 ? '1 (Top Tray)' : (i + 1)}</div>
                          <div>
                              <input type="text" class="form-control" value="${tray.tray_id || ''}" data-draft-id="${tray.id || ''}" style="width: 100%;" />
                          </div>
                          <div>
                              <input type="number" class="form-control" value="${trayQty}" style="width: 100%;" ${i === 0 ? '' : 'readonly'} />
                          </div>
                          <div>
                <!-- Tray Validation Status [Pass/Fail] as per the Tray Scan -->
                <span>
            <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
            <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
          </span>
            </div>
                      `;
                  }
                  // ...existing code...
                  showButtons = isDraft || traysData.length === 0;
                  // The unmatched else block is removed to fix the syntax error.
      
                  detailsDiv.innerHTML = html;
      
                  // Auto-focus the first Tray ID input when modal opens
                  const firstTrayIdInput = detailsDiv.querySelector('input[type="text"]:not([readonly])');
                  if (firstTrayIdInput) {
                      firstTrayIdInput.focus();
                      firstTrayIdInput.select();
                  }
                  
                  // ✅ ENHANCED: Attach validation and auto-save to newly created form-control inputs
                  console.log('🔄 [IQF] Attaching validation + auto-save to modal form inputs...');
                  const currentLotId = getCurrentLotId();
                  if (window.IQFTrayValidation && currentLotId) {
                      // Use enhanced modal opening handler
                      window.IQFTrayValidation.onModalOpen(modal, currentLotId);
                  }
      
                 
                  const isReleased = event.target.getAttribute("data-moved-to-d-picker") === "True";
                  
                  // Make all inputs readonly if Released
                  if (isReleased) {
                      detailsDiv.querySelectorAll('input').forEach(inp => inp.setAttribute('readonly', 'readonly'));
                  }
                  
                  // Hide buttons if Released
                  const buttonSection = modal.querySelector('.tray-scan-modal-BQ-content > div[style*="justify-content: center"]');
                  if (buttonSection) {
                      buttonSection.style.display = isReleased ? "none" : (showButtons ? "flex" : "none");
                  }
                  // --- END BLOCK ---
      
                  modal.classList.add("open");
      
                  // Enable editing only when edit icon is clicked (for first tray)
                  const editBtn = detailsDiv.querySelector('.tray-edit-btn');
                  const qtyInput = detailsDiv.querySelector('.tray-qty-input');
                  if (editBtn && qtyInput) {
                      const maxQty = parseInt(qtyInput.value, 10) || 0;
      
                      editBtn.addEventListener('click', function() {
                          qtyInput.removeAttribute('readonly');
                          qtyInput.focus();
                      });
      
                      qtyInput.addEventListener('input', function() {
                          let val = parseInt(qtyInput.value, 10) || 0;
                          if (val > maxQty) {
                              qtyInput.value = maxQty;
                          }
                          if (val < 0) {
                              qtyInput.value = 0;
                          }
                      });
                  }
      
                  // Tray ID validation logic
                  if (!isReleased) {
      
                    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]:not([readonly])');
                    trayIdInputs.forEach((input, idx, allInputs) => {
                        input.addEventListener('input', function () {
                            let prevError = input.parentNode.querySelector('.tray-id-error');
                            if (prevError) prevError.remove();
                        });
        
                        input.addEventListener('blur', async function () {
                            let prevError = input.parentNode.querySelector('.tray-id-error');
                            if (prevError) prevError.remove();
        
                            const trayId = input.value.trim();
                            if (!trayId) return;
        
                            // 1. Check for duplicates in other inputs (in-modal)
                            let duplicateInModal = false;
                            allInputs.forEach((otherInput, otherIdx) => {
                                if (otherIdx !== idx && otherInput.value.trim() === trayId) {
                                    duplicateInModal = true;
                                }
                            });
                            if (duplicateInModal) {
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'tray-id-error';
                                errorDiv.style.color = 'red';
                                errorDiv.style.fontSize = '12px';
                                errorDiv.textContent = 'Already scanned in a row!';
                                input.parentNode.appendChild(errorDiv);
                                input.focus();
                                input.select();
                                return;
                            }
        
                            // 2. Check with backend if tray_id exists in DB
                            try {
                                const resp = await fetch(`/dayplanning/tray_id_unique_check/?tray_id=${encodeURIComponent(trayId)}`);
                                const result = await resp.json();
                                if (result.exists) {
                                    const errorDiv = document.createElement('div');
                                    errorDiv.className = 'tray-id-error';
                                    errorDiv.style.color = 'red';
                                    errorDiv.style.fontSize = '12px';
                                    errorDiv.textContent = 'Tray ID already exists!';
                                    input.parentNode.appendChild(errorDiv);
                                    input.focus();
                                    input.select();
                                }
                            } catch (e) {
                                // Optionally handle network error
                            }
                        });
                        
      
                      input.addEventListener('keydown', async function (e) {
                          if (e.key === 'Enter') {
                              e.preventDefault();
                              input.blur();
                              setTimeout(() => {
                                  if (!input.parentNode.querySelector('.tray-id-error')) {
                                      const nextInput = allInputs[idx + 1];
                                      if (nextInput) {
                                          nextInput.focus();
                                          nextInput.select();
                                      }
                                  } else {
                                      input.focus();
                                      input.select();
                                  }
                              }, 50);
                          }
                      });
                  });
                }
      
                  // Draft button logic
                const draftBtn = document.getElementById('trayScanDraftBtn');
                  if (draftBtn) {
                      draftBtn.onclick = function() {
                          if (detailsDiv.querySelector('.tray-id-error')) {
                              Swal.fire('Error', 'Please fix duplicate Tray IDs before saving draft.', 'error');
                              return;
                          }
                          detailsDiv.querySelectorAll('.tray-id-error').forEach(el => el.remove());
                  
                          const trayRows = [];
                          const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
                          const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
                  
                          for (let i = 0; i < trayIdInputs.length; i++) {
                              const tray_id = trayIdInputs[i].value; // allow empty
                              const tray_quantity = trayQtyInputs[i].value;
                              const draft_id = trayIdInputs[i].getAttribute('data-draft-id') || null;
                              // Always push, even if tray_id is empty
                              trayRows.push({
                                  tray_id,
                                  tray_quantity,
                                  id: draft_id
                              });
                          }
                          const batchId = window.currentTrayScanBatchId || '';
                  
                          fetch('/dayplanning/draft_tray/', {
                              method: 'POST',
                              headers: {
                                  'Content-Type': 'application/json',
                                  'X-CSRFToken': getCookie('csrftoken')
                              },
                              body: JSON.stringify({
                                  batch_id: batchId,
                                  trays: trayRows
                              })
                          })
                          .then(res => res.json())
                          .then(data => {
                              if (data.success) {
                                  // Refetch trays in the same order and re-render
                                  const ids = trayRows.map(tray => tray.id).filter(Boolean);
                                  const params = new URLSearchParams();
                                  params.append('batch_id', batchId);
                                  ids.forEach(id => params.append('ids[]', id));
                                  fetch(`/dayplanning/draft_tray_id_list/?${params.toString()}`)
                                      .then(res => res.json())
                                      .then(data2 => {
                                          if (data2.success && Array.isArray(data2.trays)) {
                                              // Re-render the tray rows in the same order, but keep empty rows too
                                              let html = `
                                                  <div>S.no</div>
                                                  <div>Tray ID</div>
                                                  <div>Tray Qty</div>
                                              `;
                                              let noOfTrays = trayIdInputs.length;
                                            for (let i = 0; i < noOfTrays; i++) {
                                                const tray = data2.trays[i] || {};
                                                html += `
                                                    <div>${i === 0 ? '1 (Top Tray)' : (i + 1)}</div>
                                                    <div>
                                                        <input type="text" class="form-control" value="${tray.tray_id || ''}" data-draft-id="${tray.id || ''}" style="width: 100%;" />
                                                    </div>
                                                    <div>
                                                        <input type="number" class="form-control" value="${tray.tray_quantity || ''}" style="width: 100%;" ${i === 0 ? '' : 'readonly'} />
                                                    </div>
                                                `;
                                            }
      
                                              detailsDiv.innerHTML = html;
                                              Swal.fire({
                                                icon: 'success',
                                                title: 'Success!',
                                                text: 'Draft saved!',
                                                timer: 1200,
                                                showConfirmButton: false
                                              });
                                              modal.classList.remove("open");
                                              // Update the batch status cell in the row
                                              const currentRow = document.querySelector(`.tray-scan-btn-BQ[data-batch-id="${batchId}"]`)?.closest('tr');
                                              if (currentRow) {
                                                  const statusCell = currentRow.querySelector('td:nth-child(13)'); // 13th column is Batch Status
                                                  if (statusCell) {
                                                      statusCell.innerHTML = `
                                                          <div
                                                            class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                                                            style="
                                                              border: 2px solid #4997ac;
                                                              background-color: #d1f2f3;
                                                              color: #03425d;
                                                              font-size: clamp(0.75rem, 2vw, 0.875rem);
                                                              white-space: nowrap;
                                                              padding-top: 0.5rem;
                                                              padding-bottom: 0.5rem;
                                                            "
                                                          >
                                                            On-Hold
                                                          </div>
                                                      `;
                                                  }
                                              }
      
                                          } else {
                                              Swal.fire('Success', 'Draft saved!', 'success');
                                              modal.classList.remove("open");
                                          }
                                      });
                              } else {
                                  Swal.fire('Error', data.error || 'Failed to save draft', 'error');
                              }
                          })
                          .catch(error => {
                              console.error('Error:', error);
                              Swal.fire('Error', 'Network error occurred', 'error');
                          });
                      };
                  }
      
                  
                  // Submit button logic
                const submitBtn = document.getElementById('trayScanSubmitBtn');
                  if (submitBtn) {
                      submitBtn.onclick = function() {
                          if (detailsDiv.querySelector('.tray-id-error')) {
                              Swal.fire('Error', 'Please fix duplicate Tray IDs before submitting.', 'error');
                              return;
                          }
                          detailsDiv.querySelectorAll('.tray-id-error').forEach(el => el.remove());
                  
                          const trayRows = [];
                          const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
                          const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
                          let emptyTrayId = false;
                          for (let i = 0; i < trayIdInputs.length; i++) {
                              const tray_id = trayIdInputs[i].value.trim();
                              const tray_quantity = trayQtyInputs[i].value;
                              // Remove previous error if any
                              let prevError = trayIdInputs[i].parentNode.querySelector('.tray-id-error');
                              if (prevError) prevError.remove();
                              if (!tray_id) {
                                  emptyTrayId = true;
                                  // Show inline error
                                  const errorDiv = document.createElement('div');
                                  errorDiv.className = 'tray-id-error';
                                  errorDiv.style.color = 'red';
                                  errorDiv.style.fontSize = '12px';
                                  errorDiv.textContent = 'Tray ID should not be empty!';
                                  trayIdInputs[i].parentNode.appendChild(errorDiv);
                                  trayIdInputs[i].focus();
                                  break;
                              }
                              trayRows.push({
                                  tray_id,
                                  tray_quantity
                              });
                          }
                          if (emptyTrayId) {
                              return;
                          }
                          const batchId = window.currentTrayScanBatchId || '';
                  
                          fetch('/dayplanning/tray_scan/', {
                              method: 'POST',
                              headers: {
                                  'Content-Type': 'application/json',
                                  'X-CSRFToken': getCookie('csrftoken')
                              },
                              body: JSON.stringify({
                                  batch_id: batchId,
                                  trays: trayRows
                              })
                          })
                          .then(res => res.json())
                          .then(data => {
                              if (data.success) {
                                  Swal.fire({
                                    icon: 'success',
                                    title: 'Success',
                                    text: 'Tray scan saved!',
                                    timer: 1200,
                                    showConfirmButton: false
                                  });
                                  modal.classList.remove("open");
                                  const currentRow = document.querySelector(`.tray-scan-btn-BQ[data-batch-id="${batchId}"]`)?.closest('tr');
                                  if (currentRow) {
                                      const statusCell = currentRow.querySelector('td:nth-child(13)');
                                      if (statusCell) {
                                          statusCell.innerHTML = `
                                              <div
                                                class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                                                style="
                                                  border: 2px solid #0d5d17;
                                                  background-color: #c5f9c2;
                                                  color: #2f801b;
                                                  font-size: clamp(0.75rem, 2vw, 0.875rem);
                                                  white-space: nowrap;
                                                  padding-top: 0.5rem;
                                                  padding-bottom: 0.5rem;
                                                "
                                              >
                                                Yet To Release
                                              </div>
                                          `;
                                      }
                                  }
                                // Disable audio icon
                                const audioIcon = currentRow.querySelector('a[title="Add Audio Remark"]');
                                if (audioIcon) {
                                    const span = document.createElement('span');
                                    span.title = "Disabled after moved";
                                    span.style = "display: inline-flex; align-items: center; height: 28px; margin-left: 0; opacity: 0.5; pointer-events: none;";
                                    span.innerHTML = audioIcon.innerHTML;
                                    audioIcon.replaceWith(span);
                                }
                                // Disable chat icon and textarea
                                const chatIcon = currentRow.querySelector('a[title="Add Remark"]');
                                if (chatIcon) {
                                    const span = document.createElement('span');
                                    span.title = "Disabled after moved";
                                    span.style = "display: inline-flex; align-items: center; height: 20px; margin-left: 5px; opacity: 0.5; pointer-events: none;";
                                    span.innerHTML = chatIcon.innerHTML;
                                    chatIcon.replaceWith(span);
                                }
                                // Make textarea readonly if present
                                const textarea = currentRow.querySelector('textarea');
                                if (textarea) textarea.setAttribute('readonly', true);
                                // Optionally, hide send button if present
                                const sendBtn = currentRow.querySelector('.remark-tooltip button');
                                if (sendBtn) sendBtn.style.display = 'none';
      
                              } else if (data.duplicate_tray_ids) {
                                  trayIdInputs.forEach((input, idx) => {
                                      if (data.duplicate_tray_ids.includes(input.value)) {
                                          const errorDiv = document.createElement('div');
                                          errorDiv.className = 'tray-id-error';
                                          errorDiv.style.color = 'red';
                                          errorDiv.style.fontSize = '12px';
                                          errorDiv.textContent = 'Tray ID already exists!';
                                          input.parentNode.appendChild(errorDiv);
                                      }
                                  });
                                  Swal.fire('Error', 'Duplicate Tray ID(s) found. Please correct.', 'error');
                              } else {
                                  Swal.fire('Error', data.error || 'Failed to save tray scan', 'error');
                              }
                          })
                          .catch(error => {
                              console.error('Error:', error);
                              Swal.fire('Error', 'Network error occurred', 'error');
                          });
                      };
                  }
                
                
              
                });
          });
      
          closeBtn.addEventListener("click", () => {
              modal.classList.remove("open");
          });
      
          modal.addEventListener("click", (event) => {
              if (event.target === modal) {
                  modal.classList.remove("open");
              }
          });
      });
      
      
</script>
   
<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", function (e) {
            e.preventDefault();
            // Find the textarea and get its value
            var textarea = tooltip.querySelector("textarea");
            var remark = textarea ? textarea.value.trim() : "";
            if (!remark) {
              Swal.fire('Error', 'Please enter a remark before sending.', 'error');
              return;
            }
            // Find the batch_id from the row (tr) data attribute or from a hidden field
            var row = trigger.closest("tr");
            var trayScanLink = row ? row.querySelector('.tray-scan-btn') : null;
            var batchId = row ? row.getAttribute('data-batch-id') : null;
            if (!batchId) {
              Swal.fire('Error', 'Batch ID not found.', 'error');
              return;
            }
            fetch('/iqf/iqf_save_ip_pick_remark/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
              },
              body: JSON.stringify({
                batch_id: batchId,
                remark: remark
              })
            })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                Swal.fire({
                  icon: 'success',
                  title: 'Remark saved!',
                  timer: 1200,
                  showConfirmButton: false
                }).then(() => {
                  // Make the textarea readonly
                  if (textarea) {
                    textarea.setAttribute("readonly", true);
                  }

                  // Replace send button with info message
                  if (sendButton && tooltip) {
                    const infoDiv = document.createElement("div");
                    infoDiv.style.marginTop = "40px";
                    infoDiv.style.color = "#31708f";
                    infoDiv.style.background = "#d9edf7";
                    infoDiv.style.border = "1px solid #bce8f1";
                    infoDiv.style.borderRadius = "4px";
                    infoDiv.style.padding = "8px 12px";
                    infoDiv.style.fontSize = "10px";
                    infoDiv.style.textAlign = "left";
                    infoDiv.innerHTML = `
                      <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                      Remark already saved and cannot be edited.
                    `;
                    sendButton.parentNode.replaceChild(infoDiv, sendButton);
                  }
                  // Change chat icon color after remark is saved
                  const chatIcon = trigger.querySelector('img[alt="Chat"]');
                  if (chatIcon) {
                    chatIcon.style.filter = 'grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)';
                    chatIcon.style.opacity = '1';
                  }
                  hideTooltip(); // optional if you still want to hide the tooltip
                });

              } else {
                Swal.fire('Error', data.error || 'Failed to save remark', 'error');
              }
            })
            .catch(() => {
              Swal.fire('Error', 'Network error', 'error');
            });
          });
        }
      });
    });
</script>

<!-- Script for clearing "Tray ID" while hitting "Redo" icon -->
<script nonce="{{ csp_nonce }}">
      document.addEventListener("DOMContentLoaded", function () {
        const redoBtn = document.getElementById("trayScanRedoBtn");
        if (redoBtn) {
          redoBtn.title = "Redo"; // Set tooltip on mouse hover
        }
      
        const detailsDiv = document.getElementById("trayScanDetails_BQ");
        const table = document.getElementById('order-listing');
        let msgBar = document.getElementById('dp-table-msg-bar');
      
        // Create message bar if not present
        if (!msgBar && table) {
          msgBar = document.createElement('div');
          msgBar.id = 'dp-table-msg-bar';
          msgBar.style.display = 'none';
          msgBar.style.width = '100%';
          msgBar.style.margin = '0 0 8px 0';
          msgBar.style.padding = '10px 24px';
          msgBar.style.background = '#d1eaff';
          msgBar.style.color = '#0056b3';
          msgBar.style.fontWeight = 'bold';
          msgBar.style.borderRadius = '8px';
          msgBar.style.fontSize = '1.1rem';
          msgBar.style.textAlign = 'center';
          msgBar.style.transition = 'opacity 0.3s, background 0.3s, color 0.3s';
          table.parentNode.insertBefore(msgBar, table);
        }
      
        // --- FIX: Show alert inside modal form, not on table ---
        let formMsgBar = document.getElementById('tray-id-clear-msg-bar');
        const modal = document.getElementById('trayScanModal_BQ');
        if (!formMsgBar && modal) {
          formMsgBar = document.createElement('div');
          formMsgBar.id = 'tray-id-clear-msg-bar';
          formMsgBar.style.display = 'none';
          formMsgBar.style.width = '100%';
          formMsgBar.style.margin = '0 0 8px 0';
          formMsgBar.style.padding = '8px 16px';
          formMsgBar.style.background = '#ffd6d6';
          formMsgBar.style.color = '#b30000';      // red text
          formMsgBar.style.fontWeight = 'bold';
          formMsgBar.style.borderRadius = '8px';
          formMsgBar.style.fontSize = '14px';      // 14px font
          formMsgBar.style.textAlign = 'center';
          formMsgBar.style.transition = 'opacity 0.3s, background 0.3s, color 0.3s';
          const modalContent = modal.querySelector('.tray-scan-modal-BQ-content');
          if (modalContent) {
            modalContent.insertBefore(formMsgBar, modalContent.firstChild);
          }
        }
        // -------------------------------------------------------
      
        if (redoBtn && detailsDiv) {
          redoBtn.addEventListener("click", function () {
            detailsDiv.querySelectorAll('input[type="text"]').forEach(function(input) {
              input.value = "";
            });
            // Show line alert INSIDE MODAL FORM
            if (formMsgBar) {
              formMsgBar.textContent = "Tray ID Cleared Successfully";
              formMsgBar.style.display = 'block';
              formMsgBar.style.opacity = '1';
              formMsgBar.style.background = '#d1eaff';
              formMsgBar.style.color = '#0056b3';
              setTimeout(function () {
                formMsgBar.style.opacity = '0';
                setTimeout(function () { formMsgBar.style.display = 'none'; }, 300);
              }, 2000);
            }
          });
        }
      });
</script>

<!-- Script for Tray Validate Status column -- enable/disable of table column -->
<script nonce="{{ csp_nonce }}">
      document.addEventListener("DOMContentLoaded", function () {
        const validateBtn = document.getElementById("trayValidateBtn");
        const detailsDiv = document.getElementById("trayScanDetails_BQ");
        let validationEnabled = false;
      
        if (validateBtn && detailsDiv) {
          validateBtn.addEventListener("click", function () {
            validationEnabled = !validationEnabled;
      
            // Toggle header
            const header = detailsDiv.querySelector('.tray-validation-status-header');
            if (header) {
              header.style.opacity = validationEnabled ? "1" : "0.3";
              header.style.pointerEvents = validationEnabled ? "auto" : "none";
            }
      
            // Toggle all cells in the column
            detailsDiv.querySelectorAll('.tray-validation-status-cell').forEach(function(cell) {
              cell.style.opacity = validationEnabled ? "1" : "0.3";
              cell.style.pointerEvents = validationEnabled ? "auto" : "none";
            });
          });
        }
      });
</script>

<!-- Table Sorting Script -->
<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      const table = document.getElementById("order-listing");
      if (!table) return;
      const headers = table.querySelectorAll("thead th");
      const tbody = table.querySelector("tbody");
      let sortDirection = {};
      headers.forEach((header, index) => {
        header.style.cursor = "pointer";
        header.addEventListener("click", function () {
          const rows = Array.from(tbody.querySelectorAll("tr"));
          const dir = sortDirection[index] === "asc" ? "desc" : "asc";
          sortDirection[index] = dir;
          rows.sort((a, b) => {
            const cellA = a.children[index].textContent.trim();
            const cellB = b.children[index].textContent.trim();
            const valA = isNaN(cellA) ? cellA : parseFloat(cellA);
            const valB = isNaN(cellB) ? cellB : parseFloat(cellB);
            if (valA < valB) return dir === "asc" ? -1 : 1;
            if (valA > valB) return dir === "asc" ? 1 : -1;
            return 0;
          });
          tbody.innerHTML = "";
          rows.forEach((row) => tbody.appendChild(row));
        });
      });
    });
</script>

<!-- Script for Text Remarks (unchanged) -->
<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", hideTooltip);
        }
      });
    });
</script>

<!-- Plating Stk - Image hover - fixed position while hitting the Plating Stk No -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  let openTooltip = null;

  // Helper function to completely close a tooltip
  function closeTooltip(tooltip, trigger) {
    if (tooltip) {
      console.log('🔴 Closing tooltip completely');
      
      // Remove pinned class
      tooltip.classList.remove("pinned");
      
      // Hide the entire tooltip completely
      tooltip.style.opacity = "0";
      tooltip.style.pointerEvents = "none";
      tooltip.style.visibility = "hidden";
      tooltip.style.display = "none"; // ✅ ADDED: Force display none
      
      // Hide buttons
      const infoBtn = tooltip.querySelector('.info-btn');
      const closeBtn = tooltip.querySelector('.close-btn');
      if (infoBtn) infoBtn.style.display = 'none';
      if (closeBtn) closeBtn.style.display = 'none';
      
      // Remove visual indicator from trigger
      if (trigger) {
        trigger.style.backgroundColor = '';
        trigger.style.borderRadius = '';
      }
      
      // Clear global reference
      openTooltip = null;
      
      console.log('✅ Tooltip completely closed');
    }
  }

  document.querySelectorAll(".model-image-tooltip .info-btn").forEach(function(btn) {
  btn.addEventListener("click", function(e) {
    e.stopPropagation();
    // Find the closest row
    const row = btn.closest('tr');
    let lotId = null; 
    let batchId = null;
    if (row) {
      lotId = row.getAttribute('data-lot-id');
      batchId = row.getAttribute('data-batch-id');
    }
    // Build the URL with lot_id and batch_id if found
    let url = "/adminportal/dp_visualaid/";
    if (lotId) {
      url += encodeURIComponent(lotId) + "/";
    }
    if (batchId) {
      url += "?batch_id=" + encodeURIComponent(batchId);
    }
    window.location.href = url;
  });
});
  


  // Tooltip show/hide logic
  document.querySelectorAll(".model-hover-trigger").forEach(function (trigger) {
    const tooltip = trigger.querySelector(".model-image-tooltip");

    trigger.addEventListener("mouseenter", function () {
      if (tooltip && !tooltip.classList.contains("pinned")) {
        tooltip.style.display = "flex"; // ✅ ADDED: Reset display
        tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        
        // Show Info and Close buttons on hover
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';
      }
    });

    trigger.addEventListener("mouseleave", function () {
      if (tooltip && !tooltip.classList.contains("pinned")) {
        tooltip.style.opacity = "0";
        tooltip.style.pointerEvents = "none";
        
        // Hide Info and Close buttons when not hovering and not pinned
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'none';
        if (closeBtn) closeBtn.style.display = 'none';
      }
    });

    // Keep tooltip visible when hovering over it
    if (tooltip) {
      tooltip.addEventListener("mouseenter", function () {
        if (!tooltip.classList.contains("pinned")) {
          tooltip.style.display = "flex"; // ✅ ADDED: Reset display
          tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
        }
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        
        // Keep buttons visible when hovering over tooltip
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';
      });

      tooltip.addEventListener("mouseleave", function () {
        if (!tooltip.classList.contains("pinned")) {
          tooltip.style.opacity = "0";
          tooltip.style.pointerEvents = "none";
          
          // Hide buttons when leaving tooltip and not pinned
          const infoBtn = tooltip.querySelector('.info-btn');
          const closeBtn = tooltip.querySelector('.close-btn');
          if (infoBtn) infoBtn.style.display = 'none';
          if (closeBtn) closeBtn.style.display = 'none';
        }
      });
    }

    trigger.addEventListener("click", function (e) {
      e.stopPropagation();

      if (tooltip) {
        // Close any previously opened tooltip
        if (openTooltip && openTooltip !== tooltip) {
          const prevTrigger = openTooltip.closest('.model-hover-trigger');
          closeTooltip(openTooltip, prevTrigger);
        }

        tooltip.classList.add("pinned");
        tooltip.style.display = "flex"; // ✅ ADDED: Ensure display
        tooltip.style.visibility = "visible"; // ✅ ADDED: Ensure visibility
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        openTooltip = tooltip;
        
        // Keep buttons visible when pinned
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';

        // Add visual indicator that tooltip is pinned
        trigger.style.backgroundColor = '#e3f2fd';
        trigger.style.borderRadius = '4px';
      }
    });


    // ✅ FIXED: Handle Close button click - Complete tooltip closure
    const closeBtn = tooltip?.querySelector('.close-btn');
    if (closeBtn) {
      // Initially hide the button
      closeBtn.style.display = 'none';
      
      closeBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        console.log('🔴 Close button clicked');
        
        // Use the helper function to completely close tooltip
        closeTooltip(tooltip, trigger);
        
        // Feedback animation for close button
        closeBtn.style.transform = 'scale(0.9)';
        setTimeout(() => {
          if (closeBtn.style) {
            closeBtn.style.transform = 'scale(1)';
          }
        }, 150);
      });
      
      // ✅ Add hover effect for close button
      closeBtn.addEventListener('mouseenter', function() {
        closeBtn.style.backgroundColor = '#c82333';
        closeBtn.style.transform = 'scale(1.05)';
      });
      
      closeBtn.addEventListener('mouseleave', function() {
        closeBtn.style.backgroundColor = '#dc3545';
        closeBtn.style.transform = 'scale(1)';
      });
    }
  });

  // ✅ ENHANCED: Close tooltip when clicking outside
  document.addEventListener("click", function (e) {
    if (openTooltip && !e.target.closest('.model-image-tooltip') && !e.target.closest('.model-hover-trigger')) {
      const openTrigger = openTooltip.closest('.model-hover-trigger');
      closeTooltip(openTooltip, openTrigger);
    }
  });

  // ✅ Close tooltip with ESC key
  document.addEventListener("keydown", function (e) {
    if (e.key === "Escape" && openTooltip) {
      const openTrigger = openTooltip.closest('.model-hover-trigger');
      closeTooltip(openTooltip, openTrigger);
      console.log('✅ Tooltip closed with ESC key');
    }
  });

  // Prevent tooltip from closing when clicking inside it
  document.querySelectorAll(".model-image-tooltip").forEach(function (tooltip) {
    tooltip.addEventListener("click", function (e) {
      e.stopPropagation();
    });
  });
});
</script>

<!-- Script for Model / Stock No - Image Mouse Hover -->
<script nonce="{{ csp_nonce }}">
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.model-hover-trigger').forEach(function(trigger) {
      const tooltip = trigger.querySelector('.model-image-tooltip');
      let currentIndex = 0;
      let tooltipPinned = false;
      let hoverTimeout = null;
      const images = Array.from(tooltip.querySelectorAll('.img-gallery img'));

      function showImages(start) {
        images.forEach((img, i) => {
          img.style.display = (i >= start && i < start + 3) ? 'block' : 'none';
        });
      }
      showImages(currentIndex);

      // Show immediately on mouseenter
      trigger.addEventListener('mouseenter', function() {
        clearTimeout(hoverTimeout);
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
      });

      // Hide when leaving trigger (unless pinned)
      trigger.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          hoverTimeout = setTimeout(function() {
            if (!tooltip.matches(':hover')) {
              tooltip.style.opacity = '0';
              tooltip.style.pointerEvents = 'none';
            }
          }, 300);
        }
      });

      // Keep visible when hovering over tooltip
      tooltip.addEventListener('mouseenter', function() {
        clearTimeout(hoverTimeout);
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
      });

      // Hide when leaving tooltip (unless pinned)
      tooltip.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          hoverTimeout = setTimeout(function() {
            tooltip.style.opacity = '0';
            tooltip.style.pointerEvents = 'none';
          }, 300);
        }
      });

      // Pin tooltip on click (make it sticky)
      trigger.addEventListener('click', function(e) {
        e.preventDefault();
        tooltipPinned = true;
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
        clearTimeout(hoverTimeout);
        
        // Add visual indicator that it's pinned
        trigger.style.backgroundColor = '#e3f2fd';
        trigger.style.borderRadius = '4px';
      });

      // Unpin tooltip if user clicks outside
      document.addEventListener('mousedown', function(e) {
        if (!trigger.contains(e.target) && !tooltip.contains(e.target)) {
          tooltipPinned = false;
          tooltip.style.opacity = '0';
          tooltip.style.pointerEvents = 'none';
          
          // Remove visual indicator
          trigger.style.backgroundColor = '';
          trigger.style.borderRadius = '';
        }
      });

      // Handle scroll buttons with error handling
      const leftBtn = tooltip.querySelector('.img-scroll-left');
      const rightBtn = tooltip.querySelector('.img-scroll-right');
      
      if (leftBtn) {
        leftBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (currentIndex > 0) {
            currentIndex--;
            showImages(currentIndex);
          }
        });
      }
      
      if (rightBtn) {
        rightBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (currentIndex < images.length - 3) {
            currentIndex++;
            showImages(currentIndex);
          }
        });
      }

      // Add click event to images for modal slider
      images.forEach(function(img, idx) {
        img.style.cursor = 'pointer';
        img.addEventListener('click', function(e) {
          e.stopPropagation();
          openImageSlider(images.map(i => i.src), idx);
        });
      });
    });

    // Modal slider functions
    const modal = document.getElementById("imageSliderModal");
    const closeModal = document.getElementById("closeImageSliderModal");
    const slidesContainer = modal ? modal.querySelector(".slides") : null;
    let sliderImages = [];
    let currentSlide = 0;

    function openImageSlider(srcArray, startIdx) {
      if (!modal || !slidesContainer) return;
      
      sliderImages = srcArray;
      slidesContainer.innerHTML = '';
      sliderImages.forEach(src => {
        const slide = document.createElement('div');
        slide.className = 'slide';
        const img = document.createElement('img');
        img.src = src;
        slide.appendChild(img);
        slidesContainer.appendChild(slide);
      });
      currentSlide = startIdx;
      showSlide(currentSlide);
      modal.classList.add('open');
    }

    function showSlide(n) {
      const slides = slidesContainer ? slidesContainer.querySelectorAll('.slide') : [];
      if (!slides.length) return;
      currentSlide = (n + slides.length) % slides.length;
      slides.forEach((slide, idx) => {
        slide.classList.toggle('active', idx === currentSlide);
      });
    }

    if (modal) {
      const prevBtn = modal.querySelector("#prevBtn");
      const nextBtn = modal.querySelector("#nextBtn");
      
      if (prevBtn) {
        prevBtn.addEventListener("click", function(e) {
          e.stopPropagation();
          showSlide(currentSlide - 1);
        });
      }
      
      if (nextBtn) {
        nextBtn.addEventListener("click", function(e) {
          e.stopPropagation();
          showSlide(currentSlide + 1);
        });
      }
      
      if (closeModal) {
        closeModal.addEventListener("click", function() {
          modal.classList.remove("open");
        });
      }
      
      modal.addEventListener("click", function(e) {
        if (e.target === modal) modal.classList.remove("open");
      });
    }
  });
</script>

<!-- Show alert and highlight row -->
<script nonce="{{ csp_nonce }}">
  // filepath: a:\Workspace\Track_and_Trace_v2\static\templates\Day_Planning\DP_PickTable.html
  document.addEventListener("DOMContentLoaded", function() {
    const table = document.getElementById('order-listing');
    const modal = document.getElementById('trayScanModal');
    const msgBarId = 'dp-table-msg-bar';
    let msgBar = document.getElementById(msgBarId);

    // Create message bar if not present
    if (!msgBar && table) {
      msgBar = document.createElement('div');
      msgBar.id = msgBarId;
      msgBar.style.display = 'none';
      msgBar.style.width = '100%';
      msgBar.style.margin = '0 0 8px 0';
      msgBar.style.padding = '10px 24px';
      msgBar.style.background = '#d1eaff';
      msgBar.style.color = '#0056b3';
      msgBar.style.fontWeight = 'bold';
      msgBar.style.borderRadius = '8px';
      msgBar.style.fontSize = '1.1rem';
      msgBar.style.textAlign = 'center';
      msgBar.style.transition = 'opacity 0.3s, background 0.3s, color 0.3s';
      table.parentNode.insertBefore(msgBar, table);
    }

    // Highlight style (if not present)
    if (!document.getElementById('dp-row-action-highlight-style')) {
      var style = document.createElement('style');
      style.id = 'dp-row-action-highlight-style';
      style.innerHTML = `
        .dp-row-action-highlight {
          box-shadow: 0 0 0 3px #007bff, 0 0 10px #007bff55 !important;
          transition: box-shadow 9.3s;
          background-color: #fff5bd !important;
          animation: highlightAnimation 2s ease-in-out;
        }
      `;
      document.head.appendChild(style);
    }

    const btnMsg = {
      "Draft": "Drafted successfully",
      "Submit": "Submitted successfully",
      "Cancel": "Cancelled successfully"
    };
    const btnBg = {
      "Draft": "#d1eaff",    // blue
      "Submit": "#d4f7d4",   // green
      "Cancel": "#ffd6d6"    // red
    };
    const btnColor = {
      "Draft": "#0056b3",
      "Submit": "#218838",
      "Cancel": "#b30000"
    };

    document.querySelectorAll('.tray-scan-modal-buttons button').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.preventDefault();

        // 1. Close the modal immediately
        if (modal) modal.classList.remove('open');

        // 2. Show alert and highlight row
        let btnText = btn.textContent.trim();
        let msg = btnMsg[btnText] || "Action successful";
        let bg = btnBg[btnText] || "#d1eaff";
        let color = btnColor[btnText] || "#0056b3";
        if (msgBar) {
          msgBar.textContent = msg;
          msgBar.style.display = 'block';
          msgBar.style.opacity = '1';
          msgBar.style.background = bg;
          msgBar.style.color = color;
        }
        document.querySelectorAll('tr.highlighted-tray-scan').forEach(function(row) {
          row.classList.add('dp-row-action-highlight');
          setTimeout(function() {
            row.classList.remove('dp-row-action-highlight');
          }, 2000);
        });

        // 3. Hide alert after 2s (and redirect if needed)
        setTimeout(function() {
          if (msgBar) {
            msgBar.style.opacity = '0';
            setTimeout(function() { msgBar.style.display = 'none'; }, 300);
          }
          // Uncomment below if you want to redirect after alert
          // window.location.href = "{% url 'dp_pick_table' %}";
        }, 3000);
      });
    });
  });
</script>

<!-- script for buttons in form & highlight -->
<script nonce="{{ csp_nonce }}">
      document.addEventListener("DOMContentLoaded", function () {
        // 1. Save the active row when clicking a tray scan trigger.
        document.querySelectorAll(".tray-scan-btn").forEach(function(btn) {
          btn.addEventListener("click", function(e) {
            const row = e.target.closest("tr");
            if (row) {
              window.activeRow = row;
            }
            // Open the left modal (trayScanModal) as needed.
            const trayModal = document.getElementById("trayScanModal");
            if (trayModal) {
              trayModal.classList.add("open");
            }
          });
        });

        // 2. Attach click event handlers to popup action buttons (Draft, Submit, Cancel)
        document.querySelectorAll('.tray-scan-modal-buttons button').forEach(function(btn) {
          btn.addEventListener("click", function(e) {
            e.preventDefault();
            
            // Close both modals
            const newPopupModal = document.getElementById("newPopupModal");
            const trayScanModal = document.getElementById("trayScanModal");
            if (newPopupModal) newPopupModal.classList.remove("open");
            if (trayScanModal) trayScanModal.classList.remove("open");

            // Highlight the active row for a few seconds.
            document.querySelectorAll('#order-listing tbody tr').forEach(function(row) {
        row.classList.remove("dp-row-action-highlight");
      });

      if (window.activeRow) {
        window.activeRow.classList.add("dp-row-action-highlight");
        setTimeout(() => {
          window.activeRow.classList.remove("dp-row-action-highlight");
        }, 2000);
      }
      });
    });
  });
</script>

<!-- Active row highlighter for IQF Pick Table with close btn swap and clear bg -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function() {
  // Add highlight style if not present
  if (!document.getElementById('iqf-row-action-highlight-style')) {
    var style = document.createElement('style');
    style.id = 'iqf-row-action-highlight-style';
    style.innerHTML = `
      .iqf-row-action-highlight {
        transition: box-shadow 1.3s;
        background-color: #fff5bd !important;
        animation: highlightAnimation 2s ease-in-out;
      }
      .iqf-row-action-highlight td:nth-child(1),
      .iqf-row-action-highlight td:nth-child(2),
      .iqf-row-action-highlight td:nth-child(3) {
        background-color: #fff5bd !important;
      }
    `;
    document.head.appendChild(style);
  }

  let originalRowIndex = null;
  let movedRow = null;
  let placeholderRow = null;

  // Listen for clicks on Eye, Accept, and Reject buttons
  document.querySelectorAll('.tray-scan-btn-Jig, .btn-twitter, .btn-youtube').forEach(function(link) {
    link.addEventListener('click', function(event) {
      // Remove highlight from all rows
      document.querySelectorAll('tbody tr').forEach(function(row) {
        row.classList.remove('iqf-row-action-highlight');
      });
      // Move the clicked row to the top and highlight
      var row = event.target.closest('tr');
      if (row && row.parentNode) {
        const tbody = row.parentNode;
        if (tbody.firstElementChild !== row) {
          // If a previous move exists, restore it first
          if (movedRow && placeholderRow && placeholderRow.parentNode) {
            placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
            placeholderRow.parentNode.removeChild(placeholderRow);
            movedRow.classList.remove('iqf-row-action-highlight');
            movedRow = null;
            placeholderRow = null;
            originalRowIndex = null;
          }
          // Store original index and row
          originalRowIndex = Array.from(tbody.children).indexOf(row);
          movedRow = row;
          // Insert a placeholder at the original position
          placeholderRow = document.createElement('tr');
          placeholderRow.style.display = 'none';
          for (let i = 0; i < row.children.length; i++) {
            placeholderRow.appendChild(document.createElement('td'));
          }
          tbody.insertBefore(placeholderRow, tbody.children[originalRowIndex]);
          // Move row to top
          tbody.insertBefore(row, tbody.firstElementChild);
        }
        row.classList.add('iqf-row-action-highlight');
      }
    });
  });

  // Helper to restore row and clear highlight
  function restoreRowHighlight() {
    if (movedRow && placeholderRow && placeholderRow.parentNode) {
      placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
      placeholderRow.parentNode.removeChild(placeholderRow);
      movedRow.classList.remove('iqf-row-action-highlight');
      movedRow = null;
      placeholderRow = null;
      originalRowIndex = null;
    }
    document.querySelectorAll('tbody tr').forEach(function(row) {
      row.classList.remove('iqf-row-action-highlight');
      row.classList.remove('highlighted-tray-scan');
    });
  }

  // Swap close button position and clear highlight for all close buttons
  function swapAndClearCloseBtns() {
    // ✅ ADDED: Include delink modal's close icon (.delink-close) and cancel button (#cancelDelinkBtn)
    document.querySelectorAll('.close-btn, #closeTrayScanModal_DayPlanning, #closeTrayScanModal, #closetrayScanModal_BQ, #closeNewPopupModal, .delink-close, #cancelDelinkBtn').forEach(function(closeBtn) {
      closeBtn.addEventListener('click', function() {
          console.log('🔄 Restoring row for button:', closeBtn.id || closeBtn.className);
        // Swap close button position if parent uses flex
        var parent = closeBtn.parentElement;
        if (parent && parent.style.display && parent.style.display.includes('flex')) {
          if (closeBtn === parent.firstElementChild) {
            parent.appendChild(closeBtn);
          } else {
            parent.insertBefore(closeBtn, parent.firstElementChild);
          }
        }
        restoreRowHighlight();
      });
    });
  }
  swapAndClearCloseBtns();


  

  // --- FIX: Restore row and refresh browser on delink modal actions ---
  function handleDelinkModalActions() {
    function doRestoreAndReload() {
      restoreRowHighlight();
      window.location.reload();
    }
    // Attach to Submit, Cancel, and Close buttons in delink modal
    ['confirmDelinkBtn', 'cancelDelinkBtn'].forEach(function(id) {
      const btn = document.getElementById(id);
      if (btn) {
        btn.addEventListener('click', doRestoreAndReload);
      }
    });
    document.querySelectorAll('.delink-close').forEach(function(btn) {
      btn.addEventListener('click', doRestoreAndReload);
    });
  }
  handleDelinkModalActions();

  // If modal is dynamically recreated, re-attach handlers
  const delinkModal = document.getElementById('delinkModal');
  if (delinkModal) {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
          if (delinkModal.style.display === 'block') {
            setTimeout(handleDelinkModalActions, 100);
          }
        }
      });
    });
    observer.observe(delinkModal, { attributes: true });
  }
});
</script>

<!-- // --- Child Screen Lock Feature ---
// When child screen (tray scan modal) is open, only allow scroll and Eye icon (view) access on parent.
// All other actions (edit, delete, filter, etc.) are blocked visually and functionally.
-->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  function lockParentActions() {
    // Select only buttons/inputs/links in parent panels, exclude modal dialogs
    document.querySelectorAll(
      '.main-panel button, .sidebar button, .main-panel a, .sidebar a, .main-panel img, .sidebar img, .main-panel .hold-toggle-btn, .sidebar .hold-toggle-btn'
    ).forEach(function (el) {
      // Skip allowed elements: view eye, Add Jig
      if (
        el.closest('#rightSideModal') || 
        el.closest('#trayScanModal_DayPlanning') ||
        el.classList.contains('tray-scan-btn-Jig') || 
        el.closest('.tray-scan-btn')
      ) {
        return; // don’t lock modal internals or allowed buttons
      }

      // Disable everything else
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.filter = 'grayscale(1)';
      el.style.cursor = 'not-allowed';

      if (el.classList.contains('hold-toggle-btn')) el.disabled = true;
    });

    // Keep table scroll active
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = 'auto';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }  

  function unlockParentActions() {
    // Reset everything
    document.querySelectorAll('.main-panel *, .sidebar *').forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.filter = '';
      el.style.cursor = '';
      if (el.classList.contains('hold-toggle-btn')) el.disabled = false;
    });

    // Restore table scroll
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = '';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  // Listen for modal open/close
  var closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");

  // Lock parent when any view or Add Jig is clicked
  document.querySelectorAll('.tray-scan-btn-Jig, .tray-scan-btn').forEach(function(link) {
    link.addEventListener('click', function() {
      setTimeout(lockParentActions, 100);
    });
  });

  // Unlock when tray scan modal closes
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }

  // Also unlock when Add Jig modal closes (if you have a close button)
  var addJigClose = document.querySelector('#rightSideModal .close, #rightSideModal [data-bs-dismiss="modal"]');
  if (addJigClose) {
    addJigClose.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }
});
</script>

<!-- Barcode Scanner Script for IQF -->
<script nonce="{{ csp_nonce }}">
// ==========================================
// BARCODE SCANNER FUNCTIONALITY - IQF
// ==========================================
document.addEventListener("DOMContentLoaded", function () {
  // Scanner elements
  const scanBtn = document.getElementById("scanButton");
  const scanStatus = document.getElementById("scanStatusMessage");
  const scanInput = document.getElementById("scanHiddenInput");
  
  // Scanner state
  let isScanning = false;
  
  if (!scanBtn || !scanStatus || !scanInput) {
    console.log("❌ [IQF SCANNER] Required scanner elements not found");
    return;
  }
  
  console.log("✅ [IQF SCANNER] Scanner elements found and initialized");
  
  // Start scanning function
  function startScanning() {
    if (isScanning) return;
    
    isScanning = true;
    scanInput.value = "";
    scanInput.focus();
    
    scanBtn.innerHTML = '<i class="fa fa-stop" style="margin-right: 6px;"></i>Stop';
    scanStatus.style.display = "inline";
    scanStatus.textContent = "PLEASE SCAN";
    
    console.log("🎯 [IQF SCANNER] Scanning started");
  }
  
  // Stop scanning function
  function stopScanning() {
    if (!isScanning) return;
    
    isScanning = false;
    scanInput.value = "";
    scanInput.blur();
    
    scanBtn.innerHTML = '<i class="fa fa-qrcode" style="margin-right: 6px;"></i>Scan';
    scanStatus.style.display = "none";
    
    console.log("⏹️ [IQF SCANNER] Scanning stopped");
  }
  
  // Show scan error function
  function showScanError(message) {
    scanStatus.style.color = "#dc3545";
    scanStatus.textContent = message;
    scanStatus.style.display = "inline";
    scanInput.value = "";
    
    // Keep scanner active for retry
    if (isScanning) {
      scanInput.focus();
      
      // Reset to scanning mode after error
      setTimeout(() => {
        if (isScanning) {
          scanStatus.style.color = "#28a745";
          scanStatus.textContent = "PLEASE SCAN";
        }
      }, 3000);
    }
  }
  
  // Function to validate and process barcode
  function validateBarcode(trayId) {
    console.log("🔍 [IQF SCANNER] Processing tray ID:", trayId);
    
    // Find priority row (Draft first, then first available)
    openPriorityRowModal(trayId);
    
    // Optional: Log API response for debugging (doesn't affect modal opening)
    fetch(`/iqf/get_lot_id_for_tray/?tray_id=${encodeURIComponent(trayId)}`)
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          console.log("✅ [IQF SCANNER] Tray found in system - ID:", trayId, "Lot:", data.lot_id);
        } else {
          console.log("⚠️ [IQF SCANNER] Tray not in system, manual entry required:", trayId);
        }
      })
      .catch((error) => {
        console.log("⚠️ [IQF SCANNER] API error (modal still opened):", error);
      });
  }
  
  // Function to find and open priority row modal (Draft first, then first available)
  function openPriorityRowModal(trayId) {
    console.log("🎯 [IQF SCANNER] Finding priority row for tray ID:", trayId);
    
    const allDataRows = document.querySelectorAll('#order-listing tbody tr');
    
    if (allDataRows.length === 0) {
      showScanError("No data available in the table!");
      return;
    }
    
    let targetRow = null;
    let rowType = "";
    
    // Step 1: Look for the first "Draft" status row
    for (let i = 0; i < allDataRows.length; i++) {
      const row = allDataRows[i];
      const lotStatusCell = row.cells[14]; // Lot Status is the 15th column (index 14)
      
      if (lotStatusCell) {
        const statusText = lotStatusCell.textContent.trim();
        console.log(`🔍 [IQF SCANNER] Row ${i + 1} lot status:`, statusText);
        
        if (statusText.includes('Draft')) {
          console.log("✨ [IQF SCANNER] Found Draft row at position", i + 1);
          targetRow = row;
          rowType = "Draft";
          break;
        }
      }
    }
    
    // Step 2: If no Draft found, use the first available row
    if (!targetRow) {
      console.log("📝 [IQF SCANNER] No Draft rows found, using first available row");
      targetRow = allDataRows[0];
      rowType = "First Available";
    }
    
    // Find the View button in the target row (in Action column)
    const viewBtn = targetRow.querySelector('a[href="#"]');
    
    if (!viewBtn) {
      showScanError("View button not available for the selected row!");
      return;
    }
    
    const rowIndex = Array.from(allDataRows).indexOf(targetRow) + 1;
    console.log(`🎯 [IQF SCANNER] Opening ${rowType} modal for row ${rowIndex}`);
    
    // Store the scanned tray ID globally so it can be used when modal opens
    window.scannedTrayIdForIQFModal = trayId;
    
    // Click the View button to open modal
    viewBtn.click();
    
    // Pre-fill tray ID in modal after it opens
    setTimeout(() => {
      fillTrayIdInIQFModal(trayId);
    }, 500);
    
    scanStatus.style.color = "#28a745";
    scanStatus.textContent = `${rowType} modal opened!`;
    
    // Stop scanning after successful modal opening
    setTimeout(() => {
      stopScanning();
    }, 2000);
  }
  
  // Function to find and fill next empty tray ID slot in IQF modals
  function findAndFillNextEmptyTraySlot(modal, trayId) {
    console.log("🔍 [IQF DRAFT] Searching for next empty tray ID slot in Draft modal");
    
    // Find all tray ID input fields in the modal
    const trayIdInputs = modal.querySelectorAll([
      'input[placeholder*="Tray ID"]',
      'input[placeholder*="tray ID"]', 
      'input[placeholder*="Enter Tray"]',
      'input[id*="tray"]',
      'input[name*="tray"]',
      'input[data-tray-id]',
      'input[type="text"]:not([placeholder*="validation"]):not([placeholder*="info"])'
    ].join(', '));
    
    if (trayIdInputs.length === 0) {
      console.log("⚠️ [IQF DRAFT] No tray ID inputs found, using any text input as fallback");
      const allTextInputs = modal.querySelectorAll('input[type="text"]');
      if (allTextInputs.length > 0) {
        allTextInputs[0].focus();
        allTextInputs[0].value = trayId;
        console.log("📝 [IQF DRAFT] Used fallback text input");
        allTextInputs[0].dispatchEvent(new Event('input', { bubbles: true }));
      }
      return;
    }
    
    console.log(`🔍 [IQF DRAFT] Found ${trayIdInputs.length} tray ID input fields`);
    
    // Find the first truly empty slot
    let targetInput = null;
    let targetSlotIndex = -1;
    
    // Search through all inputs to find the first truly empty one
    for (let i = 0; i < trayIdInputs.length; i++) {
      const input = trayIdInputs[i];
      const currentValue = input.value ? input.value.trim() : '';
      
      console.log(`🔍 [IQF DRAFT] Checking slot ${i + 1}: "${currentValue}" (${currentValue ? 'filled' : 'empty'})`);
      
      if (!currentValue || currentValue === '') {
        targetInput = input;
        targetSlotIndex = i + 1;
        console.log(`✨ [IQF DRAFT] Found first empty slot at position ${targetSlotIndex}`);
        break;
      }
    }
    
    // Fill the target slot or warn if all are filled
    if (targetInput) {
      targetInput.focus();
      targetInput.value = trayId;
      console.log(`📝 [IQF DRAFT] Pre-filled tray ID "${trayId}" in slot ${targetSlotIndex}`);
      
      // Trigger input event for any validation
      targetInput.dispatchEvent(new Event('input', { bubbles: true }));
      targetInput.dispatchEvent(new Event('change', { bubbles: true }));
      
      // Update scan status with slot information
      scanStatus.textContent = `IQF Draft slot ${targetSlotIndex} filled!`;
      
      // ✅ NEW: Auto-trigger validation for Draft modal after filling
      setTimeout(() => {
        autoTriggerTrayValidation(modal, trayId, `Draft Slot ${targetSlotIndex}`);
      }, 200);
    } else {
      // All slots are filled - warn user instead of overwriting
      console.log("⚠️ [IQF DRAFT] All slots are filled - cannot add more tray IDs");
      scanStatus.style.color = "#dc3545";
      scanStatus.textContent = "All tray slots filled!";
      
      // Still focus on the last input for user awareness
      const lastInput = trayIdInputs[trayIdInputs.length - 1];
      if (lastInput) {
        lastInput.focus();
      }
      
      // Reset scanner status after warning
      setTimeout(() => {
        if (isScanning) {
          scanStatus.style.color = "#28a745";
          scanStatus.textContent = "PLEASE SCAN";
        }
      }, 3000);
    }
  }
  
  // Function to fill tray ID in IQF modal
  function fillTrayIdInIQFModal(trayId) {
    // Look for IQF specific modal
    const iqfModal = document.querySelector('[id*="iqf"], [class*="iqf"], [data-modal*="iqf"]');
    const genericModal = document.querySelector('.modal:not([style*="display: none"])');
    const activeModal = iqfModal || genericModal;
    
    if (!activeModal) {
      console.log("⚠️ [IQF SCANNER] No active modal found");
      return;
    }
    
    console.log("🎯 [IQF SCANNER] Found active modal, filling tray ID");
    
    // Check if this is a Draft modal by looking for existing filled tray IDs
    const existingTrayInputs = activeModal.querySelectorAll('input[type="text"]');
    let isDraftModal = false;
    
    for (const input of existingTrayInputs) {
      if (input.value && input.value.trim() && input.placeholder && input.placeholder.toLowerCase().includes('tray')) {
        isDraftModal = true;
        break;
      }
    }
    
    if (isDraftModal) {
      console.log("🔍 [IQF SCANNER] Detected Draft modal, using smart slot filling");
      findAndFillNextEmptyTraySlot(activeModal, trayId);
    } else {
      // Regular modal - fill first tray ID input
      const trayIdInput = activeModal.querySelector('input[placeholder*="Tray ID"], input[placeholder*="tray ID"], input[placeholder*="Enter Tray"], input[type="text"]');
      if (trayIdInput) {
        trayIdInput.focus();
        trayIdInput.value = trayId;
        console.log("📝 [IQF SCANNER] Pre-filled tray ID in regular modal:", trayId);
        
        // Trigger input event for any validation
        trayIdInput.dispatchEvent(new Event('input', { bubbles: true }));
        trayIdInput.dispatchEvent(new Event('change', { bubbles: true }));
        
        // Auto-trigger validation for regular modal after filling
        autoTriggerTrayValidation(activeModal, trayId, 'Regular');
      }
    }
  }
  
  // ✅ NEW: Auto-trigger tray validation after barcode scan
  function autoTriggerTrayValidation(modal, trayId, modalType) {
    console.log(`🚀 [IQF SCANNER] Auto-triggering validation for ${modalType} modal with tray ID: ${trayId}`);
    
    // Wait a moment for the tray ID to be properly filled
    setTimeout(() => {
      // Look for validation button with various possible selectors
      const validationBtn = modal.querySelector([
        'button[id*="trayValidate"]',           // #trayValidateBtn or similar
        'button[class*="tray-validate"]',       // .tray-validate-btn or similar  
        'button[onclick*="validate"]',          // onclick="validateTray()" or similar
        'button:contains("Validate")',          // Button with "Validate" text
        'input[type="button"][value*="Validate"]', // Input button with Validate value
        '.btn:contains("Validate")',            // Any button with Validate text
        '#trayValidateBtn',                     // Specific ID if known
        'button[data-action="validate"]'        // Data attribute approach
      ].join(', '));
      
      // Alternative approach: look for buttons with "validate" in text content
      let validateButton = validationBtn;
      if (!validateButton) {
        const allButtons = modal.querySelectorAll('button, input[type="button"], input[type="submit"]');
        for (const btn of allButtons) {
          const btnText = btn.textContent || btn.value || btn.title || '';
          if (btnText.toLowerCase().includes('validate') || btnText.toLowerCase().includes('check')) {
            validateButton = btn;
            console.log("🔍 [IQF SCANNER] Found validation button by text:", btnText);
            break;
          }
        }
      }
      
      if (validateButton && !validateButton.disabled) {
        console.log("✅ [IQF SCANNER] Auto-clicking Tray Validate button");
        validateButton.click();
        
        // Update scanner status
        scanStatus.style.color = "#28a745";
        scanStatus.textContent = `Validation triggered for ${modalType} modal!`;
        
        // Auto-stop scanning after successful validation trigger
        setTimeout(() => {
          stopScanning();
        }, 2000);
      } else {
        console.log("⚠️ [IQF SCANNER] Tray Validate button not found or disabled");
        console.log("Available buttons in modal:", Array.from(modal.querySelectorAll('button')).map(b => b.textContent || b.id || b.className));
        
        // Show warning but don't stop scanner
        scanStatus.style.color = "#ff8c00";
        scanStatus.textContent = "Tray filled - manual validation needed";
      }
    }, 300); // Small delay to ensure tray ID is properly set
  }
  
  // Button click handler
  scanBtn.addEventListener("click", function () {
    if (isScanning) {
      stopScanning();
    } else {
      startScanning();
    }
  });
  
  // Listen for Enter key (traditional scanner behavior)
  scanInput.addEventListener("keydown", function (e) {
    if (e.key === "Enter" && isScanning) {
      e.preventDefault();
      const trayId = scanInput.value.trim();
      if (trayId.length >= 4) {
        validateBarcode(trayId);
      }
    }
  });
  
  // Listen for input events (rapid typing or paste operations)
  scanInput.addEventListener("input", function (e) {
    if (isScanning) {
      const currentValue = scanInput.value.trim();
      
      // Auto-trigger on length threshold (common scanner behavior)
      if (currentValue.length >= 8) {
        setTimeout(() => {
          if (isScanning && scanInput.value.trim() === currentValue) {
            validateBarcode(currentValue);
          }
        }, 100);
      }
    }
  });
  
  // Listen for paste events (scanner apps that paste)
  scanInput.addEventListener("paste", function (e) {
    if (isScanning) {
      setTimeout(() => {
        const pastedValue = scanInput.value.trim();
        if (pastedValue.length >= 4) {
          validateBarcode(pastedValue);
        }
      }, 50);
    }
  });
  
  // Auto-stop scanning after inactivity
  let inactivityTimer;
  function resetInactivityTimer() {
    clearTimeout(inactivityTimer);
    if (isScanning) {
      inactivityTimer = setTimeout(() => {
        console.log("⏰ [IQF SCANNER] Auto-stopping due to inactivity");
        stopScanning();
      }, 30000); // 30 seconds
    }
  }
  
  scanInput.addEventListener("focus", resetInactivityTimer);
  scanInput.addEventListener("input", resetInactivityTimer);
  scanInput.addEventListener("keydown", resetInactivityTimer);
  
  console.log("✅ [IQF SCANNER] Barcode scanner initialized successfully");
});
</script>

<!-- Script for only numbers, alphabets (upper/lower), and hyphen (-) are allowed (no special characters) -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  console.log("🔤 [CHAR-FILTER] Character filtering script loaded");
  
  // Only allow: a-z, A-Z, 0-9, hyphen (-)
  function strictFilterInput(e) {
    // Allow navigation keys, backspace, delete, arrows, tab, enter
    if (
      e.ctrlKey || e.metaKey ||
      ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter', 'Home', 'End'].includes(e.key)
    ) return;

    // Block any character not matching allowed set
    if (!/^[a-zA-Z0-9\-]$/.test(e.key)) {
      e.preventDefault();
      console.log("🚫 [CHAR-FILTER] Blocked invalid character:", e.key);
      return false;
    }
  }

  function strictSanitizeValue(input) {
    const oldValue = input.value;
    // Remove all except allowed chars
    input.value = input.value.replace(/[^a-zA-Z0-9\-]/g, '');
    if (oldValue !== input.value) {
      console.log("✂️ [CHAR-FILTER] Sanitized input:", oldValue, "->", input.value);
    }
  }

  // Apply to all tray ID input boxes (delink, rejection, top tray, etc.)
  // ✅ ENHANCED: Include accepted-tray-id-input and form-control classes
  document.querySelectorAll(
    '.delink-tray-input, .tray-id-input, .rejection-tray-id-input, #topTrayIdInput, .accepted-tray-id-input, .form-control'
  ).forEach(function(input) {
    // Only apply to text inputs to avoid affecting other form controls
    if (input.type === 'text' || !input.type) {
      console.log("🔤 [CHAR-FILTER] Attaching to input:", input.className);
      
      input.addEventListener('keydown', strictFilterInput);
      input.addEventListener('input', function() {
        strictSanitizeValue(input);
      });
      input.addEventListener('paste', function(e) {
        setTimeout(function() {
          strictSanitizeValue(input);
        }, 0);
      });
    }
  });
  
  console.log("✅ [CHAR-FILTER] Character filtering setup complete");
});
</script>

<!-- Script for tray ID validation via AJAX & Restore-->
<script nonce="{{ csp_nonce }}">

  
// ==========================================
// ENHANCED TRAY ID VALIDATION FOR IQF WITH AUTO-SAVE
// ==========================================

// Global validation and auto-save functions (accessible from anywhere)
window.IQFTrayValidation = (function() {
  
  // ✅ AUTO-SAVE: Storage key prefix for modal data
  const STORAGE_PREFIX = 'iqf_modal_data_';
  
  // ✅ AUTO-SAVE: Save modal data to localStorage
  function saveModalData(lotId, data) {
    if (!lotId) return;
    try {
      const storageKey = STORAGE_PREFIX + lotId;
      const existingData = JSON.parse(localStorage.getItem(storageKey) || '{}');
      const mergedData = { ...existingData, ...data, lastSaved: Date.now() };
      localStorage.setItem(storageKey, JSON.stringify(mergedData));
      console.log('💾 [AUTO-SAVE] Saved modal data for lot:', lotId, mergedData);
    } catch (e) {
      console.error('❌ [AUTO-SAVE] Failed to save modal data:', e);
    }
  }
  
  // ✅ AUTO-SAVE: Load modal data from localStorage
  function loadModalData(lotId) {
    if (!lotId) return {};
    try {
      const storageKey = STORAGE_PREFIX + lotId;
      const data = JSON.parse(localStorage.getItem(storageKey) || '{}');
      console.log('📂 [AUTO-SAVE] Loaded modal data for lot:', lotId, data);
      return data;
    } catch (e) {
      console.error('❌ [AUTO-SAVE] Failed to load modal data:', e);
      return {};
    }
  }
  
  // ✅ AUTO-SAVE: Clear modal data
  function clearModalData(lotId) {
    if (!lotId) return;
    try {
      const storageKey = STORAGE_PREFIX + lotId;
      localStorage.removeItem(storageKey);
      console.log('🗑️ [AUTO-SAVE] Cleared modal data for lot:', lotId);
    } catch (e) {
      console.error('❌ [AUTO-SAVE] Failed to clear modal data:', e);
    }
  }
   
  // Helper to show validation feedback
  function showTrayIdValidation(input, isValid, message) {
    let errorDiv = input.parentElement.querySelector('.tray-id-error');
    if (errorDiv) errorDiv.remove();

    if (!isValid) {
      errorDiv = document.createElement('div');
      errorDiv.className = 'tray-id-error';
      errorDiv.style.color = '#d32f2f';
      errorDiv.style.fontSize = '11px';
      errorDiv.style.marginTop = '2px';
      errorDiv.style.fontWeight = 'bold';
      errorDiv.textContent = message || 'Invalid Tray ID';
      input.parentElement.appendChild(errorDiv);
      input.style.borderColor = '#dc3545';
      input.style.backgroundColor = '#fff5f5';
      input._hasError = true;
    } else {
      input.style.borderColor = '#28a745';
      input.style.backgroundColor = '#f8fff8';
      input._hasError = false;
    }
  }

  // Helper to get current lot ID (from modal or global)
  function getCurrentLotId() {
    const modal = document.getElementById('trayScanModal') || document.getElementById('delinkModal');
    if (modal && modal.dataset.stockLotId) return modal.dataset.stockLotId;
    if (modal && modal.dataset.lotId) return modal.dataset.lotId;
    const btn = document.querySelector('.btn-twitter');
    if (btn && btn.getAttribute('data-lot-id')) return btn.getAttribute('data-lot-id');
    return '';
  }

  // Helper to get tray qty for accepted tray row
  function getAcceptedTrayQty(input) {
    const row = input.closest('tr');
    if (!row) return 0;
    const qtyCell = row.querySelector('td:nth-child(3)');
    return qtyCell ? parseInt(qtyCell.textContent.trim()) || 0 : 0;
  }

  // Helper to get already allocated count for accepted trays
  function getAlreadyAllocated(input) {
    const allInputs = Array.from(document.querySelectorAll('.accepted-tray-id-input'));
    let count = 0;
    for (let inp of allInputs) {
      if (inp === input) break;
      if (inp.value.trim()) count++;
    }
    return count;
  }

  // ✅ ENHANCED: Main validation function with debouncing for performance
  function validateTrayId(input) {
    const trayId = input.value.trim();
    const lotId = getCurrentLotId();
    
    // Clear existing validation timeout
    if (input._validationTimeout) {
      clearTimeout(input._validationTimeout);
    }
    
    if (!trayId || !lotId) {
      showTrayIdValidation(input, false, 'Tray ID or Lot ID missing');
      return;
    }

    // ✅ IMMEDIATE feedback for instant response
    input.style.borderColor = '#ffc107';
    input.style.backgroundColor = '#fff8e1';
    
    // ✅ DEBOUNCED validation API call (250ms for instant feel)
    input._validationTimeout = setTimeout(() => {
      console.log('🔍 [VALIDATION] Validating tray ID:', trayId, 'for lot:', lotId);
      
      // Accepted tray validation uses a different endpoint
      if (input.classList.contains('accepted-tray-id-input')) {
        const trayQty = getAcceptedTrayQty(input);
        const alreadyAllocated = getAlreadyAllocated(input);
        fetch(`/iqf/iqf_reject_check_tray_id_simple/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}&tray_qty=${trayQty}&already_allocated=${alreadyAllocated}`)
          .then(res => res.json())
          .then(data => {
            console.log('✅ [VALIDATION] Accepted tray response:', data);
            if (data.exists && data.valid_for_rejection !== false) {
              showTrayIdValidation(input, true, '');
            } else {
              showTrayIdValidation(input, false, data.status_message || 'Invalid Tray ID');
            }
          })
          .catch(() => {
            showTrayIdValidation(input, false, 'Validation error');
          });
      } else {
        // Default validation for other tray inputs
        fetch(`/iqf/iqf_validate_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
          .then(res => res.json())
          .then(data => {
            console.log('✅ [VALIDATION] General tray response:', data);
            if (data.exists) {
              showTrayIdValidation(input, true, '');
            } else {
              showTrayIdValidation(input, false, 'Tray ID not valid for this lot');
            }
          })
          .catch(() => {
            showTrayIdValidation(input, false, 'Validation error');
          });
      }
    }, 250); // Fast response time
  }

  // Function to check if input should be validated (text inputs for tray IDs only)
  function shouldValidateInput(input) {
    // Must be a text input
    if (!input || input.tagName !== 'INPUT' || input.type !== 'text') {
      return false;
    }
    
    // Must be readonly = false (editable inputs only)
    if (input.hasAttribute('readonly') || input.readOnly) {
      return false;
    }
    
    // Must have relevant classes OR be in a tray-related context
    const relevantClasses = [
      'delink-tray-input', 
      'tray-id-input', 
      'rejection-tray-id-input', 
      'accepted-tray-id-input'
    ];
    
    const hasRelevantClass = relevantClasses.some(cls => input.classList.contains(cls));
    const isTopTrayInput = input.id === 'topTrayIdInput';
    const hasFormControlWithTrayContext = input.classList.contains('form-control') && 
      (input.placeholder && input.placeholder.toLowerCase().includes('tray')) ||
      (input.closest('[class*="tray"]') || input.closest('[id*="tray"]'));
    
    return hasRelevantClass || isTopTrayInput || hasFormControlWithTrayContext;
  }

  // ✅ ENHANCED: Function to attach validation and auto-save to specific input
  function attachValidationToInput(input) {
    if (!shouldValidateInput(input)) {
      return false;
    }
    
    // Prevent duplicate listeners
    if (input._iqfValidationAttached) {
      return true;
    }
    
    console.log('🔗 [IQF] Attaching validation + auto-save to:', input.className, input.placeholder);
    
    const lotId = getCurrentLotId();
    
    // ✅ ENHANCED: Input event for instant validation (as you type)
    input.addEventListener('input', function() {
      const currentLotId = getCurrentLotId();
      
      if (input.value.trim()) {
        validateTrayId(input);
        // Auto-save the value
        autoSaveInputValue(input, currentLotId);
      } else {
        input.style.borderColor = '';
        input.style.backgroundColor = '';
        let errorDiv = input.parentElement.querySelector('.tray-id-error');
        if (errorDiv) errorDiv.remove();
        input._hasError = false;
      }
    });
    
    // ✅ ENHANCED: Keydown event for immediate response (before input event)
    input.addEventListener('keydown', function(e) {
      // For instant visual feedback, start validation on keydown
      if (e.key.length === 1 || e.key === 'Backspace' || e.key === 'Delete') {
        // Show "validating" state immediately
        setTimeout(() => {
          if (input.value.trim()) {
            input.style.borderColor = '#ffc107';
            input.style.backgroundColor = '#fff8e1';
          }
        }, 10);
      }
    });
    
    // Blur event for final validation
    input.addEventListener('blur', function() {
      const currentLotId = getCurrentLotId();
      if (input.value.trim()) {
        validateTrayId(input);
        autoSaveInputValue(input, currentLotId);
      }
    });
    
    // Focus event to restore data if needed
    input.addEventListener('focus', function() {
      const currentLotId = getCurrentLotId();
      if (!input.value.trim() && currentLotId) {
        const savedData = loadModalData(currentLotId);
        const inputId = input.id || input.name || input.className;
        const savedInput = savedData[inputId];
        if (savedInput && savedInput.value) {
          input.value = savedInput.value;
          setTimeout(() => validateTrayId(input), 100);
        }
      }
    });
    
    // Mark as processed
    input._iqfValidationAttached = true;
    return true;
  }

  // Public function to attach validation to all relevant inputs in container
  function attachValidationToContainer(container = document) {
    console.log('🔄 [IQF] Scanning container for tray inputs:', container);
    
    const selectors = [
      '.delink-tray-input', 
      '.tray-id-input', 
      '.rejection-tray-id-input', 
      '#topTrayIdInput', 
      '.accepted-tray-id-input', 
      '.form-control'
    ];
    
    let attachedCount = 0;
    
    selectors.forEach(selector => {
      const inputs = container.querySelectorAll(selector);
      inputs.forEach(input => {
        if (attachValidationToInput(input)) {
          attachedCount++;
        }
      });
    });
    
    console.log(`✅ [IQF] Attached validation to ${attachedCount} tray inputs`);
    
    // ✅ AUTO-SAVE: Restore saved data for this container
    const lotId = getCurrentLotId();
    if (lotId) {
      setTimeout(() => restoreInputValues(container, lotId), 100);
    }
    
    return attachedCount;
  }

  // ✅ AUTO-SAVE: Enhanced modal opening handler
  function onModalOpen(modal, lotId) {
    console.log('🔄 [AUTO-SAVE] Modal opened for lot:', lotId);
    
    // Attach validation to modal content
    attachValidationToContainer(modal);
    
    // Setup auto-save for the modal
    setupModalAutoSave(modal, lotId);
  }
  
  // ✅ AUTO-SAVE: Setup auto-save for modal
  function setupModalAutoSave(modal, lotId) {
    if (!modal || !lotId) return;
    
    // Save data when modal is closed
    const originalClose = modal.style.display;
    
    // Monitor for modal close events
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
          const isHidden = modal.style.display === 'none' || 
                          !modal.classList.contains('open') ||
                          modal.style.visibility === 'hidden';
          
          if (isHidden && !modal._autoSaved) {
            console.log('💾 [AUTO-SAVE] Modal closing, saving data...');
            saveAllModalInputs(modal, lotId);
            modal._autoSaved = true;
            setTimeout(() => { modal._autoSaved = false; }, 1000);
          }
        }
      });
    });
    
    observer.observe(modal, { attributes: true, attributeFilter: ['style', 'class'] });
    
    // Also save on window beforeunload
    const saveHandler = () => saveAllModalInputs(modal, lotId);
    window.addEventListener('beforeunload', saveHandler);
    
    // Store cleanup function
    modal._autoSaveCleanup = () => {
      observer.disconnect();
      window.removeEventListener('beforeunload', saveHandler);
    };
  }
  
  // ✅ AUTO-SAVE: Save all inputs in modal
  function saveAllModalInputs(modal, lotId) {
    if (!modal || !lotId) return;
    
    const inputs = modal.querySelectorAll('input[type="text"], input[type="number"], textarea');
    const dataToSave = {};
    let savedCount = 0;
    
    inputs.forEach(input => {
      if (input.value.trim()) {
        const inputId = input.id || input.name || input.className || `input_${savedCount}`;
        dataToSave[inputId] = {
          value: input.value,
          timestamp: Date.now(),
          placeholder: input.placeholder,
          type: input.type
        };
        savedCount++;
      }
    });
    
    if (savedCount > 0) {
      saveModalData(lotId, dataToSave);
      console.log(`💾 [AUTO-SAVE] Saved ${savedCount} inputs for lot ${lotId}`);
    }
  }

  // Public API
  return {
    attachToContainer: attachValidationToContainer,
    attachToInput: attachValidationToInput,
    validateInput: validateTrayId,
    shouldValidate: shouldValidateInput,
    // ✅ AUTO-SAVE: Public auto-save functions
    saveModalData: saveModalData,
    loadModalData: loadModalData,
    clearModalData: clearModalData,
    onModalOpen: onModalOpen,
    restoreInputValues: restoreInputValues,
    saveAllModalInputs: saveAllModalInputs
  };
})();

// Initialize validation on DOM ready
document.addEventListener("DOMContentLoaded", function () {
  console.log('🚀 [IQF] Initializing tray validation system...');
  window.IQFTrayValidation.attachToContainer(document);
  
  // Monitor for dynamically added inputs using MutationObserver
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.type === 'childList') {
        mutation.addedNodes.forEach(function(node) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // Check if the added node is an input or contains inputs
            if (node.tagName === 'INPUT') {
              window.IQFTrayValidation.attachToInput(node);
            } else {
              // Check for inputs within the added node
              window.IQFTrayValidation.attachToContainer(node);
            }
          }
        });
      }
    });
  });
  
  // Start observing the document for changes
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  console.log('✅ [IQF] Tray validation system initialized with dynamic monitoring');
});
</script>

<script nonce="{{ csp_nonce }}">
// ==========================================
// INITIALIZE AUTO-SAVE SYSTEM ON PAGE LOAD
// ==========================================

document.addEventListener('DOMContentLoaded', function() {
  console.log('🚀 [AUTO-SAVE] Initializing IQF auto-save system');
  
  // Make autoSaveManager globally available
  window.iqfAutoSaveManager = autoSaveManager;
  
  // Setup auto-save for any existing modals
  setTimeout(() => {
    // Look for any open modals and setup auto-save
    const openModal = document.querySelector('.tray-scan-modal.open');
    if (openModal) {
      // Extract lot ID from modal or button
      const lotId = extractLotIdFromContext();
      if (lotId) {
        autoSaveManager.setupAutoSaveListeners(lotId, '');
        console.log('✅ [AUTO-SAVE] Setup auto-save for existing open modal');
      }
    }
  }, 1000);
});

// Helper to extract lot ID from various sources
function extractLotIdFromContext() {
  // Method 1: From tray scan button
  const trayScanBtn = document.querySelector('.tray-scan-btn[data-lot-id]');
  if (trayScanBtn) {
    return trayScanBtn.getAttribute('data-lot-id');
  }
  
  // Method 2: From any button with data-lot-id
  const anyBtn = document.querySelector('[data-lot-id]');
  if (anyBtn) {
    return anyBtn.getAttribute('data-lot-id');
  }
  
  // Method 3: From global variable if set
  if (window.currentOptimalDistributionLotId) {
    return window.currentOptimalDistributionLotId;
  }
  
  return null;
}

console.log('✅ [AUTO-SAVE] IQF Auto-save system loaded successfully');


</script>

{% endblock %} {% endblock content %}